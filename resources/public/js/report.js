
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
/*!
 * Vue.js v2.6.12
 * (c) 2014-2020 Evan You
 * Released under the MIT License.
 */
/*  */

var emptyObject = Object.freeze({});

// These helpers produce better VM code in JS engines due to their
// explicitness and function inlining.
function isUndef (v) {
    return v === undefined || v === null
}

function isDef (v) {
    return v !== undefined && v !== null
}

function isTrue (v) {
    return v === true
}

function isFalse (v) {
    return v === false
}

/**
 * Check if value is primitive.
 */
function isPrimitive (value) {
    return (
        typeof value === 'string' ||
        typeof value === 'number' ||
        // $flow-disable-line
        typeof value === 'symbol' ||
        typeof value === 'boolean'
    )
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject$4 (obj) {
    return obj !== null && typeof obj === 'object'
}

/**
 * Get the raw type string of a value, e.g., [object Object].
 */
var _toString = Object.prototype.toString;

function toRawType (value) {
    return _toString.call(value).slice(8, -1)
}

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject$2 (obj) {
    return _toString.call(obj) === '[object Object]'
}

function isRegExp (v) {
    return _toString.call(v) === '[object RegExp]'
}

/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex (val) {
    var n = parseFloat(String(val));
    return n >= 0 && Math.floor(n) === n && isFinite(val)
}

function isPromise$1 (val) {
    return (
        isDef(val) &&
        typeof val.then === 'function' &&
        typeof val.catch === 'function'
    )
}

/**
 * Convert a value to a string that is actually rendered.
 */
function toString$2 (val) {
    return val == null
        ? ''
        : Array.isArray(val) || (isPlainObject$2(val) && val.toString === _toString)
            ? JSON.stringify(val, null, 2)
            : String(val)
}

/**
 * Convert an input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber (val) {
    var n = parseFloat(val);
    return isNaN(n) ? val : n
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap (
    str,
    expectsLowerCase
) {
    var map = Object.create(null);
    var list = str.split(',');
    for (var i = 0; i < list.length; i++) {
        map[list[i]] = true;
    }
    return expectsLowerCase
        ? function (val) { return map[val.toLowerCase()]; }
        : function (val) { return map[val]; }
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Check if an attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

/**
 * Remove an item from an array.
 */
function remove (arr, item) {
    if (arr.length) {
        var index = arr.indexOf(item);
        if (index > -1) {
            return arr.splice(index, 1)
        }
    }
}

/**
 * Check whether an object has the property.
 */
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
function hasOwn (obj, key) {
    return hasOwnProperty$1.call(obj, key)
}

/**
 * Create a cached version of a pure function.
 */
function cached (fn) {
    var cache = Object.create(null);
    return (function cachedFn (str) {
        var hit = cache[str];
        return hit || (cache[str] = fn(str))
    })
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
    return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
    return str.charAt(0).toUpperCase() + str.slice(1)
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
    return str.replace(hyphenateRE, '-$1').toLowerCase()
});

/**
 * Simple bind polyfill for environments that do not support it,
 * e.g., PhantomJS 1.x. Technically, we don't need this anymore
 * since native bind is now performant enough in most browsers.
 * But removing it would mean breaking code that was able to run in
 * PhantomJS 1.x, so this must be kept for backward compatibility.
 */

/* istanbul ignore next */
function polyfillBind (fn, ctx) {
    function boundFn (a) {
        var l = arguments.length;
        return l
            ? l > 1
                ? fn.apply(ctx, arguments)
                : fn.call(ctx, a)
            : fn.call(ctx)
    }

    boundFn._length = fn.length;
    return boundFn
}

function nativeBind (fn, ctx) {
    return fn.bind(ctx)
}

var bind$2 = Function.prototype.bind
    ? nativeBind
    : polyfillBind;

/**
 * Convert an Array-like object to a real Array.
 */
function toArray (list, start) {
    start = start || 0;
    var i = list.length - start;
    var ret = new Array(i);
    while (i--) {
        ret[i] = list[i + start];
    }
    return ret
}

/**
 * Mix properties into target object.
 */
function extend$1 (to, _from) {
    for (var key in _from) {
        to[key] = _from[key];
    }
    return to
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject (arr) {
    var res = {};
    for (var i = 0; i < arr.length; i++) {
        if (arr[i]) {
            extend$1(res, arr[i]);
        }
    }
    return res
}

/* eslint-disable no-unused-vars */

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 */
function noop$1 (a, b, c) {}

/**
 * Always return false.
 */
var no = function (a, b, c) { return false; };

/* eslint-enable no-unused-vars */

/**
 * Return the same value.
 */
var identity$1 = function (_) { return _; };

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual$1 (a, b) {
    if (a === b) { return true }
    var isObjectA = isObject$4(a);
    var isObjectB = isObject$4(b);
    if (isObjectA && isObjectB) {
        try {
            var isArrayA = Array.isArray(a);
            var isArrayB = Array.isArray(b);
            if (isArrayA && isArrayB) {
                return a.length === b.length && a.every(function (e, i) {
                    return looseEqual$1(e, b[i])
                })
            } else if (a instanceof Date && b instanceof Date) {
                return a.getTime() === b.getTime()
            } else if (!isArrayA && !isArrayB) {
                var keysA = Object.keys(a);
                var keysB = Object.keys(b);
                return keysA.length === keysB.length && keysA.every(function (key) {
                    return looseEqual$1(a[key], b[key])
                })
            } else {
                /* istanbul ignore next */
                return false
            }
        } catch (e) {
            /* istanbul ignore next */
            return false
        }
    } else if (!isObjectA && !isObjectB) {
        return String(a) === String(b)
    } else {
        return false
    }
}

/**
 * Return the first index at which a loosely equal value can be
 * found in the array (if value is a plain object, the array must
 * contain an object of the same shape), or -1 if it is not present.
 */
function looseIndexOf (arr, val) {
    for (var i = 0; i < arr.length; i++) {
        if (looseEqual$1(arr[i], val)) { return i }
    }
    return -1
}

/**
 * Ensure a function is called only once.
 */
function once (fn) {
    var called = false;
    return function () {
        if (!called) {
            called = true;
            fn.apply(this, arguments);
        }
    }
}

var SSR_ATTR = 'data-server-rendered';

var ASSET_TYPES = [
    'component',
    'directive',
    'filter'
];

var LIFECYCLE_HOOKS = [
    'beforeCreate',
    'created',
    'beforeMount',
    'mounted',
    'beforeUpdate',
    'updated',
    'beforeDestroy',
    'destroyed',
    'activated',
    'deactivated',
    'errorCaptured',
    'serverPrefetch'
];

/*  */



var config = ({
    /**
     * Option merge strategies (used in core/util/options)
     */
    // $flow-disable-line
    optionMergeStrategies: Object.create(null),

    /**
     * Whether to suppress warnings.
     */
    silent: false,

    /**
     * Show production mode tip message on boot?
     */
    productionTip: "development" !== 'production',

    /**
     * Whether to enable devtools
     */
    devtools: "development" !== 'production',

    /**
     * Whether to record perf
     */
    performance: false,

    /**
     * Error handler for watcher errors
     */
    errorHandler: null,

    /**
     * Warn handler for watcher warns
     */
    warnHandler: null,

    /**
     * Ignore certain custom elements
     */
    ignoredElements: [],

    /**
     * Custom user key aliases for v-on
     */
    // $flow-disable-line
    keyCodes: Object.create(null),

    /**
     * Check if a tag is reserved so that it cannot be registered as a
     * component. This is platform-dependent and may be overwritten.
     */
    isReservedTag: no,

    /**
     * Check if an attribute is reserved so that it cannot be used as a component
     * prop. This is platform-dependent and may be overwritten.
     */
    isReservedAttr: no,

    /**
     * Check if a tag is an unknown element.
     * Platform-dependent.
     */
    isUnknownElement: no,

    /**
     * Get the namespace of an element
     */
    getTagNamespace: noop$1,

    /**
     * Parse the real tag name for the specific platform.
     */
    parsePlatformTagName: identity$1,

    /**
     * Check if an attribute must be bound using property, e.g. value
     * Platform-dependent.
     */
    mustUseProp: no,

    /**
     * Perform updates asynchronously. Intended to be used by Vue Test Utils
     * This will significantly reduce performance if set to false.
     */
    async: true,

    /**
     * Exposed for legacy reasons
     */
    _lifecycleHooks: LIFECYCLE_HOOKS
});

/*  */

/**
 * unicode letters used for parsing html tags, component names and property paths.
 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
 */
var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;

/**
 * Check if a string starts with $ or _
 */
function isReserved (str) {
    var c = (str + '').charCodeAt(0);
    return c === 0x24 || c === 0x5F
}

/**
 * Define a property.
 */
function def (obj, key, val, enumerable) {
    Object.defineProperty(obj, key, {
        value: val,
        enumerable: !!enumerable,
        writable: true,
        configurable: true
    });
}

/**
 * Parse simple path.
 */
var bailRE = new RegExp(("[^" + (unicodeRegExp.source) + ".$_\\d]"));
function parsePath (path) {
    if (bailRE.test(path)) {
        return
    }
    var segments = path.split('.');
    return function (obj) {
        for (var i = 0; i < segments.length; i++) {
            if (!obj) { return }
            obj = obj[segments[i]];
        }
        return obj
    }
}

/*  */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE$1 = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
(UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');
var isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');
UA && /chrome\/\d+/.test(UA) && !isEdge;
UA && /phantomjs/.test(UA);
var isFF = UA && UA.match(/firefox\/(\d+)/);

// Firefox has a "watch" function on Object.prototype...
var nativeWatch = ({}).watch;

var supportsPassive = false;
if (inBrowser) {
    try {
        var opts = {};
        Object.defineProperty(opts, 'passive', ({
            get: function get () {
                /* istanbul ignore next */
                supportsPassive = true;
            }
        })); // https://github.com/facebook/flow/issues/285
        window.addEventListener('test-passive', null, opts);
    } catch (e) {}
}

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function () {
    if (_isServer === undefined) {
        /* istanbul ignore if */
        if (!inBrowser && !inWeex && typeof global !== 'undefined') {
            // detect presence of vue-server-renderer and avoid
            // Webpack shimming the process
            _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';
        } else {
            _isServer = false;
        }
    }
    return _isServer
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative (Ctor) {
    return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
}

var hasSymbol =
    typeof Symbol !== 'undefined' && isNative(Symbol) &&
    typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */ // $flow-disable-line
if (typeof Set !== 'undefined' && isNative(Set)) {
    // use native Set when available.
    _Set = Set;
} else {
    // a non-standard Set polyfill that only works with primitive keys.
    _Set = /*@__PURE__*/(function () {
        function Set () {
            this.set = Object.create(null);
        }
        Set.prototype.has = function has (key) {
            return this.set[key] === true
        };
        Set.prototype.add = function add (key) {
            this.set[key] = true;
        };
        Set.prototype.clear = function clear () {
            this.set = Object.create(null);
        };

        return Set;
    }());
}

/*  */

var warn$1 = noop$1;
var tip = noop$1;
var generateComponentTrace = (noop$1); // work around flow check
var formatComponentName = (noop$1);

{
    var hasConsole = typeof console !== 'undefined';
    var classifyRE = /(?:^|[-_])(\w)/g;
    var classify = function (str) { return str
        .replace(classifyRE, function (c) { return c.toUpperCase(); })
        .replace(/[-_]/g, ''); };

    warn$1 = function (msg, vm) {
        var trace = vm ? generateComponentTrace(vm) : '';

        if (config.warnHandler) {
            config.warnHandler.call(null, msg, vm, trace);
        } else if (hasConsole && (!config.silent)) {
            console.error(("[Vue warn]: " + msg + trace));
        }
    };

    tip = function (msg, vm) {
        if (hasConsole && (!config.silent)) {
            console.warn("[Vue tip]: " + msg + (
                vm ? generateComponentTrace(vm) : ''
            ));
        }
    };

    formatComponentName = function (vm, includeFile) {
        if (vm.$root === vm) {
            return '<Root>'
        }
        var options = typeof vm === 'function' && vm.cid != null
            ? vm.options
            : vm._isVue
                ? vm.$options || vm.constructor.options
                : vm;
        var name = options.name || options._componentTag;
        var file = options.__file;
        if (!name && file) {
            var match = file.match(/([^/\\]+)\.vue$/);
            name = match && match[1];
        }

        return (
            (name ? ("<" + (classify(name)) + ">") : "<Anonymous>") +
            (file && includeFile !== false ? (" at " + file) : '')
        )
    };

    var repeat$1 = function (str, n) {
        var res = '';
        while (n) {
            if (n % 2 === 1) { res += str; }
            if (n > 1) { str += str; }
            n >>= 1;
        }
        return res
    };

    generateComponentTrace = function (vm) {
        if (vm._isVue && vm.$parent) {
            var tree = [];
            var currentRecursiveSequence = 0;
            while (vm) {
                if (tree.length > 0) {
                    var last = tree[tree.length - 1];
                    if (last.constructor === vm.constructor) {
                        currentRecursiveSequence++;
                        vm = vm.$parent;
                        continue
                    } else if (currentRecursiveSequence > 0) {
                        tree[tree.length - 1] = [last, currentRecursiveSequence];
                        currentRecursiveSequence = 0;
                    }
                }
                tree.push(vm);
                vm = vm.$parent;
            }
            return '\n\nfound in\n\n' + tree
                .map(function (vm, i) { return ("" + (i === 0 ? '---> ' : repeat$1(' ', 5 + i * 2)) + (Array.isArray(vm)
                    ? ((formatComponentName(vm[0])) + "... (" + (vm[1]) + " recursive calls)")
                    : formatComponentName(vm))); })
                .join('\n')
        } else {
            return ("\n\n(found in " + (formatComponentName(vm)) + ")")
        }
    };
}

/*  */

var uid$1 = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep () {
    this.id = uid$1++;
    this.subs = [];
};

Dep.prototype.addSub = function addSub (sub) {
    this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub (sub) {
    remove(this.subs, sub);
};

Dep.prototype.depend = function depend () {
    if (Dep.target) {
        Dep.target.addDep(this);
    }
};

Dep.prototype.notify = function notify () {
    // stabilize the subscriber list first
    var subs = this.subs.slice();
    if (!config.async) {
        // subs aren't sorted in scheduler if not running async
        // we need to sort them now to make sure they fire in correct
        // order
        subs.sort(function (a, b) { return a.id - b.id; });
    }
    for (var i = 0, l = subs.length; i < l; i++) {
        subs[i].update();
    }
};

// The current target watcher being evaluated.
// This is globally unique because only one watcher
// can be evaluated at a time.
Dep.target = null;
var targetStack = [];

function pushTarget (target) {
    targetStack.push(target);
    Dep.target = target;
}

function popTarget () {
    targetStack.pop();
    Dep.target = targetStack[targetStack.length - 1];
}

/*  */

var VNode = function VNode (
    tag,
    data,
    children,
    text,
    elm,
    context,
    componentOptions,
    asyncFactory
) {
    this.tag = tag;
    this.data = data;
    this.children = children;
    this.text = text;
    this.elm = elm;
    this.ns = undefined;
    this.context = context;
    this.fnContext = undefined;
    this.fnOptions = undefined;
    this.fnScopeId = undefined;
    this.key = data && data.key;
    this.componentOptions = componentOptions;
    this.componentInstance = undefined;
    this.parent = undefined;
    this.raw = false;
    this.isStatic = false;
    this.isRootInsert = true;
    this.isComment = false;
    this.isCloned = false;
    this.isOnce = false;
    this.asyncFactory = asyncFactory;
    this.asyncMeta = undefined;
    this.isAsyncPlaceholder = false;
};

var prototypeAccessors$2 = { child: { configurable: true } };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors$2.child.get = function () {
    return this.componentInstance
};

Object.defineProperties( VNode.prototype, prototypeAccessors$2 );

var createEmptyVNode = function (text) {
    if ( text === void 0 ) text = '';

    var node = new VNode();
    node.text = text;
    node.isComment = true;
    return node
};

function createTextVNode (val) {
    return new VNode(undefined, undefined, undefined, String(val))
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode (vnode) {
    var cloned = new VNode(
        vnode.tag,
        vnode.data,
        // #7975
        // clone children array to avoid mutating original in case of cloning
        // a child.
        vnode.children && vnode.children.slice(),
        vnode.text,
        vnode.elm,
        vnode.context,
        vnode.componentOptions,
        vnode.asyncFactory
    );
    cloned.ns = vnode.ns;
    cloned.isStatic = vnode.isStatic;
    cloned.key = vnode.key;
    cloned.isComment = vnode.isComment;
    cloned.fnContext = vnode.fnContext;
    cloned.fnOptions = vnode.fnOptions;
    cloned.fnScopeId = vnode.fnScopeId;
    cloned.asyncMeta = vnode.asyncMeta;
    cloned.isCloned = true;
    return cloned
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);

var methodsToPatch = [
    'push',
    'pop',
    'shift',
    'unshift',
    'splice',
    'sort',
    'reverse'
];

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
    // cache original method
    var original = arrayProto[method];
    def(arrayMethods, method, function mutator () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var result = original.apply(this, args);
        var ob = this.__ob__;
        var inserted;
        switch (method) {
            case 'push':
            case 'unshift':
                inserted = args;
                break
            case 'splice':
                inserted = args.slice(2);
                break
        }
        if (inserted) { ob.observeArray(inserted); }
        // notify change
        ob.dep.notify();
        return result
    });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */
var shouldObserve = true;

function toggleObserving (value) {
    shouldObserve = value;
}

/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */
var Observer = function Observer (value) {
    this.value = value;
    this.dep = new Dep();
    this.vmCount = 0;
    def(value, '__ob__', this);
    if (Array.isArray(value)) {
        if (hasProto) {
            protoAugment(value, arrayMethods);
        } else {
            copyAugment(value, arrayMethods, arrayKeys);
        }
        this.observeArray(value);
    } else {
        this.walk(value);
    }
};

/**
 * Walk through all properties and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk (obj) {
    var keys = Object.keys(obj);
    for (var i = 0; i < keys.length; i++) {
        defineReactive$$1(obj, keys[i]);
    }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray (items) {
    for (var i = 0, l = items.length; i < l; i++) {
        observe(items[i]);
    }
};

// helpers

/**
 * Augment a target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment (target, src) {
    /* eslint-disable no-proto */
    target.__proto__ = src;
    /* eslint-enable no-proto */
}

/**
 * Augment a target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment (target, src, keys) {
    for (var i = 0, l = keys.length; i < l; i++) {
        var key = keys[i];
        def(target, key, src[key]);
    }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe (value, asRootData) {
    if (!isObject$4(value) || value instanceof VNode) {
        return
    }
    var ob;
    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
        ob = value.__ob__;
    } else if (
        shouldObserve &&
        !isServerRendering() &&
        (Array.isArray(value) || isPlainObject$2(value)) &&
        Object.isExtensible(value) &&
        !value._isVue
    ) {
        ob = new Observer(value);
    }
    if (asRootData && ob) {
        ob.vmCount++;
    }
    return ob
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive$$1 (
    obj,
    key,
    val,
    customSetter,
    shallow
) {
    var dep = new Dep();

    var property = Object.getOwnPropertyDescriptor(obj, key);
    if (property && property.configurable === false) {
        return
    }

    // cater for pre-defined getter/setters
    var getter = property && property.get;
    var setter = property && property.set;
    if ((!getter || setter) && arguments.length === 2) {
        val = obj[key];
    }

    var childOb = !shallow && observe(val);
    Object.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        get: function reactiveGetter () {
            var value = getter ? getter.call(obj) : val;
            if (Dep.target) {
                dep.depend();
                if (childOb) {
                    childOb.dep.depend();
                    if (Array.isArray(value)) {
                        dependArray(value);
                    }
                }
            }
            return value
        },
        set: function reactiveSetter (newVal) {
            var value = getter ? getter.call(obj) : val;
            /* eslint-disable no-self-compare */
            if (newVal === value || (newVal !== newVal && value !== value)) {
                return
            }
            /* eslint-enable no-self-compare */
            if (customSetter) {
                customSetter();
            }
            // #7981: for accessor properties without setter
            if (getter && !setter) { return }
            if (setter) {
                setter.call(obj, newVal);
            } else {
                val = newVal;
            }
            childOb = !shallow && observe(newVal);
            dep.notify();
        }
    });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set$1 (target, key, val) {
    if ((isUndef(target) || isPrimitive(target))
    ) {
        warn$1(("Cannot set reactive property on undefined, null, or primitive value: " + ((target))));
    }
    if (Array.isArray(target) && isValidArrayIndex(key)) {
        target.length = Math.max(target.length, key);
        target.splice(key, 1, val);
        return val
    }
    if (key in target && !(key in Object.prototype)) {
        target[key] = val;
        return val
    }
    var ob = (target).__ob__;
    if (target._isVue || (ob && ob.vmCount)) {
        warn$1(
            'Avoid adding reactive properties to a Vue instance or its root $data ' +
            'at runtime - declare it upfront in the data option.'
        );
        return val
    }
    if (!ob) {
        target[key] = val;
        return val
    }
    defineReactive$$1(ob.value, key, val);
    ob.dep.notify();
    return val
}

/**
 * Delete a property and trigger change if necessary.
 */
function del (target, key) {
    if ((isUndef(target) || isPrimitive(target))
    ) {
        warn$1(("Cannot delete reactive property on undefined, null, or primitive value: " + ((target))));
    }
    if (Array.isArray(target) && isValidArrayIndex(key)) {
        target.splice(key, 1);
        return
    }
    var ob = (target).__ob__;
    if (target._isVue || (ob && ob.vmCount)) {
        warn$1(
            'Avoid deleting properties on a Vue instance or its root $data ' +
            '- just set it to null.'
        );
        return
    }
    if (!hasOwn(target, key)) {
        return
    }
    delete target[key];
    if (!ob) {
        return
    }
    ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray (value) {
    for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
        e = value[i];
        e && e.__ob__ && e.__ob__.dep.depend();
        if (Array.isArray(e)) {
            dependArray(e);
        }
    }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
{
    strats.el = strats.propsData = function (parent, child, vm, key) {
        if (!vm) {
            warn$1(
                "option \"" + key + "\" can only be used during instance " +
                'creation with the `new` keyword.'
            );
        }
        return defaultStrat(parent, child)
    };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData (to, from) {
    if (!from) { return to }
    var key, toVal, fromVal;

    var keys = hasSymbol
        ? Reflect.ownKeys(from)
        : Object.keys(from);

    for (var i = 0; i < keys.length; i++) {
        key = keys[i];
        // in case the object is already observed...
        if (key === '__ob__') { continue }
        toVal = to[key];
        fromVal = from[key];
        if (!hasOwn(to, key)) {
            set$1(to, key, fromVal);
        } else if (
            toVal !== fromVal &&
            isPlainObject$2(toVal) &&
            isPlainObject$2(fromVal)
        ) {
            mergeData(toVal, fromVal);
        }
    }
    return to
}

/**
 * Data
 */
function mergeDataOrFn (
    parentVal,
    childVal,
    vm
) {
    if (!vm) {
        // in a Vue.extend merge, both should be functions
        if (!childVal) {
            return parentVal
        }
        if (!parentVal) {
            return childVal
        }
        // when parentVal & childVal are both present,
        // we need to return a function that returns the
        // merged result of both functions... no need to
        // check if parentVal is a function here because
        // it has to be a function to pass previous merges.
        return function mergedDataFn () {
            return mergeData(
                typeof childVal === 'function' ? childVal.call(this, this) : childVal,
                typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal
            )
        }
    } else {
        return function mergedInstanceDataFn () {
            // instance merge
            var instanceData = typeof childVal === 'function'
                ? childVal.call(vm, vm)
                : childVal;
            var defaultData = typeof parentVal === 'function'
                ? parentVal.call(vm, vm)
                : parentVal;
            if (instanceData) {
                return mergeData(instanceData, defaultData)
            } else {
                return defaultData
            }
        }
    }
}

strats.data = function (
    parentVal,
    childVal,
    vm
) {
    if (!vm) {
        if (childVal && typeof childVal !== 'function') {
            warn$1(
                'The "data" option should be a function ' +
                'that returns a per-instance value in component ' +
                'definitions.',
                vm
            );

            return parentVal
        }
        return mergeDataOrFn(parentVal, childVal)
    }

    return mergeDataOrFn(parentVal, childVal, vm)
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook (
    parentVal,
    childVal
) {
    var res = childVal
        ? parentVal
            ? parentVal.concat(childVal)
            : Array.isArray(childVal)
                ? childVal
                : [childVal]
        : parentVal;
    return res
        ? dedupeHooks(res)
        : res
}

function dedupeHooks (hooks) {
    var res = [];
    for (var i = 0; i < hooks.length; i++) {
        if (res.indexOf(hooks[i]) === -1) {
            res.push(hooks[i]);
        }
    }
    return res
}

LIFECYCLE_HOOKS.forEach(function (hook) {
    strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets (
    parentVal,
    childVal,
    vm,
    key
) {
    var res = Object.create(parentVal || null);
    if (childVal) {
        assertObjectType(key, childVal, vm);
        return extend$1(res, childVal)
    } else {
        return res
    }
}

ASSET_TYPES.forEach(function (type) {
    strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (
    parentVal,
    childVal,
    vm,
    key
) {
    // work around Firefox's Object.prototype.watch...
    if (parentVal === nativeWatch) { parentVal = undefined; }
    if (childVal === nativeWatch) { childVal = undefined; }
    /* istanbul ignore if */
    if (!childVal) { return Object.create(parentVal || null) }
    {
        assertObjectType(key, childVal, vm);
    }
    if (!parentVal) { return childVal }
    var ret = {};
    extend$1(ret, parentVal);
    for (var key$1 in childVal) {
        var parent = ret[key$1];
        var child = childVal[key$1];
        if (parent && !Array.isArray(parent)) {
            parent = [parent];
        }
        ret[key$1] = parent
            ? parent.concat(child)
            : Array.isArray(child) ? child : [child];
    }
    return ret
};

/**
 * Other object hashes.
 */
strats.props =
    strats.methods =
        strats.inject =
            strats.computed = function (
                parentVal,
                childVal,
                vm,
                key
            ) {
                if (childVal && "development" !== 'production') {
                    assertObjectType(key, childVal, vm);
                }
                if (!parentVal) { return childVal }
                var ret = Object.create(null);
                extend$1(ret, parentVal);
                if (childVal) { extend$1(ret, childVal); }
                return ret
            };
strats.provide = mergeDataOrFn;

/**
 * Default strategy.
 */
var defaultStrat = function (parentVal, childVal) {
    return childVal === undefined
        ? parentVal
        : childVal
};

/**
 * Validate component names
 */
function checkComponents (options) {
    for (var key in options.components) {
        validateComponentName(key);
    }
}

function validateComponentName (name) {
    if (!new RegExp(("^[a-zA-Z][\\-\\.0-9_" + (unicodeRegExp.source) + "]*$")).test(name)) {
        warn$1(
            'Invalid component name: "' + name + '". Component names ' +
            'should conform to valid custom element name in html5 specification.'
        );
    }
    if (isBuiltInTag(name) || config.isReservedTag(name)) {
        warn$1(
            'Do not use built-in or reserved HTML elements as component ' +
            'id: ' + name
        );
    }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps (options, vm) {
    var props = options.props;
    if (!props) { return }
    var res = {};
    var i, val, name;
    if (Array.isArray(props)) {
        i = props.length;
        while (i--) {
            val = props[i];
            if (typeof val === 'string') {
                name = camelize(val);
                res[name] = { type: null };
            } else {
                warn$1('props must be strings when using array syntax.');
            }
        }
    } else if (isPlainObject$2(props)) {
        for (var key in props) {
            val = props[key];
            name = camelize(key);
            res[name] = isPlainObject$2(val)
                ? val
                : { type: val };
        }
    } else {
        warn$1(
            "Invalid value for option \"props\": expected an Array or an Object, " +
            "but got " + (toRawType(props)) + ".",
            vm
        );
    }
    options.props = res;
}

/**
 * Normalize all injections into Object-based format
 */
function normalizeInject (options, vm) {
    var inject = options.inject;
    if (!inject) { return }
    var normalized = options.inject = {};
    if (Array.isArray(inject)) {
        for (var i = 0; i < inject.length; i++) {
            normalized[inject[i]] = { from: inject[i] };
        }
    } else if (isPlainObject$2(inject)) {
        for (var key in inject) {
            var val = inject[key];
            normalized[key] = isPlainObject$2(val)
                ? extend$1({ from: key }, val)
                : { from: val };
        }
    } else {
        warn$1(
            "Invalid value for option \"inject\": expected an Array or an Object, " +
            "but got " + (toRawType(inject)) + ".",
            vm
        );
    }
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives (options) {
    var dirs = options.directives;
    if (dirs) {
        for (var key in dirs) {
            var def$$1 = dirs[key];
            if (typeof def$$1 === 'function') {
                dirs[key] = { bind: def$$1, update: def$$1 };
            }
        }
    }
}

function assertObjectType (name, value, vm) {
    if (!isPlainObject$2(value)) {
        warn$1(
            "Invalid value for option \"" + name + "\": expected an Object, " +
            "but got " + (toRawType(value)) + ".",
            vm
        );
    }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions (
    parent,
    child,
    vm
) {
    {
        checkComponents(child);
    }

    if (typeof child === 'function') {
        child = child.options;
    }

    normalizeProps(child, vm);
    normalizeInject(child, vm);
    normalizeDirectives(child);

    // Apply extends and mixins on the child options,
    // but only if it is a raw options object that isn't
    // the result of another mergeOptions call.
    // Only merged options has the _base property.
    if (!child._base) {
        if (child.extends) {
            parent = mergeOptions(parent, child.extends, vm);
        }
        if (child.mixins) {
            for (var i = 0, l = child.mixins.length; i < l; i++) {
                parent = mergeOptions(parent, child.mixins[i], vm);
            }
        }
    }

    var options = {};
    var key;
    for (key in parent) {
        mergeField(key);
    }
    for (key in child) {
        if (!hasOwn(parent, key)) {
            mergeField(key);
        }
    }
    function mergeField (key) {
        var strat = strats[key] || defaultStrat;
        options[key] = strat(parent[key], child[key], vm, key);
    }
    return options
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset (
    options,
    type,
    id,
    warnMissing
) {
    /* istanbul ignore if */
    if (typeof id !== 'string') {
        return
    }
    var assets = options[type];
    // check local registration variations first
    if (hasOwn(assets, id)) { return assets[id] }
    var camelizedId = camelize(id);
    if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
    var PascalCaseId = capitalize(camelizedId);
    if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
    // fallback to prototype chain
    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
    if (warnMissing && !res) {
        warn$1(
            'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
            options
        );
    }
    return res
}

/*  */



function validateProp (
    key,
    propOptions,
    propsData,
    vm
) {
    var prop = propOptions[key];
    var absent = !hasOwn(propsData, key);
    var value = propsData[key];
    // boolean casting
    var booleanIndex = getTypeIndex(Boolean, prop.type);
    if (booleanIndex > -1) {
        if (absent && !hasOwn(prop, 'default')) {
            value = false;
        } else if (value === '' || value === hyphenate(key)) {
            // only cast empty string / same name to boolean if
            // boolean has higher priority
            var stringIndex = getTypeIndex(String, prop.type);
            if (stringIndex < 0 || booleanIndex < stringIndex) {
                value = true;
            }
        }
    }
    // check default value
    if (value === undefined) {
        value = getPropDefaultValue(vm, prop, key);
        // since the default value is a fresh copy,
        // make sure to observe it.
        var prevShouldObserve = shouldObserve;
        toggleObserving(true);
        observe(value);
        toggleObserving(prevShouldObserve);
    }
    {
        assertProp(prop, key, value, vm, absent);
    }
    return value
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue (vm, prop, key) {
    // no default, return undefined
    if (!hasOwn(prop, 'default')) {
        return undefined
    }
    var def = prop.default;
    // warn against non-factory defaults for Object & Array
    if (isObject$4(def)) {
        warn$1(
            'Invalid default value for prop "' + key + '": ' +
            'Props with type Object/Array must use a factory function ' +
            'to return the default value.',
            vm
        );
    }
    // the raw prop value was also undefined from previous render,
    // return previous default value to avoid unnecessary watcher trigger
    if (vm && vm.$options.propsData &&
        vm.$options.propsData[key] === undefined &&
        vm._props[key] !== undefined
    ) {
        return vm._props[key]
    }
    // call factory function for non-Function types
    // a value is Function if its prototype is function even across different execution context
    return typeof def === 'function' && getType(prop.type) !== 'Function'
        ? def.call(vm)
        : def
}

/**
 * Assert whether a prop is valid.
 */
function assertProp (
    prop,
    name,
    value,
    vm,
    absent
) {
    if (prop.required && absent) {
        warn$1(
            'Missing required prop: "' + name + '"',
            vm
        );
        return
    }
    if (value == null && !prop.required) {
        return
    }
    var type = prop.type;
    var valid = !type || type === true;
    var expectedTypes = [];
    if (type) {
        if (!Array.isArray(type)) {
            type = [type];
        }
        for (var i = 0; i < type.length && !valid; i++) {
            var assertedType = assertType(value, type[i]);
            expectedTypes.push(assertedType.expectedType || '');
            valid = assertedType.valid;
        }
    }

    if (!valid) {
        warn$1(
            getInvalidTypeMessage(name, value, expectedTypes),
            vm
        );
        return
    }
    var validator = prop.validator;
    if (validator) {
        if (!validator(value)) {
            warn$1(
                'Invalid prop: custom validator check failed for prop "' + name + '".',
                vm
            );
        }
    }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType (value, type) {
    var valid;
    var expectedType = getType(type);
    if (simpleCheckRE.test(expectedType)) {
        var t = typeof value;
        valid = t === expectedType.toLowerCase();
        // for primitive wrapper objects
        if (!valid && t === 'object') {
            valid = value instanceof type;
        }
    } else if (expectedType === 'Object') {
        valid = isPlainObject$2(value);
    } else if (expectedType === 'Array') {
        valid = Array.isArray(value);
    } else {
        valid = value instanceof type;
    }
    return {
        valid: valid,
        expectedType: expectedType
    }
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType (fn) {
    var match = fn && fn.toString().match(/^\s*function (\w+)/);
    return match ? match[1] : ''
}

function isSameType (a, b) {
    return getType(a) === getType(b)
}

function getTypeIndex (type, expectedTypes) {
    if (!Array.isArray(expectedTypes)) {
        return isSameType(expectedTypes, type) ? 0 : -1
    }
    for (var i = 0, len = expectedTypes.length; i < len; i++) {
        if (isSameType(expectedTypes[i], type)) {
            return i
        }
    }
    return -1
}

function getInvalidTypeMessage (name, value, expectedTypes) {
    var message = "Invalid prop: type check failed for prop \"" + name + "\"." +
        " Expected " + (expectedTypes.map(capitalize).join(', '));
    var expectedType = expectedTypes[0];
    var receivedType = toRawType(value);
    var expectedValue = styleValue(value, expectedType);
    var receivedValue = styleValue(value, receivedType);
    // check if we need to specify expected value
    if (expectedTypes.length === 1 &&
        isExplicable(expectedType) &&
        !isBoolean$1(expectedType, receivedType)) {
        message += " with value " + expectedValue;
    }
    message += ", got " + receivedType + " ";
    // check if we need to specify received value
    if (isExplicable(receivedType)) {
        message += "with value " + receivedValue + ".";
    }
    return message
}

function styleValue (value, type) {
    if (type === 'String') {
        return ("\"" + value + "\"")
    } else if (type === 'Number') {
        return ("" + (Number(value)))
    } else {
        return ("" + value)
    }
}

function isExplicable (value) {
    var explicitTypes = ['string', 'number', 'boolean'];
    return explicitTypes.some(function (elem) { return value.toLowerCase() === elem; })
}

function isBoolean$1 () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; })
}

/*  */

function handleError (err, vm, info) {
    // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
    // See: https://github.com/vuejs/vuex/issues/1505
    pushTarget();
    try {
        if (vm) {
            var cur = vm;
            while ((cur = cur.$parent)) {
                var hooks = cur.$options.errorCaptured;
                if (hooks) {
                    for (var i = 0; i < hooks.length; i++) {
                        try {
                            var capture = hooks[i].call(cur, err, vm, info) === false;
                            if (capture) { return }
                        } catch (e) {
                            globalHandleError(e, cur, 'errorCaptured hook');
                        }
                    }
                }
            }
        }
        globalHandleError(err, vm, info);
    } finally {
        popTarget();
    }
}

function invokeWithErrorHandling (
    handler,
    context,
    args,
    vm,
    info
) {
    var res;
    try {
        res = args ? handler.apply(context, args) : handler.call(context);
        if (res && !res._isVue && isPromise$1(res) && !res._handled) {
            res.catch(function (e) { return handleError(e, vm, info + " (Promise/async)"); });
            // issue #9511
            // avoid catch triggering multiple times when nested calls
            res._handled = true;
        }
    } catch (e) {
        handleError(e, vm, info);
    }
    return res
}

function globalHandleError (err, vm, info) {
    if (config.errorHandler) {
        try {
            return config.errorHandler.call(null, err, vm, info)
        } catch (e) {
            // if the user intentionally throws the original error in the handler,
            // do not log it twice
            if (e !== err) {
                logError(e, null, 'config.errorHandler');
            }
        }
    }
    logError(err, vm, info);
}

function logError (err, vm, info) {
    {
        warn$1(("Error in " + info + ": \"" + (err.toString()) + "\""), vm);
    }
    /* istanbul ignore else */
    if ((inBrowser || inWeex) && typeof console !== 'undefined') {
        console.error(err);
    } else {
        throw err
    }
}

/*  */

var isUsingMicroTask = false;

var callbacks = [];
var pending = false;

function flushCallbacks () {
    pending = false;
    var copies = callbacks.slice(0);
    callbacks.length = 0;
    for (var i = 0; i < copies.length; i++) {
        copies[i]();
    }
}

// Here we have async deferring wrappers using microtasks.
// In 2.5 we used (macro) tasks (in combination with microtasks).
// However, it has subtle problems when state is changed right before repaint
// (e.g. #6813, out-in transitions).
// Also, using (macro) tasks in event handler would cause some weird behaviors
// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
// So we now use microtasks everywhere, again.
// A major drawback of this tradeoff is that there are some scenarios
// where microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690, which have workarounds)
// or even between bubbling of the same event (#6566).
var timerFunc;

// The nextTick behavior leverages the microtask queue, which can be accessed
// via either native Promise.then or MutationObserver.
// MutationObserver has wider support, however it is seriously bugged in
// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
// completely stops working after triggering a few times... so, if native
// Promise is available, we will use it:
/* istanbul ignore next, $flow-disable-line */
if (typeof Promise !== 'undefined' && isNative(Promise)) {
    var p = Promise.resolve();
    timerFunc = function () {
        p.then(flushCallbacks);
        // In problematic UIWebViews, Promise.then doesn't completely break, but
        // it can get stuck in a weird state where callbacks are pushed into the
        // microtask queue but the queue isn't being flushed, until the browser
        // needs to do some other work, e.g. handle a timer. Therefore we can
        // "force" the microtask queue to be flushed by adding an empty timer.
        if (isIOS) { setTimeout(noop$1); }
    };
    isUsingMicroTask = true;
} else if (!isIE$1 && typeof MutationObserver !== 'undefined' && (
    isNative(MutationObserver) ||
    // PhantomJS and iOS 7.x
    MutationObserver.toString() === '[object MutationObserverConstructor]'
)) {
    // Use MutationObserver where native Promise is not available,
    // e.g. PhantomJS, iOS7, Android 4.4
    // (#6466 MutationObserver is unreliable in IE11)
    var counter = 1;
    var observer = new MutationObserver(flushCallbacks);
    var textNode = document.createTextNode(String(counter));
    observer.observe(textNode, {
        characterData: true
    });
    timerFunc = function () {
        counter = (counter + 1) % 2;
        textNode.data = String(counter);
    };
    isUsingMicroTask = true;
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
    // Fallback to setImmediate.
    // Technically it leverages the (macro) task queue,
    // but it is still a better choice than setTimeout.
    timerFunc = function () {
        setImmediate(flushCallbacks);
    };
} else {
    // Fallback to setTimeout.
    timerFunc = function () {
        setTimeout(flushCallbacks, 0);
    };
}

function nextTick (cb, ctx) {
    var _resolve;
    callbacks.push(function () {
        if (cb) {
            try {
                cb.call(ctx);
            } catch (e) {
                handleError(e, ctx, 'nextTick');
            }
        } else if (_resolve) {
            _resolve(ctx);
        }
    });
    if (!pending) {
        pending = true;
        timerFunc();
    }
    // $flow-disable-line
    if (!cb && typeof Promise !== 'undefined') {
        return new Promise(function (resolve) {
            _resolve = resolve;
        })
    }
}

/*  */

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

{
    var allowedGlobals = makeMap(
        'Infinity,undefined,NaN,isFinite,isNaN,' +
        'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
        'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
        'require' // for Webpack/Browserify
    );

    var warnNonPresent = function (target, key) {
        warn$1(
            "Property or method \"" + key + "\" is not defined on the instance but " +
            'referenced during render. Make sure that this property is reactive, ' +
            'either in the data option, or for class-based components, by ' +
            'initializing the property. ' +
            'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',
            target
        );
    };

    var warnReservedPrefix = function (target, key) {
        warn$1(
            "Property \"" + key + "\" must be accessed with \"$data." + key + "\" because " +
            'properties starting with "$" or "_" are not proxied in the Vue instance to ' +
            'prevent conflicts with Vue internals. ' +
            'See: https://vuejs.org/v2/api/#data',
            target
        );
    };

    var hasProxy =
        typeof Proxy !== 'undefined' && isNative(Proxy);

    if (hasProxy) {
        var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
        config.keyCodes = new Proxy(config.keyCodes, {
            set: function set (target, key, value) {
                if (isBuiltInModifier(key)) {
                    warn$1(("Avoid overwriting built-in modifier in config.keyCodes: ." + key));
                    return false
                } else {
                    target[key] = value;
                    return true
                }
            }
        });
    }

    var hasHandler = {
        has: function has (target, key) {
            var has = key in target;
            var isAllowed = allowedGlobals(key) ||
                (typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data));
            if (!has && !isAllowed) {
                if (key in target.$data) { warnReservedPrefix(target, key); }
                else { warnNonPresent(target, key); }
            }
            return has || !isAllowed
        }
    };

    var getHandler = {
        get: function get (target, key) {
            if (typeof key === 'string' && !(key in target)) {
                if (key in target.$data) { warnReservedPrefix(target, key); }
                else { warnNonPresent(target, key); }
            }
            return target[key]
        }
    };

    initProxy = function initProxy (vm) {
        if (hasProxy) {
            // determine which proxy handler to use
            var options = vm.$options;
            var handlers = options.render && options.render._withStripped
                ? getHandler
                : hasHandler;
            vm._renderProxy = new Proxy(vm, handlers);
        } else {
            vm._renderProxy = vm;
        }
    };
}

/*  */

var seenObjects = new _Set();

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
function traverse (val) {
    _traverse(val, seenObjects);
    seenObjects.clear();
}

function _traverse (val, seen) {
    var i, keys;
    var isA = Array.isArray(val);
    if ((!isA && !isObject$4(val)) || Object.isFrozen(val) || val instanceof VNode) {
        return
    }
    if (val.__ob__) {
        var depId = val.__ob__.dep.id;
        if (seen.has(depId)) {
            return
        }
        seen.add(depId);
    }
    if (isA) {
        i = val.length;
        while (i--) { _traverse(val[i], seen); }
    } else {
        keys = Object.keys(val);
        i = keys.length;
        while (i--) { _traverse(val[keys[i]], seen); }
    }
}

var mark;
var measure;

{
    var perf = inBrowser && window.performance;
    /* istanbul ignore if */
    if (
        perf &&
        perf.mark &&
        perf.measure &&
        perf.clearMarks &&
        perf.clearMeasures
    ) {
        mark = function (tag) { return perf.mark(tag); };
        measure = function (name, startTag, endTag) {
            perf.measure(name, startTag, endTag);
            perf.clearMarks(startTag);
            perf.clearMarks(endTag);
            // perf.clearMeasures(name)
        };
    }
}

/*  */

var normalizeEvent = cached(function (name) {
    var passive = name.charAt(0) === '&';
    name = passive ? name.slice(1) : name;
    var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
    name = once$$1 ? name.slice(1) : name;
    var capture = name.charAt(0) === '!';
    name = capture ? name.slice(1) : name;
    return {
        name: name,
        once: once$$1,
        capture: capture,
        passive: passive
    }
});

function createFnInvoker (fns, vm) {
    function invoker () {
        var arguments$1 = arguments;

        var fns = invoker.fns;
        if (Array.isArray(fns)) {
            var cloned = fns.slice();
            for (var i = 0; i < cloned.length; i++) {
                invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
            }
        } else {
            // return handler return value for single handlers
            return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler")
        }
    }
    invoker.fns = fns;
    return invoker
}

function updateListeners (
    on,
    oldOn,
    add,
    remove$$1,
    createOnceHandler,
    vm
) {
    var name, cur, old, event;
    for (name in on) {
        cur = on[name];
        old = oldOn[name];
        event = normalizeEvent(name);
        if (isUndef(cur)) {
            warn$1(
                "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
                vm
            );
        } else if (isUndef(old)) {
            if (isUndef(cur.fns)) {
                cur = on[name] = createFnInvoker(cur, vm);
            }
            if (isTrue(event.once)) {
                cur = on[name] = createOnceHandler(event.name, cur, event.capture);
            }
            add(event.name, cur, event.capture, event.passive, event.params);
        } else if (cur !== old) {
            old.fns = cur;
            on[name] = old;
        }
    }
    for (name in oldOn) {
        if (isUndef(on[name])) {
            event = normalizeEvent(name);
            remove$$1(event.name, oldOn[name], event.capture);
        }
    }
}

/*  */

function mergeVNodeHook (def, hookKey, hook) {
    if (def instanceof VNode) {
        def = def.data.hook || (def.data.hook = {});
    }
    var invoker;
    var oldHook = def[hookKey];

    function wrappedHook () {
        hook.apply(this, arguments);
        // important: remove merged hook to ensure it's called only once
        // and prevent memory leak
        remove(invoker.fns, wrappedHook);
    }

    if (isUndef(oldHook)) {
        // no existing hook
        invoker = createFnInvoker([wrappedHook]);
    } else {
        /* istanbul ignore if */
        if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
            // already a merged invoker
            invoker = oldHook;
            invoker.fns.push(wrappedHook);
        } else {
            // existing plain hook
            invoker = createFnInvoker([oldHook, wrappedHook]);
        }
    }

    invoker.merged = true;
    def[hookKey] = invoker;
}

/*  */

function extractPropsFromVNodeData (
    data,
    Ctor,
    tag
) {
    // we are only extracting raw values here.
    // validation and default values are handled in the child
    // component itself.
    var propOptions = Ctor.options.props;
    if (isUndef(propOptions)) {
        return
    }
    var res = {};
    var attrs = data.attrs;
    var props = data.props;
    if (isDef(attrs) || isDef(props)) {
        for (var key in propOptions) {
            var altKey = hyphenate(key);
            {
                var keyInLowerCase = key.toLowerCase();
                if (
                    key !== keyInLowerCase &&
                    attrs && hasOwn(attrs, keyInLowerCase)
                ) {
                    tip(
                        "Prop \"" + keyInLowerCase + "\" is passed to component " +
                        (formatComponentName(tag || Ctor)) + ", but the declared prop name is" +
                        " \"" + key + "\". " +
                        "Note that HTML attributes are case-insensitive and camelCased " +
                        "props need to use their kebab-case equivalents when using in-DOM " +
                        "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\"."
                    );
                }
            }
            checkProp(res, props, key, altKey, true) ||
            checkProp(res, attrs, key, altKey, false);
        }
    }
    return res
}

function checkProp (
    res,
    hash,
    key,
    altKey,
    preserve
) {
    if (isDef(hash)) {
        if (hasOwn(hash, key)) {
            res[key] = hash[key];
            if (!preserve) {
                delete hash[key];
            }
            return true
        } else if (hasOwn(hash, altKey)) {
            res[key] = hash[altKey];
            if (!preserve) {
                delete hash[altKey];
            }
            return true
        }
    }
    return false
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren (children) {
    for (var i = 0; i < children.length; i++) {
        if (Array.isArray(children[i])) {
            return Array.prototype.concat.apply([], children)
        }
    }
    return children
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren (children) {
    return isPrimitive(children)
        ? [createTextVNode(children)]
        : Array.isArray(children)
            ? normalizeArrayChildren(children)
            : undefined
}

function isTextNode (node) {
    return isDef(node) && isDef(node.text) && isFalse(node.isComment)
}

function normalizeArrayChildren (children, nestedIndex) {
    var res = [];
    var i, c, lastIndex, last;
    for (i = 0; i < children.length; i++) {
        c = children[i];
        if (isUndef(c) || typeof c === 'boolean') { continue }
        lastIndex = res.length - 1;
        last = res[lastIndex];
        //  nested
        if (Array.isArray(c)) {
            if (c.length > 0) {
                c = normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i));
                // merge adjacent text nodes
                if (isTextNode(c[0]) && isTextNode(last)) {
                    res[lastIndex] = createTextVNode(last.text + (c[0]).text);
                    c.shift();
                }
                res.push.apply(res, c);
            }
        } else if (isPrimitive(c)) {
            if (isTextNode(last)) {
                // merge adjacent text nodes
                // this is necessary for SSR hydration because text nodes are
                // essentially merged when rendered to HTML strings
                res[lastIndex] = createTextVNode(last.text + c);
            } else if (c !== '') {
                // convert primitive to vnode
                res.push(createTextVNode(c));
            }
        } else {
            if (isTextNode(c) && isTextNode(last)) {
                // merge adjacent text nodes
                res[lastIndex] = createTextVNode(last.text + c.text);
            } else {
                // default key for nested array children (likely generated by v-for)
                if (isTrue(children._isVList) &&
                    isDef(c.tag) &&
                    isUndef(c.key) &&
                    isDef(nestedIndex)) {
                    c.key = "__vlist" + nestedIndex + "_" + i + "__";
                }
                res.push(c);
            }
        }
    }
    return res
}

/*  */

function initProvide (vm) {
    var provide = vm.$options.provide;
    if (provide) {
        vm._provided = typeof provide === 'function'
            ? provide.call(vm)
            : provide;
    }
}

function initInjections (vm) {
    var result = resolveInject(vm.$options.inject, vm);
    if (result) {
        toggleObserving(false);
        Object.keys(result).forEach(function (key) {
            /* istanbul ignore else */
            {
                defineReactive$$1(vm, key, result[key], function () {
                    warn$1(
                        "Avoid mutating an injected value directly since the changes will be " +
                        "overwritten whenever the provided component re-renders. " +
                        "injection being mutated: \"" + key + "\"",
                        vm
                    );
                });
            }
        });
        toggleObserving(true);
    }
}

function resolveInject (inject, vm) {
    if (inject) {
        // inject is :any because flow is not smart enough to figure out cached
        var result = Object.create(null);
        var keys = hasSymbol
            ? Reflect.ownKeys(inject)
            : Object.keys(inject);

        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            // #6574 in case the inject object is observed...
            if (key === '__ob__') { continue }
            var provideKey = inject[key].from;
            var source = vm;
            while (source) {
                if (source._provided && hasOwn(source._provided, provideKey)) {
                    result[key] = source._provided[provideKey];
                    break
                }
                source = source.$parent;
            }
            if (!source) {
                if ('default' in inject[key]) {
                    var provideDefault = inject[key].default;
                    result[key] = typeof provideDefault === 'function'
                        ? provideDefault.call(vm)
                        : provideDefault;
                } else {
                    warn$1(("Injection \"" + key + "\" not found"), vm);
                }
            }
        }
        return result
    }
}

/*  */



/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots (
    children,
    context
) {
    if (!children || !children.length) {
        return {}
    }
    var slots = {};
    for (var i = 0, l = children.length; i < l; i++) {
        var child = children[i];
        var data = child.data;
        // remove slot attribute if the node is resolved as a Vue slot node
        if (data && data.attrs && data.attrs.slot) {
            delete data.attrs.slot;
        }
        // named slots should only be respected if the vnode was rendered in the
        // same context.
        if ((child.context === context || child.fnContext === context) &&
            data && data.slot != null
        ) {
            var name = data.slot;
            var slot = (slots[name] || (slots[name] = []));
            if (child.tag === 'template') {
                slot.push.apply(slot, child.children || []);
            } else {
                slot.push(child);
            }
        } else {
            (slots.default || (slots.default = [])).push(child);
        }
    }
    // ignore slots that contains only whitespace
    for (var name$1 in slots) {
        if (slots[name$1].every(isWhitespace)) {
            delete slots[name$1];
        }
    }
    return slots
}

function isWhitespace (node) {
    return (node.isComment && !node.asyncFactory) || node.text === ' '
}

/*  */

function normalizeScopedSlots (
    slots,
    normalSlots,
    prevSlots
) {
    var res;
    var hasNormalSlots = Object.keys(normalSlots).length > 0;
    var isStable = slots ? !!slots.$stable : !hasNormalSlots;
    var key = slots && slots.$key;
    if (!slots) {
        res = {};
    } else if (slots._normalized) {
        // fast path 1: child component re-render only, parent did not change
        return slots._normalized
    } else if (
        isStable &&
        prevSlots &&
        prevSlots !== emptyObject &&
        key === prevSlots.$key &&
        !hasNormalSlots &&
        !prevSlots.$hasNormal
    ) {
        // fast path 2: stable scoped slots w/ no normal slots to proxy,
        // only need to normalize once
        return prevSlots
    } else {
        res = {};
        for (var key$1 in slots) {
            if (slots[key$1] && key$1[0] !== '$') {
                res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
            }
        }
    }
    // expose normal slots on scopedSlots
    for (var key$2 in normalSlots) {
        if (!(key$2 in res)) {
            res[key$2] = proxyNormalSlot(normalSlots, key$2);
        }
    }
    // avoriaz seems to mock a non-extensible $scopedSlots object
    // and when that is passed down this would cause an error
    if (slots && Object.isExtensible(slots)) {
        (slots)._normalized = res;
    }
    def(res, '$stable', isStable);
    def(res, '$key', key);
    def(res, '$hasNormal', hasNormalSlots);
    return res
}

function normalizeScopedSlot(normalSlots, key, fn) {
    var normalized = function () {
        var res = arguments.length ? fn.apply(null, arguments) : fn({});
        res = res && typeof res === 'object' && !Array.isArray(res)
            ? [res] // single vnode
            : normalizeChildren(res);
        return res && (
            res.length === 0 ||
            (res.length === 1 && res[0].isComment) // #9658
        ) ? undefined
            : res
    };
    // this is a slot using the new v-slot syntax without scope. although it is
    // compiled as a scoped slot, render fn users would expect it to be present
    // on this.$slots because the usage is semantically a normal slot.
    if (fn.proxy) {
        Object.defineProperty(normalSlots, key, {
            get: normalized,
            enumerable: true,
            configurable: true
        });
    }
    return normalized
}

function proxyNormalSlot(slots, key) {
    return function () { return slots[key]; }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList (
    val,
    render
) {
    var ret, i, l, keys, key;
    if (Array.isArray(val) || typeof val === 'string') {
        ret = new Array(val.length);
        for (i = 0, l = val.length; i < l; i++) {
            ret[i] = render(val[i], i);
        }
    } else if (typeof val === 'number') {
        ret = new Array(val);
        for (i = 0; i < val; i++) {
            ret[i] = render(i + 1, i);
        }
    } else if (isObject$4(val)) {
        if (hasSymbol && val[Symbol.iterator]) {
            ret = [];
            var iterator = val[Symbol.iterator]();
            var result = iterator.next();
            while (!result.done) {
                ret.push(render(result.value, ret.length));
                result = iterator.next();
            }
        } else {
            keys = Object.keys(val);
            ret = new Array(keys.length);
            for (i = 0, l = keys.length; i < l; i++) {
                key = keys[i];
                ret[i] = render(val[key], key, i);
            }
        }
    }
    if (!isDef(ret)) {
        ret = [];
    }
    (ret)._isVList = true;
    return ret
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot (
    name,
    fallback,
    props,
    bindObject
) {
    var scopedSlotFn = this.$scopedSlots[name];
    var nodes;
    if (scopedSlotFn) { // scoped slot
        props = props || {};
        if (bindObject) {
            if (!isObject$4(bindObject)) {
                warn$1(
                    'slot v-bind without argument expects an Object',
                    this
                );
            }
            props = extend$1(extend$1({}, bindObject), props);
        }
        nodes = scopedSlotFn(props) || fallback;
    } else {
        nodes = this.$slots[name] || fallback;
    }

    var target = props && props.slot;
    if (target) {
        return this.$createElement('template', { slot: target }, nodes)
    } else {
        return nodes
    }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter (id) {
    return resolveAsset(this.$options, 'filters', id, true) || identity$1
}

/*  */

function isKeyNotMatch (expect, actual) {
    if (Array.isArray(expect)) {
        return expect.indexOf(actual) === -1
    } else {
        return expect !== actual
    }
}

/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */
function checkKeyCodes (
    eventKeyCode,
    key,
    builtInKeyCode,
    eventKeyName,
    builtInKeyName
) {
    var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
        return isKeyNotMatch(builtInKeyName, eventKeyName)
    } else if (mappedKeyCode) {
        return isKeyNotMatch(mappedKeyCode, eventKeyCode)
    } else if (eventKeyName) {
        return hyphenate(eventKeyName) !== key
    }
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps (
    data,
    tag,
    value,
    asProp,
    isSync
) {
    if (value) {
        if (!isObject$4(value)) {
            warn$1(
                'v-bind without argument expects an Object or Array value',
                this
            );
        } else {
            if (Array.isArray(value)) {
                value = toObject(value);
            }
            var hash;
            var loop = function ( key ) {
                if (
                    key === 'class' ||
                    key === 'style' ||
                    isReservedAttribute(key)
                ) {
                    hash = data;
                } else {
                    var type = data.attrs && data.attrs.type;
                    hash = asProp || config.mustUseProp(tag, type, key)
                        ? data.domProps || (data.domProps = {})
                        : data.attrs || (data.attrs = {});
                }
                var camelizedKey = camelize(key);
                var hyphenatedKey = hyphenate(key);
                if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
                    hash[key] = value[key];

                    if (isSync) {
                        var on = data.on || (data.on = {});
                        on[("update:" + key)] = function ($event) {
                            value[key] = $event;
                        };
                    }
                }
            };

            for (var key in value) loop( key );
        }
    }
    return data
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic (
    index,
    isInFor
) {
    var cached = this._staticTrees || (this._staticTrees = []);
    var tree = cached[index];
    // if has already-rendered static tree and not inside v-for,
    // we can reuse the same tree.
    if (tree && !isInFor) {
        return tree
    }
    // otherwise, render a fresh tree.
    tree = cached[index] = this.$options.staticRenderFns[index].call(
        this._renderProxy,
        null,
        this // for render fns generated for functional component templates
    );
    markStatic(tree, ("__static__" + index), false);
    return tree
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce (
    tree,
    index,
    key
) {
    markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
    return tree
}

function markStatic (
    tree,
    key,
    isOnce
) {
    if (Array.isArray(tree)) {
        for (var i = 0; i < tree.length; i++) {
            if (tree[i] && typeof tree[i] !== 'string') {
                markStaticNode(tree[i], (key + "_" + i), isOnce);
            }
        }
    } else {
        markStaticNode(tree, key, isOnce);
    }
}

function markStaticNode (node, key, isOnce) {
    node.isStatic = true;
    node.key = key;
    node.isOnce = isOnce;
}

/*  */

function bindObjectListeners (data, value) {
    if (value) {
        if (!isPlainObject$2(value)) {
            warn$1(
                'v-on without argument expects an Object value',
                this
            );
        } else {
            var on = data.on = data.on ? extend$1({}, data.on) : {};
            for (var key in value) {
                var existing = on[key];
                var ours = value[key];
                on[key] = existing ? [].concat(existing, ours) : ours;
            }
        }
    }
    return data
}

/*  */

function resolveScopedSlots (
    fns, // see flow/vnode
    res,
    // the following are added in 2.6
    hasDynamicKeys,
    contentHashKey
) {
    res = res || { $stable: !hasDynamicKeys };
    for (var i = 0; i < fns.length; i++) {
        var slot = fns[i];
        if (Array.isArray(slot)) {
            resolveScopedSlots(slot, res, hasDynamicKeys);
        } else if (slot) {
            // marker for reverse proxying v-slot without scope on this.$slots
            if (slot.proxy) {
                slot.fn.proxy = true;
            }
            res[slot.key] = slot.fn;
        }
    }
    if (contentHashKey) {
        (res).$key = contentHashKey;
    }
    return res
}

/*  */

function bindDynamicKeys (baseObj, values) {
    for (var i = 0; i < values.length; i += 2) {
        var key = values[i];
        if (typeof key === 'string' && key) {
            baseObj[values[i]] = values[i + 1];
        } else if (key !== '' && key !== null) {
            // null is a special value for explicitly removing a binding
            warn$1(
                ("Invalid value for dynamic directive argument (expected string or null): " + key),
                this
            );
        }
    }
    return baseObj
}

// helper to dynamically append modifier runtime markers to event names.
// ensure only append when value is already string, otherwise it will be cast
// to string and cause the type check to miss.
function prependModifier (value, symbol) {
    return typeof value === 'string' ? symbol + value : value
}

/*  */

function installRenderHelpers (target) {
    target._o = markOnce;
    target._n = toNumber;
    target._s = toString$2;
    target._l = renderList;
    target._t = renderSlot;
    target._q = looseEqual$1;
    target._i = looseIndexOf;
    target._m = renderStatic;
    target._f = resolveFilter;
    target._k = checkKeyCodes;
    target._b = bindObjectProps;
    target._v = createTextVNode;
    target._e = createEmptyVNode;
    target._u = resolveScopedSlots;
    target._g = bindObjectListeners;
    target._d = bindDynamicKeys;
    target._p = prependModifier;
}

/*  */

function FunctionalRenderContext (
    data,
    props,
    children,
    parent,
    Ctor
) {
    var this$1 = this;

    var options = Ctor.options;
    // ensure the createElement function in functional components
    // gets a unique context - this is necessary for correct named slot check
    var contextVm;
    if (hasOwn(parent, '_uid')) {
        contextVm = Object.create(parent);
        // $flow-disable-line
        contextVm._original = parent;
    } else {
        // the context vm passed in is a functional context as well.
        // in this case we want to make sure we are able to get a hold to the
        // real context instance.
        contextVm = parent;
        // $flow-disable-line
        parent = parent._original;
    }
    var isCompiled = isTrue(options._compiled);
    var needNormalization = !isCompiled;

    this.data = data;
    this.props = props;
    this.children = children;
    this.parent = parent;
    this.listeners = data.on || emptyObject;
    this.injections = resolveInject(options.inject, parent);
    this.slots = function () {
        if (!this$1.$slots) {
            normalizeScopedSlots(
                data.scopedSlots,
                this$1.$slots = resolveSlots(children, parent)
            );
        }
        return this$1.$slots
    };

    Object.defineProperty(this, 'scopedSlots', ({
        enumerable: true,
        get: function get () {
            return normalizeScopedSlots(data.scopedSlots, this.slots())
        }
    }));

    // support for compiled functional template
    if (isCompiled) {
        // exposing $options for renderStatic()
        this.$options = options;
        // pre-resolve slots for renderSlot()
        this.$slots = this.slots();
        this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
    }

    if (options._scopeId) {
        this._c = function (a, b, c, d) {
            var vnode = createElement(contextVm, a, b, c, d, needNormalization);
            if (vnode && !Array.isArray(vnode)) {
                vnode.fnScopeId = options._scopeId;
                vnode.fnContext = parent;
            }
            return vnode
        };
    } else {
        this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };
    }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent (
    Ctor,
    propsData,
    data,
    contextVm,
    children
) {
    var options = Ctor.options;
    var props = {};
    var propOptions = options.props;
    if (isDef(propOptions)) {
        for (var key in propOptions) {
            props[key] = validateProp(key, propOptions, propsData || emptyObject);
        }
    } else {
        if (isDef(data.attrs)) { mergeProps(props, data.attrs); }
        if (isDef(data.props)) { mergeProps(props, data.props); }
    }

    var renderContext = new FunctionalRenderContext(
        data,
        props,
        children,
        contextVm,
        Ctor
    );

    var vnode = options.render.call(null, renderContext._c, renderContext);

    if (vnode instanceof VNode) {
        return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext)
    } else if (Array.isArray(vnode)) {
        var vnodes = normalizeChildren(vnode) || [];
        var res = new Array(vnodes.length);
        for (var i = 0; i < vnodes.length; i++) {
            res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
        }
        return res
    }
}

function cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) {
    // #7817 clone node before setting fnContext, otherwise if the node is reused
    // (e.g. it was from a cached normal slot) the fnContext causes named slots
    // that should not be matched to match.
    var clone = cloneVNode(vnode);
    clone.fnContext = contextVm;
    clone.fnOptions = options;
    {
        (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
    }
    if (data.slot) {
        (clone.data || (clone.data = {})).slot = data.slot;
    }
    return clone
}

function mergeProps (to, from) {
    for (var key in from) {
        to[camelize(key)] = from[key];
    }
}

/*  */

/*  */

/*  */

/*  */

// inline hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
    init: function init (vnode, hydrating) {
        if (
            vnode.componentInstance &&
            !vnode.componentInstance._isDestroyed &&
            vnode.data.keepAlive
        ) {
            // kept-alive components, treat as a patch
            var mountedNode = vnode; // work around flow
            componentVNodeHooks.prepatch(mountedNode, mountedNode);
        } else {
            var child = vnode.componentInstance = createComponentInstanceForVnode(
                vnode,
                activeInstance
            );
            child.$mount(hydrating ? vnode.elm : undefined, hydrating);
        }
    },

    prepatch: function prepatch (oldVnode, vnode) {
        var options = vnode.componentOptions;
        var child = vnode.componentInstance = oldVnode.componentInstance;
        updateChildComponent(
            child,
            options.propsData, // updated props
            options.listeners, // updated listeners
            vnode, // new parent vnode
            options.children // new children
        );
    },

    insert: function insert (vnode) {
        var context = vnode.context;
        var componentInstance = vnode.componentInstance;
        if (!componentInstance._isMounted) {
            componentInstance._isMounted = true;
            callHook(componentInstance, 'mounted');
        }
        if (vnode.data.keepAlive) {
            if (context._isMounted) {
                // vue-router#1212
                // During updates, a kept-alive component's child components may
                // change, so directly walking the tree here may call activated hooks
                // on incorrect children. Instead we push them into a queue which will
                // be processed after the whole patch process ended.
                queueActivatedComponent(componentInstance);
            } else {
                activateChildComponent(componentInstance, true /* direct */);
            }
        }
    },

    destroy: function destroy (vnode) {
        var componentInstance = vnode.componentInstance;
        if (!componentInstance._isDestroyed) {
            if (!vnode.data.keepAlive) {
                componentInstance.$destroy();
            } else {
                deactivateChildComponent(componentInstance, true /* direct */);
            }
        }
    }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent (
    Ctor,
    data,
    context,
    children,
    tag
) {
    if (isUndef(Ctor)) {
        return
    }

    var baseCtor = context.$options._base;

    // plain options object: turn it into a constructor
    if (isObject$4(Ctor)) {
        Ctor = baseCtor.extend(Ctor);
    }

    // if at this stage it's not a constructor or an async component factory,
    // reject.
    if (typeof Ctor !== 'function') {
        {
            warn$1(("Invalid Component definition: " + (String(Ctor))), context);
        }
        return
    }

    // async component
    var asyncFactory;
    if (isUndef(Ctor.cid)) {
        asyncFactory = Ctor;
        Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
        if (Ctor === undefined) {
            // return a placeholder node for async component, which is rendered
            // as a comment node but preserves all the raw information for the node.
            // the information will be used for async server-rendering and hydration.
            return createAsyncPlaceholder(
                asyncFactory,
                data,
                context,
                children,
                tag
            )
        }
    }

    data = data || {};

    // resolve constructor options in case global mixins are applied after
    // component constructor creation
    resolveConstructorOptions(Ctor);

    // transform component v-model data into props & events
    if (isDef(data.model)) {
        transformModel(Ctor.options, data);
    }

    // extract props
    var propsData = extractPropsFromVNodeData(data, Ctor, tag);

    // functional component
    if (isTrue(Ctor.options.functional)) {
        return createFunctionalComponent(Ctor, propsData, data, context, children)
    }

    // extract listeners, since these needs to be treated as
    // child component listeners instead of DOM listeners
    var listeners = data.on;
    // replace with listeners with .native modifier
    // so it gets processed during parent component patch.
    data.on = data.nativeOn;

    if (isTrue(Ctor.options.abstract)) {
        // abstract components do not keep anything
        // other than props & listeners & slot

        // work around flow
        var slot = data.slot;
        data = {};
        if (slot) {
            data.slot = slot;
        }
    }

    // install component management hooks onto the placeholder node
    installComponentHooks(data);

    // return a placeholder vnode
    var name = Ctor.options.name || tag;
    var vnode = new VNode(
        ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
        data, undefined, undefined, undefined, context,
        { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
        asyncFactory
    );

    return vnode
}

function createComponentInstanceForVnode (
    vnode, // we know it's MountedComponentVNode but flow doesn't
    parent // activeInstance in lifecycle state
) {
    var options = {
        _isComponent: true,
        _parentVnode: vnode,
        parent: parent
    };
    // check inline-template render functions
    var inlineTemplate = vnode.data.inlineTemplate;
    if (isDef(inlineTemplate)) {
        options.render = inlineTemplate.render;
        options.staticRenderFns = inlineTemplate.staticRenderFns;
    }
    return new vnode.componentOptions.Ctor(options)
}

function installComponentHooks (data) {
    var hooks = data.hook || (data.hook = {});
    for (var i = 0; i < hooksToMerge.length; i++) {
        var key = hooksToMerge[i];
        var existing = hooks[key];
        var toMerge = componentVNodeHooks[key];
        if (existing !== toMerge && !(existing && existing._merged)) {
            hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
        }
    }
}

function mergeHook$1 (f1, f2) {
    var merged = function (a, b) {
        // flow complains about extra args which is why we use any
        f1(a, b);
        f2(a, b);
    };
    merged._merged = true;
    return merged
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel (options, data) {
    var prop = (options.model && options.model.prop) || 'value';
    var event = (options.model && options.model.event) || 'input'
    ;(data.attrs || (data.attrs = {}))[prop] = data.model.value;
    var on = data.on || (data.on = {});
    var existing = on[event];
    var callback = data.model.callback;
    if (isDef(existing)) {
        if (
            Array.isArray(existing)
                ? existing.indexOf(callback) === -1
                : existing !== callback
        ) {
            on[event] = [callback].concat(existing);
        }
    } else {
        on[event] = callback;
    }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement (
    context,
    tag,
    data,
    children,
    normalizationType,
    alwaysNormalize
) {
    if (Array.isArray(data) || isPrimitive(data)) {
        normalizationType = children;
        children = data;
        data = undefined;
    }
    if (isTrue(alwaysNormalize)) {
        normalizationType = ALWAYS_NORMALIZE;
    }
    return _createElement(context, tag, data, children, normalizationType)
}

function _createElement (
    context,
    tag,
    data,
    children,
    normalizationType
) {
    if (isDef(data) && isDef((data).__ob__)) {
        warn$1(
            "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
            'Always create fresh vnode data objects in each render!',
            context
        );
        return createEmptyVNode()
    }
    // object syntax in v-bind
    if (isDef(data) && isDef(data.is)) {
        tag = data.is;
    }
    if (!tag) {
        // in case of component :is set to falsy value
        return createEmptyVNode()
    }
    // warn against non-primitive key
    if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)
    ) {
        {
            warn$1(
                'Avoid using non-primitive value as key, ' +
                'use string/number value instead.',
                context
            );
        }
    }
    // support single function children as default scoped slot
    if (Array.isArray(children) &&
        typeof children[0] === 'function'
    ) {
        data = data || {};
        data.scopedSlots = { default: children[0] };
        children.length = 0;
    }
    if (normalizationType === ALWAYS_NORMALIZE) {
        children = normalizeChildren(children);
    } else if (normalizationType === SIMPLE_NORMALIZE) {
        children = simpleNormalizeChildren(children);
    }
    var vnode, ns;
    if (typeof tag === 'string') {
        var Ctor;
        ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);
        if (config.isReservedTag(tag)) {
            // platform built-in elements
            if (isDef(data) && isDef(data.nativeOn)) {
                warn$1(
                    ("The .native modifier for v-on is only valid on components but it was used on <" + tag + ">."),
                    context
                );
            }
            vnode = new VNode(
                config.parsePlatformTagName(tag), data, children,
                undefined, undefined, context
            );
        } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
            // component
            vnode = createComponent(Ctor, data, context, children, tag);
        } else {
            // unknown or unlisted namespaced elements
            // check at runtime because it may get assigned a namespace when its
            // parent normalizes children
            vnode = new VNode(
                tag, data, children,
                undefined, undefined, context
            );
        }
    } else {
        // direct component options / constructor
        vnode = createComponent(tag, data, context, children);
    }
    if (Array.isArray(vnode)) {
        return vnode
    } else if (isDef(vnode)) {
        if (isDef(ns)) { applyNS(vnode, ns); }
        if (isDef(data)) { registerDeepBindings(data); }
        return vnode
    } else {
        return createEmptyVNode()
    }
}

function applyNS (vnode, ns, force) {
    vnode.ns = ns;
    if (vnode.tag === 'foreignObject') {
        // use default namespace inside foreignObject
        ns = undefined;
        force = true;
    }
    if (isDef(vnode.children)) {
        for (var i = 0, l = vnode.children.length; i < l; i++) {
            var child = vnode.children[i];
            if (isDef(child.tag) && (
                isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {
                applyNS(child, ns, force);
            }
        }
    }
}

// ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes
function registerDeepBindings (data) {
    if (isObject$4(data.style)) {
        traverse(data.style);
    }
    if (isObject$4(data.class)) {
        traverse(data.class);
    }
}

/*  */

function initRender (vm) {
    vm._vnode = null; // the root of the child tree
    vm._staticTrees = null; // v-once cached trees
    var options = vm.$options;
    var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
    var renderContext = parentVnode && parentVnode.context;
    vm.$slots = resolveSlots(options._renderChildren, renderContext);
    vm.$scopedSlots = emptyObject;
    // bind the createElement fn to this instance
    // so that we get proper render context inside it.
    // args order: tag, data, children, normalizationType, alwaysNormalize
    // internal version is used by render functions compiled from templates
    vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
    // normalization is always applied for the public version, used in
    // user-written render functions.
    vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };

    // $attrs & $listeners are exposed for easier HOC creation.
    // they need to be reactive so that HOCs using them are always updated
    var parentData = parentVnode && parentVnode.data;

    /* istanbul ignore else */
    {
        defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
            !isUpdatingChildComponent && warn$1("$attrs is readonly.", vm);
        }, true);
        defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {
            !isUpdatingChildComponent && warn$1("$listeners is readonly.", vm);
        }, true);
    }
}

var currentRenderingInstance = null;

function renderMixin (Vue) {
    // install runtime convenience helpers
    installRenderHelpers(Vue.prototype);

    Vue.prototype.$nextTick = function (fn) {
        return nextTick(fn, this)
    };

    Vue.prototype._render = function () {
        var vm = this;
        var ref = vm.$options;
        var render = ref.render;
        var _parentVnode = ref._parentVnode;

        if (_parentVnode) {
            vm.$scopedSlots = normalizeScopedSlots(
                _parentVnode.data.scopedSlots,
                vm.$slots,
                vm.$scopedSlots
            );
        }

        // set parent vnode. this allows render functions to have access
        // to the data on the placeholder node.
        vm.$vnode = _parentVnode;
        // render self
        var vnode;
        try {
            // There's no need to maintain a stack because all render fns are called
            // separately from one another. Nested component's render fns are called
            // when parent component is patched.
            currentRenderingInstance = vm;
            vnode = render.call(vm._renderProxy, vm.$createElement);
        } catch (e) {
            handleError(e, vm, "render");
            // return error render result,
            // or previous vnode to prevent render error causing blank component
            /* istanbul ignore else */
            if (vm.$options.renderError) {
                try {
                    vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
                } catch (e) {
                    handleError(e, vm, "renderError");
                    vnode = vm._vnode;
                }
            } else {
                vnode = vm._vnode;
            }
        } finally {
            currentRenderingInstance = null;
        }
        // if the returned array contains only a single node, allow it
        if (Array.isArray(vnode) && vnode.length === 1) {
            vnode = vnode[0];
        }
        // return empty vnode in case the render function errored out
        if (!(vnode instanceof VNode)) {
            if (Array.isArray(vnode)) {
                warn$1(
                    'Multiple root nodes returned from render function. Render function ' +
                    'should return a single root node.',
                    vm
                );
            }
            vnode = createEmptyVNode();
        }
        // set parent
        vnode.parent = _parentVnode;
        return vnode
    };
}

/*  */

function ensureCtor (comp, base) {
    if (
        comp.__esModule ||
        (hasSymbol && comp[Symbol.toStringTag] === 'Module')
    ) {
        comp = comp.default;
    }
    return isObject$4(comp)
        ? base.extend(comp)
        : comp
}

function createAsyncPlaceholder (
    factory,
    data,
    context,
    children,
    tag
) {
    var node = createEmptyVNode();
    node.asyncFactory = factory;
    node.asyncMeta = { data: data, context: context, children: children, tag: tag };
    return node
}

function resolveAsyncComponent (
    factory,
    baseCtor
) {
    if (isTrue(factory.error) && isDef(factory.errorComp)) {
        return factory.errorComp
    }

    if (isDef(factory.resolved)) {
        return factory.resolved
    }

    var owner = currentRenderingInstance;
    if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
        // already pending
        factory.owners.push(owner);
    }

    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
        return factory.loadingComp
    }

    if (owner && !isDef(factory.owners)) {
        var owners = factory.owners = [owner];
        var sync = true;
        var timerLoading = null;
        var timerTimeout = null

        ;(owner).$on('hook:destroyed', function () { return remove(owners, owner); });

        var forceRender = function (renderCompleted) {
            for (var i = 0, l = owners.length; i < l; i++) {
                (owners[i]).$forceUpdate();
            }

            if (renderCompleted) {
                owners.length = 0;
                if (timerLoading !== null) {
                    clearTimeout(timerLoading);
                    timerLoading = null;
                }
                if (timerTimeout !== null) {
                    clearTimeout(timerTimeout);
                    timerTimeout = null;
                }
            }
        };

        var resolve = once(function (res) {
            // cache resolved
            factory.resolved = ensureCtor(res, baseCtor);
            // invoke callbacks only if this is not a synchronous resolve
            // (async resolves are shimmed as synchronous during SSR)
            if (!sync) {
                forceRender(true);
            } else {
                owners.length = 0;
            }
        });

        var reject = once(function (reason) {
            warn$1(
                "Failed to resolve async component: " + (String(factory)) +
                (reason ? ("\nReason: " + reason) : '')
            );
            if (isDef(factory.errorComp)) {
                factory.error = true;
                forceRender(true);
            }
        });

        var res = factory(resolve, reject);

        if (isObject$4(res)) {
            if (isPromise$1(res)) {
                // () => Promise
                if (isUndef(factory.resolved)) {
                    res.then(resolve, reject);
                }
            } else if (isPromise$1(res.component)) {
                res.component.then(resolve, reject);

                if (isDef(res.error)) {
                    factory.errorComp = ensureCtor(res.error, baseCtor);
                }

                if (isDef(res.loading)) {
                    factory.loadingComp = ensureCtor(res.loading, baseCtor);
                    if (res.delay === 0) {
                        factory.loading = true;
                    } else {
                        timerLoading = setTimeout(function () {
                            timerLoading = null;
                            if (isUndef(factory.resolved) && isUndef(factory.error)) {
                                factory.loading = true;
                                forceRender(false);
                            }
                        }, res.delay || 200);
                    }
                }

                if (isDef(res.timeout)) {
                    timerTimeout = setTimeout(function () {
                        timerTimeout = null;
                        if (isUndef(factory.resolved)) {
                            reject(
                                ("timeout (" + (res.timeout) + "ms)")

                            );
                        }
                    }, res.timeout);
                }
            }
        }

        sync = false;
        // return in case resolved synchronously
        return factory.loading
            ? factory.loadingComp
            : factory.resolved
    }
}

/*  */

function isAsyncPlaceholder (node) {
    return node.isComment && node.asyncFactory
}

/*  */

function getFirstComponentChild (children) {
    if (Array.isArray(children)) {
        for (var i = 0; i < children.length; i++) {
            var c = children[i];
            if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
                return c
            }
        }
    }
}

/*  */

/*  */

function initEvents (vm) {
    vm._events = Object.create(null);
    vm._hasHookEvent = false;
    // init parent attached events
    var listeners = vm.$options._parentListeners;
    if (listeners) {
        updateComponentListeners(vm, listeners);
    }
}

var target$1;

function add (event, fn) {
    target$1.$on(event, fn);
}

function remove$1 (event, fn) {
    target$1.$off(event, fn);
}

function createOnceHandler (event, fn) {
    var _target = target$1;
    return function onceHandler () {
        var res = fn.apply(null, arguments);
        if (res !== null) {
            _target.$off(event, onceHandler);
        }
    }
}

function updateComponentListeners (
    vm,
    listeners,
    oldListeners
) {
    target$1 = vm;
    updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
    target$1 = undefined;
}

function eventsMixin (Vue) {
    var hookRE = /^hook:/;
    Vue.prototype.$on = function (event, fn) {
        var vm = this;
        if (Array.isArray(event)) {
            for (var i = 0, l = event.length; i < l; i++) {
                vm.$on(event[i], fn);
            }
        } else {
            (vm._events[event] || (vm._events[event] = [])).push(fn);
            // optimize hook:event cost by using a boolean flag marked at registration
            // instead of a hash lookup
            if (hookRE.test(event)) {
                vm._hasHookEvent = true;
            }
        }
        return vm
    };

    Vue.prototype.$once = function (event, fn) {
        var vm = this;
        function on () {
            vm.$off(event, on);
            fn.apply(vm, arguments);
        }
        on.fn = fn;
        vm.$on(event, on);
        return vm
    };

    Vue.prototype.$off = function (event, fn) {
        var vm = this;
        // all
        if (!arguments.length) {
            vm._events = Object.create(null);
            return vm
        }
        // array of events
        if (Array.isArray(event)) {
            for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
                vm.$off(event[i$1], fn);
            }
            return vm
        }
        // specific event
        var cbs = vm._events[event];
        if (!cbs) {
            return vm
        }
        if (!fn) {
            vm._events[event] = null;
            return vm
        }
        // specific handler
        var cb;
        var i = cbs.length;
        while (i--) {
            cb = cbs[i];
            if (cb === fn || cb.fn === fn) {
                cbs.splice(i, 1);
                break
            }
        }
        return vm
    };

    Vue.prototype.$emit = function (event) {
        var vm = this;
        {
            var lowerCaseEvent = event.toLowerCase();
            if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
                tip(
                    "Event \"" + lowerCaseEvent + "\" is emitted in component " +
                    (formatComponentName(vm)) + " but the handler is registered for \"" + event + "\". " +
                    "Note that HTML attributes are case-insensitive and you cannot use " +
                    "v-on to listen to camelCase events when using in-DOM templates. " +
                    "You should probably use \"" + (hyphenate(event)) + "\" instead of \"" + event + "\"."
                );
            }
        }
        var cbs = vm._events[event];
        if (cbs) {
            cbs = cbs.length > 1 ? toArray(cbs) : cbs;
            var args = toArray(arguments, 1);
            var info = "event handler for \"" + event + "\"";
            for (var i = 0, l = cbs.length; i < l; i++) {
                invokeWithErrorHandling(cbs[i], vm, args, vm, info);
            }
        }
        return vm
    };
}

/*  */

var activeInstance = null;
var isUpdatingChildComponent = false;

function setActiveInstance(vm) {
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    return function () {
        activeInstance = prevActiveInstance;
    }
}

function initLifecycle (vm) {
    var options = vm.$options;

    // locate first non-abstract parent
    var parent = options.parent;
    if (parent && !options.abstract) {
        while (parent.$options.abstract && parent.$parent) {
            parent = parent.$parent;
        }
        parent.$children.push(vm);
    }

    vm.$parent = parent;
    vm.$root = parent ? parent.$root : vm;

    vm.$children = [];
    vm.$refs = {};

    vm._watcher = null;
    vm._inactive = null;
    vm._directInactive = false;
    vm._isMounted = false;
    vm._isDestroyed = false;
    vm._isBeingDestroyed = false;
}

function lifecycleMixin (Vue) {
    Vue.prototype._update = function (vnode, hydrating) {
        var vm = this;
        var prevEl = vm.$el;
        var prevVnode = vm._vnode;
        var restoreActiveInstance = setActiveInstance(vm);
        vm._vnode = vnode;
        // Vue.prototype.__patch__ is injected in entry points
        // based on the rendering backend used.
        if (!prevVnode) {
            // initial render
            vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);
        } else {
            // updates
            vm.$el = vm.__patch__(prevVnode, vnode);
        }
        restoreActiveInstance();
        // update __vue__ reference
        if (prevEl) {
            prevEl.__vue__ = null;
        }
        if (vm.$el) {
            vm.$el.__vue__ = vm;
        }
        // if parent is an HOC, update its $el as well
        if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
            vm.$parent.$el = vm.$el;
        }
        // updated hook is called by the scheduler to ensure that children are
        // updated in a parent's updated hook.
    };

    Vue.prototype.$forceUpdate = function () {
        var vm = this;
        if (vm._watcher) {
            vm._watcher.update();
        }
    };

    Vue.prototype.$destroy = function () {
        var vm = this;
        if (vm._isBeingDestroyed) {
            return
        }
        callHook(vm, 'beforeDestroy');
        vm._isBeingDestroyed = true;
        // remove self from parent
        var parent = vm.$parent;
        if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
            remove(parent.$children, vm);
        }
        // teardown watchers
        if (vm._watcher) {
            vm._watcher.teardown();
        }
        var i = vm._watchers.length;
        while (i--) {
            vm._watchers[i].teardown();
        }
        // remove reference from data ob
        // frozen object may not have observer.
        if (vm._data.__ob__) {
            vm._data.__ob__.vmCount--;
        }
        // call the last hook...
        vm._isDestroyed = true;
        // invoke destroy hooks on current rendered tree
        vm.__patch__(vm._vnode, null);
        // fire destroyed hook
        callHook(vm, 'destroyed');
        // turn off all instance listeners.
        vm.$off();
        // remove __vue__ reference
        if (vm.$el) {
            vm.$el.__vue__ = null;
        }
        // release circular reference (#6759)
        if (vm.$vnode) {
            vm.$vnode.parent = null;
        }
    };
}

function mountComponent (
    vm,
    el,
    hydrating
) {
    vm.$el = el;
    if (!vm.$options.render) {
        vm.$options.render = createEmptyVNode;
        {
            /* istanbul ignore if */
            if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
                vm.$options.el || el) {
                warn$1(
                    'You are using the runtime-only build of Vue where the template ' +
                    'compiler is not available. Either pre-compile the templates into ' +
                    'render functions, or use the compiler-included build.',
                    vm
                );
            } else {
                warn$1(
                    'Failed to mount component: template or render function not defined.',
                    vm
                );
            }
        }
    }
    callHook(vm, 'beforeMount');

    var updateComponent;
    /* istanbul ignore if */
    if (config.performance && mark) {
        updateComponent = function () {
            var name = vm._name;
            var id = vm._uid;
            var startTag = "vue-perf-start:" + id;
            var endTag = "vue-perf-end:" + id;

            mark(startTag);
            var vnode = vm._render();
            mark(endTag);
            measure(("vue " + name + " render"), startTag, endTag);

            mark(startTag);
            vm._update(vnode, hydrating);
            mark(endTag);
            measure(("vue " + name + " patch"), startTag, endTag);
        };
    } else {
        updateComponent = function () {
            vm._update(vm._render(), hydrating);
        };
    }

    // we set this to vm._watcher inside the watcher's constructor
    // since the watcher's initial patch may call $forceUpdate (e.g. inside child
    // component's mounted hook), which relies on vm._watcher being already defined
    new Watcher(vm, updateComponent, noop$1, {
        before: function before () {
            if (vm._isMounted && !vm._isDestroyed) {
                callHook(vm, 'beforeUpdate');
            }
        }
    }, true /* isRenderWatcher */);
    hydrating = false;

    // manually mounted instance, call mounted on self
    // mounted is called for render-created child components in its inserted hook
    if (vm.$vnode == null) {
        vm._isMounted = true;
        callHook(vm, 'mounted');
    }
    return vm
}

function updateChildComponent (
    vm,
    propsData,
    listeners,
    parentVnode,
    renderChildren
) {
    {
        isUpdatingChildComponent = true;
    }

    // determine whether component has slot children
    // we need to do this before overwriting $options._renderChildren.

    // check if there are dynamic scopedSlots (hand-written or compiled but with
    // dynamic slot names). Static scoped slots compiled from template has the
    // "$stable" marker.
    var newScopedSlots = parentVnode.data.scopedSlots;
    var oldScopedSlots = vm.$scopedSlots;
    var hasDynamicScopedSlot = !!(
        (newScopedSlots && !newScopedSlots.$stable) ||
        (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||
        (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key)
    );

    // Any static slot children from the parent may have changed during parent's
    // update. Dynamic scoped slots may also have changed. In such cases, a forced
    // update is necessary to ensure correctness.
    var needsForceUpdate = !!(
        renderChildren ||               // has new static slots
        vm.$options._renderChildren ||  // has old static slots
        hasDynamicScopedSlot
    );

    vm.$options._parentVnode = parentVnode;
    vm.$vnode = parentVnode; // update vm's placeholder node without re-render

    if (vm._vnode) { // update child tree's parent
        vm._vnode.parent = parentVnode;
    }
    vm.$options._renderChildren = renderChildren;

    // update $attrs and $listeners hash
    // these are also reactive so they may trigger child update if the child
    // used them during render
    vm.$attrs = parentVnode.data.attrs || emptyObject;
    vm.$listeners = listeners || emptyObject;

    // update props
    if (propsData && vm.$options.props) {
        toggleObserving(false);
        var props = vm._props;
        var propKeys = vm.$options._propKeys || [];
        for (var i = 0; i < propKeys.length; i++) {
            var key = propKeys[i];
            var propOptions = vm.$options.props; // wtf flow?
            props[key] = validateProp(key, propOptions, propsData, vm);
        }
        toggleObserving(true);
        // keep a copy of raw propsData
        vm.$options.propsData = propsData;
    }

    // update listeners
    listeners = listeners || emptyObject;
    var oldListeners = vm.$options._parentListeners;
    vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, oldListeners);

    // resolve slots + force update if has children
    if (needsForceUpdate) {
        vm.$slots = resolveSlots(renderChildren, parentVnode.context);
        vm.$forceUpdate();
    }

    {
        isUpdatingChildComponent = false;
    }
}

function isInInactiveTree (vm) {
    while (vm && (vm = vm.$parent)) {
        if (vm._inactive) { return true }
    }
    return false
}

function activateChildComponent (vm, direct) {
    if (direct) {
        vm._directInactive = false;
        if (isInInactiveTree(vm)) {
            return
        }
    } else if (vm._directInactive) {
        return
    }
    if (vm._inactive || vm._inactive === null) {
        vm._inactive = false;
        for (var i = 0; i < vm.$children.length; i++) {
            activateChildComponent(vm.$children[i]);
        }
        callHook(vm, 'activated');
    }
}

function deactivateChildComponent (vm, direct) {
    if (direct) {
        vm._directInactive = true;
        if (isInInactiveTree(vm)) {
            return
        }
    }
    if (!vm._inactive) {
        vm._inactive = true;
        for (var i = 0; i < vm.$children.length; i++) {
            deactivateChildComponent(vm.$children[i]);
        }
        callHook(vm, 'deactivated');
    }
}

function callHook (vm, hook) {
    // #7573 disable dep collection when invoking lifecycle hooks
    pushTarget();
    var handlers = vm.$options[hook];
    var info = hook + " hook";
    if (handlers) {
        for (var i = 0, j = handlers.length; i < j; i++) {
            invokeWithErrorHandling(handlers[i], vm, null, vm, info);
        }
    }
    if (vm._hasHookEvent) {
        vm.$emit('hook:' + hook);
    }
    popTarget();
}

/*  */

var MAX_UPDATE_COUNT = 100;

var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index$1 = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState () {
    index$1 = queue.length = activatedChildren.length = 0;
    has = {};
    {
        circular = {};
    }
    waiting = flushing = false;
}

// Async edge case #6566 requires saving the timestamp when event listeners are
// attached. However, calling performance.now() has a perf overhead especially
// if the page has thousands of event listeners. Instead, we take a timestamp
// every time the scheduler flushes and use that for all event listeners
// attached during that flush.
var currentFlushTimestamp = 0;

// Async edge case fix requires storing an event listener's attach timestamp.
var getNow = Date.now;

// Determine what event timestamp the browser is using. Annoyingly, the
// timestamp can either be hi-res (relative to page load) or low-res
// (relative to UNIX epoch), so in order to compare time we have to use the
// same timestamp type when saving the flush timestamp.
// All IE versions use low-res event timestamps, and have problematic clock
// implementations (#9632)
if (inBrowser && !isIE$1) {
    var performance = window.performance;
    if (
        performance &&
        typeof performance.now === 'function' &&
        getNow() > document.createEvent('Event').timeStamp
    ) {
        // if the event timestamp, although evaluated AFTER the Date.now(), is
        // smaller than it, it means the event is using a hi-res timestamp,
        // and we need to use the hi-res version for event listener timestamps as
        // well.
        getNow = function () { return performance.now(); };
    }
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue () {
    currentFlushTimestamp = getNow();
    flushing = true;
    var watcher, id;

    // Sort queue before flush.
    // This ensures that:
    // 1. Components are updated from parent to child. (because parent is always
    //    created before the child)
    // 2. A component's user watchers are run before its render watcher (because
    //    user watchers are created before the render watcher)
    // 3. If a component is destroyed during a parent component's watcher run,
    //    its watchers can be skipped.
    queue.sort(function (a, b) { return a.id - b.id; });

    // do not cache length because more watchers might be pushed
    // as we run existing watchers
    for (index$1 = 0; index$1 < queue.length; index$1++) {
        watcher = queue[index$1];
        if (watcher.before) {
            watcher.before();
        }
        id = watcher.id;
        has[id] = null;
        watcher.run();
        // in dev build, check and stop circular updates.
        if (has[id] != null) {
            circular[id] = (circular[id] || 0) + 1;
            if (circular[id] > MAX_UPDATE_COUNT) {
                warn$1(
                    'You may have an infinite update loop ' + (
                        watcher.user
                            ? ("in watcher with expression \"" + (watcher.expression) + "\"")
                            : "in a component render function."
                    ),
                    watcher.vm
                );
                break
            }
        }
    }

    // keep copies of post queues before resetting state
    var activatedQueue = activatedChildren.slice();
    var updatedQueue = queue.slice();

    resetSchedulerState();

    // call component updated and activated hooks
    callActivatedHooks(activatedQueue);
    callUpdatedHooks(updatedQueue);

    // devtool hook
    /* istanbul ignore if */
    if (devtools && config.devtools) {
        devtools.emit('flush');
    }
}

function callUpdatedHooks (queue) {
    var i = queue.length;
    while (i--) {
        var watcher = queue[i];
        var vm = watcher.vm;
        if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
            callHook(vm, 'updated');
        }
    }
}

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent (vm) {
    // setting _inactive to false here so that a render function can
    // rely on checking whether it's in an inactive tree (e.g. router-view)
    vm._inactive = false;
    activatedChildren.push(vm);
}

function callActivatedHooks (queue) {
    for (var i = 0; i < queue.length; i++) {
        queue[i]._inactive = true;
        activateChildComponent(queue[i], true /* true */);
    }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher (watcher) {
    var id = watcher.id;
    if (has[id] == null) {
        has[id] = true;
        if (!flushing) {
            queue.push(watcher);
        } else {
            // if already flushing, splice the watcher based on its id
            // if already past its id, it will be run next immediately.
            var i = queue.length - 1;
            while (i > index$1 && queue[i].id > watcher.id) {
                i--;
            }
            queue.splice(i + 1, 0, watcher);
        }
        // queue the flush
        if (!waiting) {
            waiting = true;

            if (!config.async) {
                flushSchedulerQueue();
                return
            }
            nextTick(flushSchedulerQueue);
        }
    }
}

/*  */



var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher (
    vm,
    expOrFn,
    cb,
    options,
    isRenderWatcher
) {
    this.vm = vm;
    if (isRenderWatcher) {
        vm._watcher = this;
    }
    vm._watchers.push(this);
    // options
    if (options) {
        this.deep = !!options.deep;
        this.user = !!options.user;
        this.lazy = !!options.lazy;
        this.sync = !!options.sync;
        this.before = options.before;
    } else {
        this.deep = this.user = this.lazy = this.sync = false;
    }
    this.cb = cb;
    this.id = ++uid$2; // uid for batching
    this.active = true;
    this.dirty = this.lazy; // for lazy watchers
    this.deps = [];
    this.newDeps = [];
    this.depIds = new _Set();
    this.newDepIds = new _Set();
    this.expression = expOrFn.toString()
    ;
    // parse expression for getter
    if (typeof expOrFn === 'function') {
        this.getter = expOrFn;
    } else {
        this.getter = parsePath(expOrFn);
        if (!this.getter) {
            this.getter = noop$1;
            warn$1(
                "Failed watching path: \"" + expOrFn + "\" " +
                'Watcher only accepts simple dot-delimited paths. ' +
                'For full control, use a function instead.',
                vm
            );
        }
    }
    this.value = this.lazy
        ? undefined
        : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get () {
    pushTarget(this);
    var value;
    var vm = this.vm;
    try {
        value = this.getter.call(vm, vm);
    } catch (e) {
        if (this.user) {
            handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
        } else {
            throw e
        }
    } finally {
        // "touch" every property so they are all tracked as
        // dependencies for deep watching
        if (this.deep) {
            traverse(value);
        }
        popTarget();
        this.cleanupDeps();
    }
    return value
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep (dep) {
    var id = dep.id;
    if (!this.newDepIds.has(id)) {
        this.newDepIds.add(id);
        this.newDeps.push(dep);
        if (!this.depIds.has(id)) {
            dep.addSub(this);
        }
    }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps () {
    var i = this.deps.length;
    while (i--) {
        var dep = this.deps[i];
        if (!this.newDepIds.has(dep.id)) {
            dep.removeSub(this);
        }
    }
    var tmp = this.depIds;
    this.depIds = this.newDepIds;
    this.newDepIds = tmp;
    this.newDepIds.clear();
    tmp = this.deps;
    this.deps = this.newDeps;
    this.newDeps = tmp;
    this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update () {
    /* istanbul ignore else */
    if (this.lazy) {
        this.dirty = true;
    } else if (this.sync) {
        this.run();
    } else {
        queueWatcher(this);
    }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run () {
    if (this.active) {
        var value = this.get();
        if (
            value !== this.value ||
            // Deep watchers and watchers on Object/Arrays should fire even
            // when the value is the same, because the value may
            // have mutated.
            isObject$4(value) ||
            this.deep
        ) {
            // set new value
            var oldValue = this.value;
            this.value = value;
            if (this.user) {
                try {
                    this.cb.call(this.vm, value, oldValue);
                } catch (e) {
                    handleError(e, this.vm, ("callback for watcher \"" + (this.expression) + "\""));
                }
            } else {
                this.cb.call(this.vm, value, oldValue);
            }
        }
    }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate () {
    this.value = this.get();
    this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend () {
    var i = this.deps.length;
    while (i--) {
        this.deps[i].depend();
    }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown () {
    if (this.active) {
        // remove self from vm's watcher list
        // this is a somewhat expensive operation so we skip it
        // if the vm is being destroyed.
        if (!this.vm._isBeingDestroyed) {
            remove(this.vm._watchers, this);
        }
        var i = this.deps.length;
        while (i--) {
            this.deps[i].removeSub(this);
        }
        this.active = false;
    }
};

/*  */

var sharedPropertyDefinition = {
    enumerable: true,
    configurable: true,
    get: noop$1,
    set: noop$1
};

function proxy (target, sourceKey, key) {
    sharedPropertyDefinition.get = function proxyGetter () {
        return this[sourceKey][key]
    };
    sharedPropertyDefinition.set = function proxySetter (val) {
        this[sourceKey][key] = val;
    };
    Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState (vm) {
    vm._watchers = [];
    var opts = vm.$options;
    if (opts.props) { initProps(vm, opts.props); }
    if (opts.methods) { initMethods(vm, opts.methods); }
    if (opts.data) {
        initData(vm);
    } else {
        observe(vm._data = {}, true /* asRootData */);
    }
    if (opts.computed) { initComputed(vm, opts.computed); }
    if (opts.watch && opts.watch !== nativeWatch) {
        initWatch(vm, opts.watch);
    }
}

function initProps (vm, propsOptions) {
    var propsData = vm.$options.propsData || {};
    var props = vm._props = {};
    // cache prop keys so that future props updates can iterate using Array
    // instead of dynamic object key enumeration.
    var keys = vm.$options._propKeys = [];
    var isRoot = !vm.$parent;
    // root instance props should be converted
    if (!isRoot) {
        toggleObserving(false);
    }
    var loop = function ( key ) {
        keys.push(key);
        var value = validateProp(key, propsOptions, propsData, vm);
        /* istanbul ignore else */
        {
            var hyphenatedKey = hyphenate(key);
            if (isReservedAttribute(hyphenatedKey) ||
                config.isReservedAttr(hyphenatedKey)) {
                warn$1(
                    ("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop."),
                    vm
                );
            }
            defineReactive$$1(props, key, value, function () {
                if (!isRoot && !isUpdatingChildComponent) {
                    warn$1(
                        "Avoid mutating a prop directly since the value will be " +
                        "overwritten whenever the parent component re-renders. " +
                        "Instead, use a data or computed property based on the prop's " +
                        "value. Prop being mutated: \"" + key + "\"",
                        vm
                    );
                }
            });
        }
        // static props are already proxied on the component's prototype
        // during Vue.extend(). We only need to proxy props defined at
        // instantiation here.
        if (!(key in vm)) {
            proxy(vm, "_props", key);
        }
    };

    for (var key in propsOptions) loop( key );
    toggleObserving(true);
}

function initData (vm) {
    var data = vm.$options.data;
    data = vm._data = typeof data === 'function'
        ? getData(data, vm)
        : data || {};
    if (!isPlainObject$2(data)) {
        data = {};
        warn$1(
            'data functions should return an object:\n' +
            'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
            vm
        );
    }
    // proxy data on instance
    var keys = Object.keys(data);
    var props = vm.$options.props;
    var methods = vm.$options.methods;
    var i = keys.length;
    while (i--) {
        var key = keys[i];
        {
            if (methods && hasOwn(methods, key)) {
                warn$1(
                    ("Method \"" + key + "\" has already been defined as a data property."),
                    vm
                );
            }
        }
        if (props && hasOwn(props, key)) {
            warn$1(
                "The data property \"" + key + "\" is already declared as a prop. " +
                "Use prop default value instead.",
                vm
            );
        } else if (!isReserved(key)) {
            proxy(vm, "_data", key);
        }
    }
    // observe data
    observe(data, true /* asRootData */);
}

function getData (data, vm) {
    // #7573 disable dep collection when invoking data getters
    pushTarget();
    try {
        return data.call(vm, vm)
    } catch (e) {
        handleError(e, vm, "data()");
        return {}
    } finally {
        popTarget();
    }
}

var computedWatcherOptions = { lazy: true };

function initComputed (vm, computed) {
    // $flow-disable-line
    var watchers = vm._computedWatchers = Object.create(null);
    // computed properties are just getters during SSR
    var isSSR = isServerRendering();

    for (var key in computed) {
        var userDef = computed[key];
        var getter = typeof userDef === 'function' ? userDef : userDef.get;
        if (getter == null) {
            warn$1(
                ("Getter is missing for computed property \"" + key + "\"."),
                vm
            );
        }

        if (!isSSR) {
            // create internal watcher for the computed property.
            watchers[key] = new Watcher(
                vm,
                getter || noop$1,
                noop$1,
                computedWatcherOptions
            );
        }

        // component-defined computed properties are already defined on the
        // component prototype. We only need to define computed properties defined
        // at instantiation here.
        if (!(key in vm)) {
            defineComputed(vm, key, userDef);
        } else {
            if (key in vm.$data) {
                warn$1(("The computed property \"" + key + "\" is already defined in data."), vm);
            } else if (vm.$options.props && key in vm.$options.props) {
                warn$1(("The computed property \"" + key + "\" is already defined as a prop."), vm);
            }
        }
    }
}

function defineComputed (
    target,
    key,
    userDef
) {
    var shouldCache = !isServerRendering();
    if (typeof userDef === 'function') {
        sharedPropertyDefinition.get = shouldCache
            ? createComputedGetter(key)
            : createGetterInvoker(userDef);
        sharedPropertyDefinition.set = noop$1;
    } else {
        sharedPropertyDefinition.get = userDef.get
            ? shouldCache && userDef.cache !== false
                ? createComputedGetter(key)
                : createGetterInvoker(userDef.get)
            : noop$1;
        sharedPropertyDefinition.set = userDef.set || noop$1;
    }
    if (sharedPropertyDefinition.set === noop$1) {
        sharedPropertyDefinition.set = function () {
            warn$1(
                ("Computed property \"" + key + "\" was assigned to but it has no setter."),
                this
            );
        };
    }
    Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter (key) {
    return function computedGetter () {
        var watcher = this._computedWatchers && this._computedWatchers[key];
        if (watcher) {
            if (watcher.dirty) {
                watcher.evaluate();
            }
            if (Dep.target) {
                watcher.depend();
            }
            return watcher.value
        }
    }
}

function createGetterInvoker(fn) {
    return function computedGetter () {
        return fn.call(this, this)
    }
}

function initMethods (vm, methods) {
    var props = vm.$options.props;
    for (var key in methods) {
        {
            if (typeof methods[key] !== 'function') {
                warn$1(
                    "Method \"" + key + "\" has type \"" + (typeof methods[key]) + "\" in the component definition. " +
                    "Did you reference the function correctly?",
                    vm
                );
            }
            if (props && hasOwn(props, key)) {
                warn$1(
                    ("Method \"" + key + "\" has already been defined as a prop."),
                    vm
                );
            }
            if ((key in vm) && isReserved(key)) {
                warn$1(
                    "Method \"" + key + "\" conflicts with an existing Vue instance method. " +
                    "Avoid defining component methods that start with _ or $."
                );
            }
        }
        vm[key] = typeof methods[key] !== 'function' ? noop$1 : bind$2(methods[key], vm);
    }
}

function initWatch (vm, watch) {
    for (var key in watch) {
        var handler = watch[key];
        if (Array.isArray(handler)) {
            for (var i = 0; i < handler.length; i++) {
                createWatcher(vm, key, handler[i]);
            }
        } else {
            createWatcher(vm, key, handler);
        }
    }
}

function createWatcher (
    vm,
    expOrFn,
    handler,
    options
) {
    if (isPlainObject$2(handler)) {
        options = handler;
        handler = handler.handler;
    }
    if (typeof handler === 'string') {
        handler = vm[handler];
    }
    return vm.$watch(expOrFn, handler, options)
}

function stateMixin (Vue) {
    // flow somehow has problems with directly declared definition object
    // when using Object.defineProperty, so we have to procedurally build up
    // the object here.
    var dataDef = {};
    dataDef.get = function () { return this._data };
    var propsDef = {};
    propsDef.get = function () { return this._props };
    {
        dataDef.set = function () {
            warn$1(
                'Avoid replacing instance root $data. ' +
                'Use nested data properties instead.',
                this
            );
        };
        propsDef.set = function () {
            warn$1("$props is readonly.", this);
        };
    }
    Object.defineProperty(Vue.prototype, '$data', dataDef);
    Object.defineProperty(Vue.prototype, '$props', propsDef);

    Vue.prototype.$set = set$1;
    Vue.prototype.$delete = del;

    Vue.prototype.$watch = function (
        expOrFn,
        cb,
        options
    ) {
        var vm = this;
        if (isPlainObject$2(cb)) {
            return createWatcher(vm, expOrFn, cb, options)
        }
        options = options || {};
        options.user = true;
        var watcher = new Watcher(vm, expOrFn, cb, options);
        if (options.immediate) {
            try {
                cb.call(vm, watcher.value);
            } catch (error) {
                handleError(error, vm, ("callback for immediate watcher \"" + (watcher.expression) + "\""));
            }
        }
        return function unwatchFn () {
            watcher.teardown();
        }
    };
}

/*  */

var uid$3 = 0;

function initMixin (Vue) {
    Vue.prototype._init = function (options) {
        var vm = this;
        // a uid
        vm._uid = uid$3++;

        var startTag, endTag;
        /* istanbul ignore if */
        if (config.performance && mark) {
            startTag = "vue-perf-start:" + (vm._uid);
            endTag = "vue-perf-end:" + (vm._uid);
            mark(startTag);
        }

        // a flag to avoid this being observed
        vm._isVue = true;
        // merge options
        if (options && options._isComponent) {
            // optimize internal component instantiation
            // since dynamic options merging is pretty slow, and none of the
            // internal component options needs special treatment.
            initInternalComponent(vm, options);
        } else {
            vm.$options = mergeOptions(
                resolveConstructorOptions(vm.constructor),
                options || {},
                vm
            );
        }
        /* istanbul ignore else */
        {
            initProxy(vm);
        }
        // expose real self
        vm._self = vm;
        initLifecycle(vm);
        initEvents(vm);
        initRender(vm);
        callHook(vm, 'beforeCreate');
        initInjections(vm); // resolve injections before data/props
        initState(vm);
        initProvide(vm); // resolve provide after data/props
        callHook(vm, 'created');

        /* istanbul ignore if */
        if (config.performance && mark) {
            vm._name = formatComponentName(vm, false);
            mark(endTag);
            measure(("vue " + (vm._name) + " init"), startTag, endTag);
        }

        if (vm.$options.el) {
            vm.$mount(vm.$options.el);
        }
    };
}

function initInternalComponent (vm, options) {
    var opts = vm.$options = Object.create(vm.constructor.options);
    // doing this because it's faster than dynamic enumeration.
    var parentVnode = options._parentVnode;
    opts.parent = options.parent;
    opts._parentVnode = parentVnode;

    var vnodeComponentOptions = parentVnode.componentOptions;
    opts.propsData = vnodeComponentOptions.propsData;
    opts._parentListeners = vnodeComponentOptions.listeners;
    opts._renderChildren = vnodeComponentOptions.children;
    opts._componentTag = vnodeComponentOptions.tag;

    if (options.render) {
        opts.render = options.render;
        opts.staticRenderFns = options.staticRenderFns;
    }
}

function resolveConstructorOptions (Ctor) {
    var options = Ctor.options;
    if (Ctor.super) {
        var superOptions = resolveConstructorOptions(Ctor.super);
        var cachedSuperOptions = Ctor.superOptions;
        if (superOptions !== cachedSuperOptions) {
            // super option changed,
            // need to resolve new options.
            Ctor.superOptions = superOptions;
            // check if there are any late-modified/attached options (#4976)
            var modifiedOptions = resolveModifiedOptions(Ctor);
            // update base extend options
            if (modifiedOptions) {
                extend$1(Ctor.extendOptions, modifiedOptions);
            }
            options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
            if (options.name) {
                options.components[options.name] = Ctor;
            }
        }
    }
    return options
}

function resolveModifiedOptions (Ctor) {
    var modified;
    var latest = Ctor.options;
    var sealed = Ctor.sealedOptions;
    for (var key in latest) {
        if (latest[key] !== sealed[key]) {
            if (!modified) { modified = {}; }
            modified[key] = latest[key];
        }
    }
    return modified
}

function Vue$1 (options) {
    if (!(this instanceof Vue$1)
    ) {
        warn$1('Vue is a constructor and should be called with the `new` keyword');
    }
    this._init(options);
}

initMixin(Vue$1);
stateMixin(Vue$1);
eventsMixin(Vue$1);
lifecycleMixin(Vue$1);
renderMixin(Vue$1);

/*  */

function initUse (Vue) {
    Vue.use = function (plugin) {
        var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));
        if (installedPlugins.indexOf(plugin) > -1) {
            return this
        }

        // additional parameters
        var args = toArray(arguments, 1);
        args.unshift(this);
        if (typeof plugin.install === 'function') {
            plugin.install.apply(plugin, args);
        } else if (typeof plugin === 'function') {
            plugin.apply(null, args);
        }
        installedPlugins.push(plugin);
        return this
    };
}

/*  */

function initMixin$1 (Vue) {
    Vue.mixin = function (mixin) {
        this.options = mergeOptions(this.options, mixin);
        return this
    };
}

/*  */

function initExtend (Vue) {
    /**
     * Each instance constructor, including Vue, has a unique
     * cid. This enables us to create wrapped "child
     * constructors" for prototypal inheritance and cache them.
     */
    Vue.cid = 0;
    var cid = 1;

    /**
     * Class inheritance
     */
    Vue.extend = function (extendOptions) {
        extendOptions = extendOptions || {};
        var Super = this;
        var SuperId = Super.cid;
        var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
        if (cachedCtors[SuperId]) {
            return cachedCtors[SuperId]
        }

        var name = extendOptions.name || Super.options.name;
        if (name) {
            validateComponentName(name);
        }

        var Sub = function VueComponent (options) {
            this._init(options);
        };
        Sub.prototype = Object.create(Super.prototype);
        Sub.prototype.constructor = Sub;
        Sub.cid = cid++;
        Sub.options = mergeOptions(
            Super.options,
            extendOptions
        );
        Sub['super'] = Super;

        // For props and computed properties, we define the proxy getters on
        // the Vue instances at extension time, on the extended prototype. This
        // avoids Object.defineProperty calls for each instance created.
        if (Sub.options.props) {
            initProps$1(Sub);
        }
        if (Sub.options.computed) {
            initComputed$1(Sub);
        }

        // allow further extension/mixin/plugin usage
        Sub.extend = Super.extend;
        Sub.mixin = Super.mixin;
        Sub.use = Super.use;

        // create asset registers, so extended classes
        // can have their private assets too.
        ASSET_TYPES.forEach(function (type) {
            Sub[type] = Super[type];
        });
        // enable recursive self-lookup
        if (name) {
            Sub.options.components[name] = Sub;
        }

        // keep a reference to the super options at extension time.
        // later at instantiation we can check if Super's options have
        // been updated.
        Sub.superOptions = Super.options;
        Sub.extendOptions = extendOptions;
        Sub.sealedOptions = extend$1({}, Sub.options);

        // cache constructor
        cachedCtors[SuperId] = Sub;
        return Sub
    };
}

function initProps$1 (Comp) {
    var props = Comp.options.props;
    for (var key in props) {
        proxy(Comp.prototype, "_props", key);
    }
}

function initComputed$1 (Comp) {
    var computed = Comp.options.computed;
    for (var key in computed) {
        defineComputed(Comp.prototype, key, computed[key]);
    }
}

/*  */

function initAssetRegisters (Vue) {
    /**
     * Create asset registration methods.
     */
    ASSET_TYPES.forEach(function (type) {
        Vue[type] = function (
            id,
            definition
        ) {
            if (!definition) {
                return this.options[type + 's'][id]
            } else {
                /* istanbul ignore if */
                if (type === 'component') {
                    validateComponentName(id);
                }
                if (type === 'component' && isPlainObject$2(definition)) {
                    definition.name = definition.name || id;
                    definition = this.options._base.extend(definition);
                }
                if (type === 'directive' && typeof definition === 'function') {
                    definition = { bind: definition, update: definition };
                }
                this.options[type + 's'][id] = definition;
                return definition
            }
        };
    });
}

/*  */



function getComponentName (opts) {
    return opts && (opts.Ctor.options.name || opts.tag)
}

function matches$1 (pattern, name) {
    if (Array.isArray(pattern)) {
        return pattern.indexOf(name) > -1
    } else if (typeof pattern === 'string') {
        return pattern.split(',').indexOf(name) > -1
    } else if (isRegExp(pattern)) {
        return pattern.test(name)
    }
    /* istanbul ignore next */
    return false
}

function pruneCache (keepAliveInstance, filter) {
    var cache = keepAliveInstance.cache;
    var keys = keepAliveInstance.keys;
    var _vnode = keepAliveInstance._vnode;
    for (var key in cache) {
        var cachedNode = cache[key];
        if (cachedNode) {
            var name = getComponentName(cachedNode.componentOptions);
            if (name && !filter(name)) {
                pruneCacheEntry(cache, key, keys, _vnode);
            }
        }
    }
}

function pruneCacheEntry (
    cache,
    key,
    keys,
    current
) {
    var cached$$1 = cache[key];
    if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
        cached$$1.componentInstance.$destroy();
    }
    cache[key] = null;
    remove(keys, key);
}

var patternTypes = [String, RegExp, Array];

var KeepAlive = {
    name: 'keep-alive',
    abstract: true,

    props: {
        include: patternTypes,
        exclude: patternTypes,
        max: [String, Number]
    },

    created: function created () {
        this.cache = Object.create(null);
        this.keys = [];
    },

    destroyed: function destroyed () {
        for (var key in this.cache) {
            pruneCacheEntry(this.cache, key, this.keys);
        }
    },

    mounted: function mounted () {
        var this$1 = this;

        this.$watch('include', function (val) {
            pruneCache(this$1, function (name) { return matches$1(val, name); });
        });
        this.$watch('exclude', function (val) {
            pruneCache(this$1, function (name) { return !matches$1(val, name); });
        });
    },

    render: function render () {
        var slot = this.$slots.default;
        var vnode = getFirstComponentChild(slot);
        var componentOptions = vnode && vnode.componentOptions;
        if (componentOptions) {
            // check pattern
            var name = getComponentName(componentOptions);
            var ref = this;
            var include = ref.include;
            var exclude = ref.exclude;
            if (
                // not included
                (include && (!name || !matches$1(include, name))) ||
                // excluded
                (exclude && name && matches$1(exclude, name))
            ) {
                return vnode
            }

            var ref$1 = this;
            var cache = ref$1.cache;
            var keys = ref$1.keys;
            var key = vnode.key == null
                // same constructor may get registered as different local components
                // so cid alone is not enough (#3269)
                ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
                : vnode.key;
            if (cache[key]) {
                vnode.componentInstance = cache[key].componentInstance;
                // make current key freshest
                remove(keys, key);
                keys.push(key);
            } else {
                cache[key] = vnode;
                keys.push(key);
                // prune oldest entry
                if (this.max && keys.length > parseInt(this.max)) {
                    pruneCacheEntry(cache, keys[0], keys, this._vnode);
                }
            }

            vnode.data.keepAlive = true;
        }
        return vnode || (slot && slot[0])
    }
};

var builtInComponents = {
    KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI (Vue) {
    // config
    var configDef = {};
    configDef.get = function () { return config; };
    {
        configDef.set = function () {
            warn$1(
                'Do not replace the Vue.config object, set individual fields instead.'
            );
        };
    }
    Object.defineProperty(Vue, 'config', configDef);

    // exposed util methods.
    // NOTE: these are not considered part of the public API - avoid relying on
    // them unless you are aware of the risk.
    Vue.util = {
        warn: warn$1,
        extend: extend$1,
        mergeOptions: mergeOptions,
        defineReactive: defineReactive$$1
    };

    Vue.set = set$1;
    Vue.delete = del;
    Vue.nextTick = nextTick;

    // 2.6 explicit observable API
    Vue.observable = function (obj) {
        observe(obj);
        return obj
    };

    Vue.options = Object.create(null);
    ASSET_TYPES.forEach(function (type) {
        Vue.options[type + 's'] = Object.create(null);
    });

    // this is used to identify the "base" constructor to extend all plain-object
    // components with in Weex's multi-instance scenarios.
    Vue.options._base = Vue;

    extend$1(Vue.options.components, builtInComponents);

    initUse(Vue);
    initMixin$1(Vue);
    initExtend(Vue);
    initAssetRegisters(Vue);
}

initGlobalAPI(Vue$1);

Object.defineProperty(Vue$1.prototype, '$isServer', {
    get: isServerRendering
});

Object.defineProperty(Vue$1.prototype, '$ssrContext', {
    get: function get () {
        /* istanbul ignore next */
        return this.$vnode && this.$vnode.ssrContext
    }
});

// expose FunctionalRenderContext for ssr runtime helper installation
Object.defineProperty(Vue$1, 'FunctionalRenderContext', {
    value: FunctionalRenderContext
});

Vue$1.version = '2.6.12';

/*  */

// these are reserved for web because they are directly compiled away
// during template compilation
var isReservedAttr = makeMap('style,class');

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select,progress');
var mustUseProp = function (tag, type, attr) {
    return (
        (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
        (attr === 'selected' && tag === 'option') ||
        (attr === 'checked' && tag === 'input') ||
        (attr === 'muted' && tag === 'video')
    )
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');

var convertEnumeratedValue = function (key, value) {
    return isFalsyAttrValue(value) || value === 'false'
        ? 'false'
        // allow arbitrary string value for contenteditable
        : key === 'contenteditable' && isValidContentEditableValue(value)
            ? value
            : 'true'
};

var isBooleanAttr = makeMap(
    'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
    'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
    'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
    'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
    'required,reversed,scoped,seamless,selected,sortable,translate,' +
    'truespeed,typemustmatch,visible'
);

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
};

var getXlinkProp = function (name) {
    return isXlink(name) ? name.slice(6, name.length) : ''
};

var isFalsyAttrValue = function (val) {
    return val == null || val === false
};

/*  */

function genClassForVnode (vnode) {
    var data = vnode.data;
    var parentNode = vnode;
    var childNode = vnode;
    while (isDef(childNode.componentInstance)) {
        childNode = childNode.componentInstance._vnode;
        if (childNode && childNode.data) {
            data = mergeClassData(childNode.data, data);
        }
    }
    while (isDef(parentNode = parentNode.parent)) {
        if (parentNode && parentNode.data) {
            data = mergeClassData(data, parentNode.data);
        }
    }
    return renderClass(data.staticClass, data.class)
}

function mergeClassData (child, parent) {
    return {
        staticClass: concat$1(child.staticClass, parent.staticClass),
        class: isDef(child.class)
            ? [child.class, parent.class]
            : parent.class
    }
}

function renderClass (
    staticClass,
    dynamicClass
) {
    if (isDef(staticClass) || isDef(dynamicClass)) {
        return concat$1(staticClass, stringifyClass(dynamicClass))
    }
    /* istanbul ignore next */
    return ''
}

function concat$1 (a, b) {
    return a ? b ? (a + ' ' + b) : a : (b || '')
}

function stringifyClass (value) {
    if (Array.isArray(value)) {
        return stringifyArray(value)
    }
    if (isObject$4(value)) {
        return stringifyObject(value)
    }
    if (typeof value === 'string') {
        return value
    }
    /* istanbul ignore next */
    return ''
}

function stringifyArray (value) {
    var res = '';
    var stringified;
    for (var i = 0, l = value.length; i < l; i++) {
        if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
            if (res) { res += ' '; }
            res += stringified;
        }
    }
    return res
}

function stringifyObject (value) {
    var res = '';
    for (var key in value) {
        if (value[key]) {
            if (res) { res += ' '; }
            res += key;
        }
    }
    return res
}

/*  */

var namespaceMap = {
    svg: 'http://www.w3.org/2000/svg',
    math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap(
    'html,body,base,head,link,meta,style,title,' +
    'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
    'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +
    'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
    's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
    'embed,object,param,source,canvas,script,noscript,del,ins,' +
    'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
    'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
    'output,progress,select,textarea,' +
    'details,dialog,menu,menuitem,summary,' +
    'content,element,shadow,template,blockquote,iframe,tfoot'
);

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap(
    'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
    'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
    'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
    true
);

var isReservedTag = function (tag) {
    return isHTMLTag(tag) || isSVG(tag)
};

function getTagNamespace (tag) {
    if (isSVG(tag)) {
        return 'svg'
    }
    // basic support for MathML
    // note it doesn't support other MathML elements being component roots
    if (tag === 'math') {
        return 'math'
    }
}

var unknownElementCache = Object.create(null);
function isUnknownElement (tag) {
    /* istanbul ignore if */
    if (!inBrowser) {
        return true
    }
    if (isReservedTag(tag)) {
        return false
    }
    tag = tag.toLowerCase();
    /* istanbul ignore if */
    if (unknownElementCache[tag] != null) {
        return unknownElementCache[tag]
    }
    var el = document.createElement(tag);
    if (tag.indexOf('-') > -1) {
        // http://stackoverflow.com/a/28210364/1070244
        return (unknownElementCache[tag] = (
            el.constructor === window.HTMLUnknownElement ||
            el.constructor === window.HTMLElement
        ))
    } else {
        return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
    }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query (el) {
    if (typeof el === 'string') {
        var selected = document.querySelector(el);
        if (!selected) {
            warn$1(
                'Cannot find element: ' + el
            );
            return document.createElement('div')
        }
        return selected
    } else {
        return el
    }
}

/*  */

function createElement$1 (tagName, vnode) {
    var elm = document.createElement(tagName);
    if (tagName !== 'select') {
        return elm
    }
    // false or null will remove the attribute but undefined will not
    if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
        elm.setAttribute('multiple', 'multiple');
    }
    return elm
}

function createElementNS (namespace, tagName) {
    return document.createElementNS(namespaceMap[namespace], tagName)
}

function createTextNode (text) {
    return document.createTextNode(text)
}

function createComment (text) {
    return document.createComment(text)
}

function insertBefore (parentNode, newNode, referenceNode) {
    parentNode.insertBefore(newNode, referenceNode);
}

function removeChild (node, child) {
    node.removeChild(child);
}

function appendChild (node, child) {
    node.appendChild(child);
}

function parentNode (node) {
    return node.parentNode
}

function nextSibling (node) {
    return node.nextSibling
}

function tagName (node) {
    return node.tagName
}

function setTextContent (node, text) {
    node.textContent = text;
}

function setStyleScope (node, scopeId) {
    node.setAttribute(scopeId, '');
}

var nodeOps = /*#__PURE__*/Object.freeze({
    createElement: createElement$1,
    createElementNS: createElementNS,
    createTextNode: createTextNode,
    createComment: createComment,
    insertBefore: insertBefore,
    removeChild: removeChild,
    appendChild: appendChild,
    parentNode: parentNode,
    nextSibling: nextSibling,
    tagName: tagName,
    setTextContent: setTextContent,
    setStyleScope: setStyleScope
});

/*  */

var ref = {
    create: function create (_, vnode) {
        registerRef(vnode);
    },
    update: function update (oldVnode, vnode) {
        if (oldVnode.data.ref !== vnode.data.ref) {
            registerRef(oldVnode, true);
            registerRef(vnode);
        }
    },
    destroy: function destroy (vnode) {
        registerRef(vnode, true);
    }
};

function registerRef (vnode, isRemoval) {
    var key = vnode.data.ref;
    if (!isDef(key)) { return }

    var vm = vnode.context;
    var ref = vnode.componentInstance || vnode.elm;
    var refs = vm.$refs;
    if (isRemoval) {
        if (Array.isArray(refs[key])) {
            remove(refs[key], ref);
        } else if (refs[key] === ref) {
            refs[key] = undefined;
        }
    } else {
        if (vnode.data.refInFor) {
            if (!Array.isArray(refs[key])) {
                refs[key] = [ref];
            } else if (refs[key].indexOf(ref) < 0) {
                // $flow-disable-line
                refs[key].push(ref);
            }
        } else {
            refs[key] = ref;
        }
    }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode (a, b) {
    return (
        a.key === b.key && (
            (
                a.tag === b.tag &&
                a.isComment === b.isComment &&
                isDef(a.data) === isDef(b.data) &&
                sameInputType(a, b)
            ) || (
                isTrue(a.isAsyncPlaceholder) &&
                a.asyncFactory === b.asyncFactory &&
                isUndef(b.asyncFactory.error)
            )
        )
    )
}

function sameInputType (a, b) {
    if (a.tag !== 'input') { return true }
    var i;
    var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
    var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
    return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)
}

function createKeyToOldIdx (children, beginIdx, endIdx) {
    var i, key;
    var map = {};
    for (i = beginIdx; i <= endIdx; ++i) {
        key = children[i].key;
        if (isDef(key)) { map[key] = i; }
    }
    return map
}

function createPatchFunction (backend) {
    var i, j;
    var cbs = {};

    var modules = backend.modules;
    var nodeOps = backend.nodeOps;

    for (i = 0; i < hooks.length; ++i) {
        cbs[hooks[i]] = [];
        for (j = 0; j < modules.length; ++j) {
            if (isDef(modules[j][hooks[i]])) {
                cbs[hooks[i]].push(modules[j][hooks[i]]);
            }
        }
    }

    function emptyNodeAt (elm) {
        return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
    }

    function createRmCb (childElm, listeners) {
        function remove$$1 () {
            if (--remove$$1.listeners === 0) {
                removeNode(childElm);
            }
        }
        remove$$1.listeners = listeners;
        return remove$$1
    }

    function removeNode (el) {
        var parent = nodeOps.parentNode(el);
        // element may have already been removed due to v-html / v-text
        if (isDef(parent)) {
            nodeOps.removeChild(parent, el);
        }
    }

    function isUnknownElement$$1 (vnode, inVPre) {
        return (
            !inVPre &&
            !vnode.ns &&
            !(
                config.ignoredElements.length &&
                config.ignoredElements.some(function (ignore) {
                    return isRegExp(ignore)
                        ? ignore.test(vnode.tag)
                        : ignore === vnode.tag
                })
            ) &&
            config.isUnknownElement(vnode.tag)
        )
    }

    var creatingElmInVPre = 0;

    function createElm (
        vnode,
        insertedVnodeQueue,
        parentElm,
        refElm,
        nested,
        ownerArray,
        index
    ) {
        if (isDef(vnode.elm) && isDef(ownerArray)) {
            // This vnode was used in a previous render!
            // now it's used as a new node, overwriting its elm would cause
            // potential patch errors down the road when it's used as an insertion
            // reference node. Instead, we clone the node on-demand before creating
            // associated DOM element for it.
            vnode = ownerArray[index] = cloneVNode(vnode);
        }

        vnode.isRootInsert = !nested; // for transition enter check
        if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
            return
        }

        var data = vnode.data;
        var children = vnode.children;
        var tag = vnode.tag;
        if (isDef(tag)) {
            {
                if (data && data.pre) {
                    creatingElmInVPre++;
                }
                if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
                    warn$1(
                        'Unknown custom element: <' + tag + '> - did you ' +
                        'register the component correctly? For recursive components, ' +
                        'make sure to provide the "name" option.',
                        vnode.context
                    );
                }
            }

            vnode.elm = vnode.ns
                ? nodeOps.createElementNS(vnode.ns, tag)
                : nodeOps.createElement(tag, vnode);
            setScope(vnode);

            /* istanbul ignore if */
            {
                createChildren(vnode, children, insertedVnodeQueue);
                if (isDef(data)) {
                    invokeCreateHooks(vnode, insertedVnodeQueue);
                }
                insert(parentElm, vnode.elm, refElm);
            }

            if (data && data.pre) {
                creatingElmInVPre--;
            }
        } else if (isTrue(vnode.isComment)) {
            vnode.elm = nodeOps.createComment(vnode.text);
            insert(parentElm, vnode.elm, refElm);
        } else {
            vnode.elm = nodeOps.createTextNode(vnode.text);
            insert(parentElm, vnode.elm, refElm);
        }
    }

    function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
        var i = vnode.data;
        if (isDef(i)) {
            var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
            if (isDef(i = i.hook) && isDef(i = i.init)) {
                i(vnode, false /* hydrating */);
            }
            // after calling the init hook, if the vnode is a child component
            // it should've created a child instance and mounted it. the child
            // component also has set the placeholder vnode's elm.
            // in that case we can just return the element and be done.
            if (isDef(vnode.componentInstance)) {
                initComponent(vnode, insertedVnodeQueue);
                insert(parentElm, vnode.elm, refElm);
                if (isTrue(isReactivated)) {
                    reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
                }
                return true
            }
        }
    }

    function initComponent (vnode, insertedVnodeQueue) {
        if (isDef(vnode.data.pendingInsert)) {
            insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
            vnode.data.pendingInsert = null;
        }
        vnode.elm = vnode.componentInstance.$el;
        if (isPatchable(vnode)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
            setScope(vnode);
        } else {
            // empty component root.
            // skip all element-related modules except for ref (#3455)
            registerRef(vnode);
            // make sure to invoke the insert hook
            insertedVnodeQueue.push(vnode);
        }
    }

    function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
        var i;
        // hack for #4339: a reactivated component with inner transition
        // does not trigger because the inner node's created hooks are not called
        // again. It's not ideal to involve module-specific logic in here but
        // there doesn't seem to be a better way to do it.
        var innerNode = vnode;
        while (innerNode.componentInstance) {
            innerNode = innerNode.componentInstance._vnode;
            if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
                for (i = 0; i < cbs.activate.length; ++i) {
                    cbs.activate[i](emptyNode, innerNode);
                }
                insertedVnodeQueue.push(innerNode);
                break
            }
        }
        // unlike a newly created component,
        // a reactivated keep-alive component doesn't insert itself
        insert(parentElm, vnode.elm, refElm);
    }

    function insert (parent, elm, ref$$1) {
        if (isDef(parent)) {
            if (isDef(ref$$1)) {
                if (nodeOps.parentNode(ref$$1) === parent) {
                    nodeOps.insertBefore(parent, elm, ref$$1);
                }
            } else {
                nodeOps.appendChild(parent, elm);
            }
        }
    }

    function createChildren (vnode, children, insertedVnodeQueue) {
        if (Array.isArray(children)) {
            {
                checkDuplicateKeys(children);
            }
            for (var i = 0; i < children.length; ++i) {
                createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
            }
        } else if (isPrimitive(vnode.text)) {
            nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
        }
    }

    function isPatchable (vnode) {
        while (vnode.componentInstance) {
            vnode = vnode.componentInstance._vnode;
        }
        return isDef(vnode.tag)
    }

    function invokeCreateHooks (vnode, insertedVnodeQueue) {
        for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
            cbs.create[i$1](emptyNode, vnode);
        }
        i = vnode.data.hook; // Reuse variable
        if (isDef(i)) {
            if (isDef(i.create)) { i.create(emptyNode, vnode); }
            if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }
        }
    }

    // set scope id attribute for scoped CSS.
    // this is implemented as a special case to avoid the overhead
    // of going through the normal attribute patching process.
    function setScope (vnode) {
        var i;
        if (isDef(i = vnode.fnScopeId)) {
            nodeOps.setStyleScope(vnode.elm, i);
        } else {
            var ancestor = vnode;
            while (ancestor) {
                if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
                    nodeOps.setStyleScope(vnode.elm, i);
                }
                ancestor = ancestor.parent;
            }
        }
        // for slot content they should also get the scopeId from the host instance.
        if (isDef(i = activeInstance) &&
            i !== vnode.context &&
            i !== vnode.fnContext &&
            isDef(i = i.$options._scopeId)
        ) {
            nodeOps.setStyleScope(vnode.elm, i);
        }
    }

    function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
        for (; startIdx <= endIdx; ++startIdx) {
            createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
        }
    }

    function invokeDestroyHook (vnode) {
        var i, j;
        var data = vnode.data;
        if (isDef(data)) {
            if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
            for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
        }
        if (isDef(i = vnode.children)) {
            for (j = 0; j < vnode.children.length; ++j) {
                invokeDestroyHook(vnode.children[j]);
            }
        }
    }

    function removeVnodes (vnodes, startIdx, endIdx) {
        for (; startIdx <= endIdx; ++startIdx) {
            var ch = vnodes[startIdx];
            if (isDef(ch)) {
                if (isDef(ch.tag)) {
                    removeAndInvokeRemoveHook(ch);
                    invokeDestroyHook(ch);
                } else { // Text node
                    removeNode(ch.elm);
                }
            }
        }
    }

    function removeAndInvokeRemoveHook (vnode, rm) {
        if (isDef(rm) || isDef(vnode.data)) {
            var i;
            var listeners = cbs.remove.length + 1;
            if (isDef(rm)) {
                // we have a recursively passed down rm callback
                // increase the listeners count
                rm.listeners += listeners;
            } else {
                // directly removing
                rm = createRmCb(vnode.elm, listeners);
            }
            // recursively invoke hooks on child component root node
            if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
                removeAndInvokeRemoveHook(i, rm);
            }
            for (i = 0; i < cbs.remove.length; ++i) {
                cbs.remove[i](vnode, rm);
            }
            if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
                i(vnode, rm);
            } else {
                rm();
            }
        } else {
            removeNode(vnode.elm);
        }
    }

    function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
        var oldStartIdx = 0;
        var newStartIdx = 0;
        var oldEndIdx = oldCh.length - 1;
        var oldStartVnode = oldCh[0];
        var oldEndVnode = oldCh[oldEndIdx];
        var newEndIdx = newCh.length - 1;
        var newStartVnode = newCh[0];
        var newEndVnode = newCh[newEndIdx];
        var oldKeyToIdx, idxInOld, vnodeToMove, refElm;

        // removeOnly is a special flag used only by <transition-group>
        // to ensure removed elements stay in correct relative positions
        // during leaving transitions
        var canMove = !removeOnly;

        {
            checkDuplicateKeys(newCh);
        }

        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
            if (isUndef(oldStartVnode)) {
                oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
            } else if (isUndef(oldEndVnode)) {
                oldEndVnode = oldCh[--oldEndIdx];
            } else if (sameVnode(oldStartVnode, newStartVnode)) {
                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
                oldStartVnode = oldCh[++oldStartIdx];
                newStartVnode = newCh[++newStartIdx];
            } else if (sameVnode(oldEndVnode, newEndVnode)) {
                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
                oldEndVnode = oldCh[--oldEndIdx];
                newEndVnode = newCh[--newEndIdx];
            } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
                canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
                oldStartVnode = oldCh[++oldStartIdx];
                newEndVnode = newCh[--newEndIdx];
            } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
                canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
                oldEndVnode = oldCh[--oldEndIdx];
                newStartVnode = newCh[++newStartIdx];
            } else {
                if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
                idxInOld = isDef(newStartVnode.key)
                    ? oldKeyToIdx[newStartVnode.key]
                    : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
                if (isUndef(idxInOld)) { // New element
                    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
                } else {
                    vnodeToMove = oldCh[idxInOld];
                    if (sameVnode(vnodeToMove, newStartVnode)) {
                        patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
                        oldCh[idxInOld] = undefined;
                        canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
                    } else {
                        // same key but different element. treat as new element
                        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
                    }
                }
                newStartVnode = newCh[++newStartIdx];
            }
        }
        if (oldStartIdx > oldEndIdx) {
            refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
            addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
        } else if (newStartIdx > newEndIdx) {
            removeVnodes(oldCh, oldStartIdx, oldEndIdx);
        }
    }

    function checkDuplicateKeys (children) {
        var seenKeys = {};
        for (var i = 0; i < children.length; i++) {
            var vnode = children[i];
            var key = vnode.key;
            if (isDef(key)) {
                if (seenKeys[key]) {
                    warn$1(
                        ("Duplicate keys detected: '" + key + "'. This may cause an update error."),
                        vnode.context
                    );
                } else {
                    seenKeys[key] = true;
                }
            }
        }
    }

    function findIdxInOld (node, oldCh, start, end) {
        for (var i = start; i < end; i++) {
            var c = oldCh[i];
            if (isDef(c) && sameVnode(node, c)) { return i }
        }
    }

    function patchVnode (
        oldVnode,
        vnode,
        insertedVnodeQueue,
        ownerArray,
        index,
        removeOnly
    ) {
        if (oldVnode === vnode) {
            return
        }

        if (isDef(vnode.elm) && isDef(ownerArray)) {
            // clone reused vnode
            vnode = ownerArray[index] = cloneVNode(vnode);
        }

        var elm = vnode.elm = oldVnode.elm;

        if (isTrue(oldVnode.isAsyncPlaceholder)) {
            if (isDef(vnode.asyncFactory.resolved)) {
                hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
            } else {
                vnode.isAsyncPlaceholder = true;
            }
            return
        }

        // reuse element for static trees.
        // note we only do this if the vnode is cloned -
        // if the new node is not cloned it means the render functions have been
        // reset by the hot-reload-api and we need to do a proper re-render.
        if (isTrue(vnode.isStatic) &&
            isTrue(oldVnode.isStatic) &&
            vnode.key === oldVnode.key &&
            (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
        ) {
            vnode.componentInstance = oldVnode.componentInstance;
            return
        }

        var i;
        var data = vnode.data;
        if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
            i(oldVnode, vnode);
        }

        var oldCh = oldVnode.children;
        var ch = vnode.children;
        if (isDef(data) && isPatchable(vnode)) {
            for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
            if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
        }
        if (isUndef(vnode.text)) {
            if (isDef(oldCh) && isDef(ch)) {
                if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
            } else if (isDef(ch)) {
                {
                    checkDuplicateKeys(ch);
                }
                if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
            } else if (isDef(oldCh)) {
                removeVnodes(oldCh, 0, oldCh.length - 1);
            } else if (isDef(oldVnode.text)) {
                nodeOps.setTextContent(elm, '');
            }
        } else if (oldVnode.text !== vnode.text) {
            nodeOps.setTextContent(elm, vnode.text);
        }
        if (isDef(data)) {
            if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
        }
    }

    function invokeInsertHook (vnode, queue, initial) {
        // delay insert hooks for component root nodes, invoke them after the
        // element is really inserted
        if (isTrue(initial) && isDef(vnode.parent)) {
            vnode.parent.data.pendingInsert = queue;
        } else {
            for (var i = 0; i < queue.length; ++i) {
                queue[i].data.hook.insert(queue[i]);
            }
        }
    }

    var hydrationBailed = false;
    // list of modules that can skip create hook during hydration because they
    // are already rendered on the client or has no need for initialization
    // Note: style is excluded because it relies on initial clone for future
    // deep updates (#7063).
    var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');

    // Note: this is a browser-only function so we can assume elms are DOM nodes.
    function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {
        var i;
        var tag = vnode.tag;
        var data = vnode.data;
        var children = vnode.children;
        inVPre = inVPre || (data && data.pre);
        vnode.elm = elm;

        if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
            vnode.isAsyncPlaceholder = true;
            return true
        }
        // assert node match
        {
            if (!assertNodeMatch(elm, vnode, inVPre)) {
                return false
            }
        }
        if (isDef(data)) {
            if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
            if (isDef(i = vnode.componentInstance)) {
                // child component. it should have hydrated its own tree.
                initComponent(vnode, insertedVnodeQueue);
                return true
            }
        }
        if (isDef(tag)) {
            if (isDef(children)) {
                // empty element, allow client to pick up and populate children
                if (!elm.hasChildNodes()) {
                    createChildren(vnode, children, insertedVnodeQueue);
                } else {
                    // v-html and domProps: innerHTML
                    if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
                        if (i !== elm.innerHTML) {
                            /* istanbul ignore if */
                            if (typeof console !== 'undefined' &&
                                !hydrationBailed
                            ) {
                                hydrationBailed = true;
                                console.warn('Parent: ', elm);
                                console.warn('server innerHTML: ', i);
                                console.warn('client innerHTML: ', elm.innerHTML);
                            }
                            return false
                        }
                    } else {
                        // iterate and compare children lists
                        var childrenMatch = true;
                        var childNode = elm.firstChild;
                        for (var i$1 = 0; i$1 < children.length; i$1++) {
                            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                                childrenMatch = false;
                                break
                            }
                            childNode = childNode.nextSibling;
                        }
                        // if childNode is not null, it means the actual childNodes list is
                        // longer than the virtual children list.
                        if (!childrenMatch || childNode) {
                            /* istanbul ignore if */
                            if (typeof console !== 'undefined' &&
                                !hydrationBailed
                            ) {
                                hydrationBailed = true;
                                console.warn('Parent: ', elm);
                                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
                            }
                            return false
                        }
                    }
                }
            }
            if (isDef(data)) {
                var fullInvoke = false;
                for (var key in data) {
                    if (!isRenderedModule(key)) {
                        fullInvoke = true;
                        invokeCreateHooks(vnode, insertedVnodeQueue);
                        break
                    }
                }
                if (!fullInvoke && data['class']) {
                    // ensure collecting deps for deep class bindings for future updates
                    traverse(data['class']);
                }
            }
        } else if (elm.data !== vnode.text) {
            elm.data = vnode.text;
        }
        return true
    }

    function assertNodeMatch (node, vnode, inVPre) {
        if (isDef(vnode.tag)) {
            return vnode.tag.indexOf('vue-component') === 0 || (
                !isUnknownElement$$1(vnode, inVPre) &&
                vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())
            )
        } else {
            return node.nodeType === (vnode.isComment ? 8 : 3)
        }
    }

    return function patch (oldVnode, vnode, hydrating, removeOnly) {
        if (isUndef(vnode)) {
            if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }
            return
        }

        var isInitialPatch = false;
        var insertedVnodeQueue = [];

        if (isUndef(oldVnode)) {
            // empty mount (likely as component), create new root element
            isInitialPatch = true;
            createElm(vnode, insertedVnodeQueue);
        } else {
            var isRealElement = isDef(oldVnode.nodeType);
            if (!isRealElement && sameVnode(oldVnode, vnode)) {
                // patch existing root node
                patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
            } else {
                if (isRealElement) {
                    // mounting to a real element
                    // check if this is server-rendered content and if we can perform
                    // a successful hydration.
                    if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
                        oldVnode.removeAttribute(SSR_ATTR);
                        hydrating = true;
                    }
                    if (isTrue(hydrating)) {
                        if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
                            invokeInsertHook(vnode, insertedVnodeQueue, true);
                            return oldVnode
                        } else {
                            warn$1(
                                'The client-side rendered virtual DOM tree is not matching ' +
                                'server-rendered content. This is likely caused by incorrect ' +
                                'HTML markup, for example nesting block-level elements inside ' +
                                '<p>, or missing <tbody>. Bailing hydration and performing ' +
                                'full client-side render.'
                            );
                        }
                    }
                    // either not server-rendered, or hydration failed.
                    // create an empty node and replace it
                    oldVnode = emptyNodeAt(oldVnode);
                }

                // replacing existing element
                var oldElm = oldVnode.elm;
                var parentElm = nodeOps.parentNode(oldElm);

                // create new node
                createElm(
                    vnode,
                    insertedVnodeQueue,
                    // extremely rare edge case: do not insert if old element is in a
                    // leaving transition. Only happens when combining transition +
                    // keep-alive + HOCs. (#4590)
                    oldElm._leaveCb ? null : parentElm,
                    nodeOps.nextSibling(oldElm)
                );

                // update parent placeholder node element, recursively
                if (isDef(vnode.parent)) {
                    var ancestor = vnode.parent;
                    var patchable = isPatchable(vnode);
                    while (ancestor) {
                        for (var i = 0; i < cbs.destroy.length; ++i) {
                            cbs.destroy[i](ancestor);
                        }
                        ancestor.elm = vnode.elm;
                        if (patchable) {
                            for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                                cbs.create[i$1](emptyNode, ancestor);
                            }
                            // #6513
                            // invoke insert hooks that may have been merged by create hooks.
                            // e.g. for directives that uses the "inserted" hook.
                            var insert = ancestor.data.hook.insert;
                            if (insert.merged) {
                                // start at index 1 to avoid re-invoking component mounted hook
                                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                                    insert.fns[i$2]();
                                }
                            }
                        } else {
                            registerRef(ancestor);
                        }
                        ancestor = ancestor.parent;
                    }
                }

                // destroy old node
                if (isDef(parentElm)) {
                    removeVnodes([oldVnode], 0, 0);
                } else if (isDef(oldVnode.tag)) {
                    invokeDestroyHook(oldVnode);
                }
            }
        }

        invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
        return vnode.elm
    }
}

/*  */

var directives = {
    create: updateDirectives,
    update: updateDirectives,
    destroy: function unbindDirectives (vnode) {
        updateDirectives(vnode, emptyNode);
    }
};

function updateDirectives (oldVnode, vnode) {
    if (oldVnode.data.directives || vnode.data.directives) {
        _update(oldVnode, vnode);
    }
}

function _update (oldVnode, vnode) {
    var isCreate = oldVnode === emptyNode;
    var isDestroy = vnode === emptyNode;
    var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
    var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

    var dirsWithInsert = [];
    var dirsWithPostpatch = [];

    var key, oldDir, dir;
    for (key in newDirs) {
        oldDir = oldDirs[key];
        dir = newDirs[key];
        if (!oldDir) {
            // new directive, bind
            callHook$1(dir, 'bind', vnode, oldVnode);
            if (dir.def && dir.def.inserted) {
                dirsWithInsert.push(dir);
            }
        } else {
            // existing directive, update
            dir.oldValue = oldDir.value;
            dir.oldArg = oldDir.arg;
            callHook$1(dir, 'update', vnode, oldVnode);
            if (dir.def && dir.def.componentUpdated) {
                dirsWithPostpatch.push(dir);
            }
        }
    }

    if (dirsWithInsert.length) {
        var callInsert = function () {
            for (var i = 0; i < dirsWithInsert.length; i++) {
                callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
            }
        };
        if (isCreate) {
            mergeVNodeHook(vnode, 'insert', callInsert);
        } else {
            callInsert();
        }
    }

    if (dirsWithPostpatch.length) {
        mergeVNodeHook(vnode, 'postpatch', function () {
            for (var i = 0; i < dirsWithPostpatch.length; i++) {
                callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
            }
        });
    }

    if (!isCreate) {
        for (key in oldDirs) {
            if (!newDirs[key]) {
                // no longer present, unbind
                callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
            }
        }
    }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1 (
    dirs,
    vm
) {
    var res = Object.create(null);
    if (!dirs) {
        // $flow-disable-line
        return res
    }
    var i, dir;
    for (i = 0; i < dirs.length; i++) {
        dir = dirs[i];
        if (!dir.modifiers) {
            // $flow-disable-line
            dir.modifiers = emptyModifiers;
        }
        res[getRawDirName(dir)] = dir;
        dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
    }
    // $flow-disable-line
    return res
}

function getRawDirName (dir) {
    return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
}

function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {
    var fn = dir.def && dir.def[hook];
    if (fn) {
        try {
            fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
        } catch (e) {
            handleError(e, vnode.context, ("directive " + (dir.name) + " " + hook + " hook"));
        }
    }
}

var baseModules = [
    ref,
    directives
];

/*  */

function updateAttrs (oldVnode, vnode) {
    var opts = vnode.componentOptions;
    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
        return
    }
    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
        return
    }
    var key, cur, old;
    var elm = vnode.elm;
    var oldAttrs = oldVnode.data.attrs || {};
    var attrs = vnode.data.attrs || {};
    // clone observed objects, as the user probably wants to mutate it
    if (isDef(attrs.__ob__)) {
        attrs = vnode.data.attrs = extend$1({}, attrs);
    }

    for (key in attrs) {
        cur = attrs[key];
        old = oldAttrs[key];
        if (old !== cur) {
            setAttr$1(elm, key, cur);
        }
    }
    // #4391: in IE9, setting type can reset value for input[type=radio]
    // #6666: IE/Edge forces progress value down to 1 before setting a max
    /* istanbul ignore if */
    if ((isIE$1 || isEdge) && attrs.value !== oldAttrs.value) {
        setAttr$1(elm, 'value', attrs.value);
    }
    for (key in oldAttrs) {
        if (isUndef(attrs[key])) {
            if (isXlink(key)) {
                elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
            } else if (!isEnumeratedAttr(key)) {
                elm.removeAttribute(key);
            }
        }
    }
}

function setAttr$1 (el, key, value) {
    if (el.tagName.indexOf('-') > -1) {
        baseSetAttr(el, key, value);
    } else if (isBooleanAttr(key)) {
        // set attribute for blank value
        // e.g. <option disabled>Select one</option>
        if (isFalsyAttrValue(value)) {
            el.removeAttribute(key);
        } else {
            // technically allowfullscreen is a boolean attribute for <iframe>,
            // but Flash expects a value of "true" when used on <embed> tag
            value = key === 'allowfullscreen' && el.tagName === 'EMBED'
                ? 'true'
                : key;
            el.setAttribute(key, value);
        }
    } else if (isEnumeratedAttr(key)) {
        el.setAttribute(key, convertEnumeratedValue(key, value));
    } else if (isXlink(key)) {
        if (isFalsyAttrValue(value)) {
            el.removeAttributeNS(xlinkNS, getXlinkProp(key));
        } else {
            el.setAttributeNS(xlinkNS, key, value);
        }
    } else {
        baseSetAttr(el, key, value);
    }
}

function baseSetAttr (el, key, value) {
    if (isFalsyAttrValue(value)) {
        el.removeAttribute(key);
    } else {
        // #7138: IE10 & 11 fires input event when setting placeholder on
        // <textarea>... block the first input event and remove the blocker
        // immediately.
        /* istanbul ignore if */
        if (
            isIE$1 && !isIE9 &&
            el.tagName === 'TEXTAREA' &&
            key === 'placeholder' && value !== '' && !el.__ieph
        ) {
            var blocker = function (e) {
                e.stopImmediatePropagation();
                el.removeEventListener('input', blocker);
            };
            el.addEventListener('input', blocker);
            // $flow-disable-line
            el.__ieph = true; /* IE placeholder patched */
        }
        el.setAttribute(key, value);
    }
}

var attrs = {
    create: updateAttrs,
    update: updateAttrs
};

/*  */

function updateClass (oldVnode, vnode) {
    var el = vnode.elm;
    var data = vnode.data;
    var oldData = oldVnode.data;
    if (
        isUndef(data.staticClass) &&
        isUndef(data.class) && (
            isUndef(oldData) || (
                isUndef(oldData.staticClass) &&
                isUndef(oldData.class)
            )
        )
    ) {
        return
    }

    var cls = genClassForVnode(vnode);

    // handle transition classes
    var transitionClass = el._transitionClasses;
    if (isDef(transitionClass)) {
        cls = concat$1(cls, stringifyClass(transitionClass));
    }

    // set the class
    if (cls !== el._prevClass) {
        el.setAttribute('class', cls);
        el._prevClass = cls;
    }
}

var klass = {
    create: updateClass,
    update: updateClass
};

/*  */

/*  */

/*  */

/*  */

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents (on) {
    /* istanbul ignore if */
    if (isDef(on[RANGE_TOKEN])) {
        // IE input[type=range] only supports `change` event
        var event = isIE$1 ? 'change' : 'input';
        on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
        delete on[RANGE_TOKEN];
    }
    // This was originally intended to fix #4521 but no longer necessary
    // after 2.5. Keeping it for backwards compat with generated code from < 2.4
    /* istanbul ignore if */
    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
        on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
        delete on[CHECKBOX_RADIO_TOKEN];
    }
}

var target$1$1;

function createOnceHandler$1 (event, handler, capture) {
    var _target = target$1$1; // save current target element in closure
    return function onceHandler () {
        var res = handler.apply(null, arguments);
        if (res !== null) {
            remove$2(event, onceHandler, capture, _target);
        }
    }
}

// #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
// implementation and does not fire microtasks in between event propagation, so
// safe to exclude.
var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);

function add$1 (
    name,
    handler,
    capture,
    passive
) {
    // async edge case #6566: inner click event triggers patch, event handler
    // attached to outer element during patch, and triggered again. This
    // happens because browsers fire microtask ticks between event propagation.
    // the solution is simple: we save the timestamp when a handler is attached,
    // and the handler would only fire if the event passed to it was fired
    // AFTER it was attached.
    if (useMicrotaskFix) {
        var attachedTimestamp = currentFlushTimestamp;
        var original = handler;
        handler = original._wrapper = function (e) {
            if (
                // no bubbling, should always fire.
                // this is just a safety net in case event.timeStamp is unreliable in
                // certain weird environments...
                e.target === e.currentTarget ||
                // event is fired after handler attachment
                e.timeStamp >= attachedTimestamp ||
                // bail for environments that have buggy event.timeStamp implementations
                // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState
                // #9681 QtWebEngine event.timeStamp is negative value
                e.timeStamp <= 0 ||
                // #9448 bail if event is fired in another document in a multi-page
                // electron/nw.js app, since event.timeStamp will be using a different
                // starting reference
                e.target.ownerDocument !== document
            ) {
                return original.apply(this, arguments)
            }
        };
    }
    target$1$1.addEventListener(
        name,
        handler,
        supportsPassive
            ? { capture: capture, passive: passive }
            : capture
    );
}

function remove$2 (
    name,
    handler,
    capture,
    _target
) {
    (_target || target$1$1).removeEventListener(
        name,
        handler._wrapper || handler,
        capture
    );
}

function updateDOMListeners (oldVnode, vnode) {
    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
        return
    }
    var on = vnode.data.on || {};
    var oldOn = oldVnode.data.on || {};
    target$1$1 = vnode.elm;
    normalizeEvents(on);
    updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
    target$1$1 = undefined;
}

var events = {
    create: updateDOMListeners,
    update: updateDOMListeners
};

/*  */

var svgContainer;

function updateDOMProps (oldVnode, vnode) {
    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
        return
    }
    var key, cur;
    var elm = vnode.elm;
    var oldProps = oldVnode.data.domProps || {};
    var props = vnode.data.domProps || {};
    // clone observed objects, as the user probably wants to mutate it
    if (isDef(props.__ob__)) {
        props = vnode.data.domProps = extend$1({}, props);
    }

    for (key in oldProps) {
        if (!(key in props)) {
            elm[key] = '';
        }
    }

    for (key in props) {
        cur = props[key];
        // ignore children if the node has textContent or innerHTML,
        // as these will throw away existing DOM nodes and cause removal errors
        // on subsequent patches (#3360)
        if (key === 'textContent' || key === 'innerHTML') {
            if (vnode.children) { vnode.children.length = 0; }
            if (cur === oldProps[key]) { continue }
            // #6601 work around Chrome version <= 55 bug where single textNode
            // replaced by innerHTML/textContent retains its parentNode property
            if (elm.childNodes.length === 1) {
                elm.removeChild(elm.childNodes[0]);
            }
        }

        if (key === 'value' && elm.tagName !== 'PROGRESS') {
            // store value as _value as well since
            // non-string values will be stringified
            elm._value = cur;
            // avoid resetting cursor position when value is the same
            var strCur = isUndef(cur) ? '' : String(cur);
            if (shouldUpdateValue(elm, strCur)) {
                elm.value = strCur;
            }
        } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
            // IE doesn't support innerHTML for SVG elements
            svgContainer = svgContainer || document.createElement('div');
            svgContainer.innerHTML = "<svg>" + cur + "</svg>";
            var svg = svgContainer.firstChild;
            while (elm.firstChild) {
                elm.removeChild(elm.firstChild);
            }
            while (svg.firstChild) {
                elm.appendChild(svg.firstChild);
            }
        } else if (
            // skip the update if old and new VDOM state is the same.
            // `value` is handled separately because the DOM value may be temporarily
            // out of sync with VDOM state due to focus, composition and modifiers.
            // This  #4521 by skipping the unnecessary `checked` update.
            cur !== oldProps[key]
        ) {
            // some property updates can throw
            // e.g. `value` on <progress> w/ non-finite value
            try {
                elm[key] = cur;
            } catch (e) {}
        }
    }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue (elm, checkVal) {
    return (!elm.composing && (
        elm.tagName === 'OPTION' ||
        isNotInFocusAndDirty(elm, checkVal) ||
        isDirtyWithModifiers(elm, checkVal)
    ))
}

function isNotInFocusAndDirty (elm, checkVal) {
    // return true when textbox (.number and .trim) loses focus and its value is
    // not equal to the updated value
    var notInFocus = true;
    // #6157
    // work around IE bug when accessing document.activeElement in an iframe
    try { notInFocus = document.activeElement !== elm; } catch (e) {}
    return notInFocus && elm.value !== checkVal
}

function isDirtyWithModifiers (elm, newVal) {
    var value = elm.value;
    var modifiers = elm._vModifiers; // injected by v-model runtime
    if (isDef(modifiers)) {
        if (modifiers.number) {
            return toNumber(value) !== toNumber(newVal)
        }
        if (modifiers.trim) {
            return value.trim() !== newVal.trim()
        }
    }
    return value !== newVal
}

var domProps = {
    create: updateDOMProps,
    update: updateDOMProps
};

/*  */

var parseStyleText = cached(function (cssText) {
    var res = {};
    var listDelimiter = /;(?![^(]*\))/g;
    var propertyDelimiter = /:(.+)/;
    cssText.split(listDelimiter).forEach(function (item) {
        if (item) {
            var tmp = item.split(propertyDelimiter);
            tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
        }
    });
    return res
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData (data) {
    var style = normalizeStyleBinding(data.style);
    // static style is pre-processed into an object during compilation
    // and is always a fresh object, so it's safe to merge into it
    return data.staticStyle
        ? extend$1(data.staticStyle, style)
        : style
}

// normalize possible array / string values into Object
function normalizeStyleBinding (bindingStyle) {
    if (Array.isArray(bindingStyle)) {
        return toObject(bindingStyle)
    }
    if (typeof bindingStyle === 'string') {
        return parseStyleText(bindingStyle)
    }
    return bindingStyle
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle$1 (vnode, checkChild) {
    var res = {};
    var styleData;

    if (checkChild) {
        var childNode = vnode;
        while (childNode.componentInstance) {
            childNode = childNode.componentInstance._vnode;
            if (
                childNode && childNode.data &&
                (styleData = normalizeStyleData(childNode.data))
            ) {
                extend$1(res, styleData);
            }
        }
    }

    if ((styleData = normalizeStyleData(vnode.data))) {
        extend$1(res, styleData);
    }

    var parentNode = vnode;
    while ((parentNode = parentNode.parent)) {
        if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
            extend$1(res, styleData);
        }
    }
    return res
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function (el, name, val) {
    /* istanbul ignore if */
    if (cssVarRE.test(name)) {
        el.style.setProperty(name, val);
    } else if (importantRE.test(val)) {
        el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
    } else {
        var normalizedName = normalize(name);
        if (Array.isArray(val)) {
            // Support values array created by autoprefixer, e.g.
            // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
            // Set them one by one, and the browser will only set those it can recognize
            for (var i = 0, len = val.length; i < len; i++) {
                el.style[normalizedName] = val[i];
            }
        } else {
            el.style[normalizedName] = val;
        }
    }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];

var emptyStyle;
var normalize = cached(function (prop) {
    emptyStyle = emptyStyle || document.createElement('div').style;
    prop = camelize(prop);
    if (prop !== 'filter' && (prop in emptyStyle)) {
        return prop
    }
    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
    for (var i = 0; i < vendorNames.length; i++) {
        var name = vendorNames[i] + capName;
        if (name in emptyStyle) {
            return name
        }
    }
});

function updateStyle (oldVnode, vnode) {
    var data = vnode.data;
    var oldData = oldVnode.data;

    if (isUndef(data.staticStyle) && isUndef(data.style) &&
        isUndef(oldData.staticStyle) && isUndef(oldData.style)
    ) {
        return
    }

    var cur, name;
    var el = vnode.elm;
    var oldStaticStyle = oldData.staticStyle;
    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

    // if static style exists, stylebinding already merged into it when doing normalizeStyleData
    var oldStyle = oldStaticStyle || oldStyleBinding;

    var style = normalizeStyleBinding(vnode.data.style) || {};

    // store normalized style under a different key for next diff
    // make sure to clone it if it's reactive, since the user likely wants
    // to mutate it.
    vnode.data.normalizedStyle = isDef(style.__ob__)
        ? extend$1({}, style)
        : style;

    var newStyle = getStyle$1(vnode, true);

    for (name in oldStyle) {
        if (isUndef(newStyle[name])) {
            setProp(el, name, '');
        }
    }
    for (name in newStyle) {
        cur = newStyle[name];
        if (cur !== oldStyle[name]) {
            // ie9 setting to null has no effect, must use empty string
            setProp(el, name, cur == null ? '' : cur);
        }
    }
}

var style = {
    create: updateStyle,
    update: updateStyle
};

/*  */

var whitespaceRE = /\s+/;

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass$1 (el, cls) {
    /* istanbul ignore if */
    if (!cls || !(cls = cls.trim())) {
        return
    }

    /* istanbul ignore else */
    if (el.classList) {
        if (cls.indexOf(' ') > -1) {
            cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });
        } else {
            el.classList.add(cls);
        }
    } else {
        var cur = " " + (el.getAttribute('class') || '') + " ";
        if (cur.indexOf(' ' + cls + ' ') < 0) {
            el.setAttribute('class', (cur + cls).trim());
        }
    }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass$1 (el, cls) {
    /* istanbul ignore if */
    if (!cls || !(cls = cls.trim())) {
        return
    }

    /* istanbul ignore else */
    if (el.classList) {
        if (cls.indexOf(' ') > -1) {
            cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });
        } else {
            el.classList.remove(cls);
        }
        if (!el.classList.length) {
            el.removeAttribute('class');
        }
    } else {
        var cur = " " + (el.getAttribute('class') || '') + " ";
        var tar = ' ' + cls + ' ';
        while (cur.indexOf(tar) >= 0) {
            cur = cur.replace(tar, ' ');
        }
        cur = cur.trim();
        if (cur) {
            el.setAttribute('class', cur);
        } else {
            el.removeAttribute('class');
        }
    }
}

/*  */

function resolveTransition (def$$1) {
    if (!def$$1) {
        return
    }
    /* istanbul ignore else */
    if (typeof def$$1 === 'object') {
        var res = {};
        if (def$$1.css !== false) {
            extend$1(res, autoCssTransition(def$$1.name || 'v'));
        }
        extend$1(res, def$$1);
        return res
    } else if (typeof def$$1 === 'string') {
        return autoCssTransition(def$$1)
    }
}

var autoCssTransition = cached(function (name) {
    return {
        enterClass: (name + "-enter"),
        enterToClass: (name + "-enter-to"),
        enterActiveClass: (name + "-enter-active"),
        leaveClass: (name + "-leave"),
        leaveToClass: (name + "-leave-to"),
        leaveActiveClass: (name + "-leave-active")
    }
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
    /* istanbul ignore if */
    if (window.ontransitionend === undefined &&
        window.onwebkittransitionend !== undefined
    ) {
        transitionProp = 'WebkitTransition';
        transitionEndEvent = 'webkitTransitionEnd';
    }
    if (window.onanimationend === undefined &&
        window.onwebkitanimationend !== undefined
    ) {
        animationProp = 'WebkitAnimation';
        animationEndEvent = 'webkitAnimationEnd';
    }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser
    ? window.requestAnimationFrame
        ? window.requestAnimationFrame.bind(window)
        : setTimeout
    : /* istanbul ignore next */ function (fn) { return fn(); };

function nextFrame (fn) {
    raf(function () {
        raf(fn);
    });
}

function addTransitionClass (el, cls) {
    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
    if (transitionClasses.indexOf(cls) < 0) {
        transitionClasses.push(cls);
        addClass$1(el, cls);
    }
}

function removeTransitionClass (el, cls) {
    if (el._transitionClasses) {
        remove(el._transitionClasses, cls);
    }
    removeClass$1(el, cls);
}

function whenTransitionEnds (
    el,
    expectedType,
    cb
) {
    var ref = getTransitionInfo(el, expectedType);
    var type = ref.type;
    var timeout = ref.timeout;
    var propCount = ref.propCount;
    if (!type) { return cb() }
    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
    var ended = 0;
    var end = function () {
        el.removeEventListener(event, onEnd);
        cb();
    };
    var onEnd = function (e) {
        if (e.target === el) {
            if (++ended >= propCount) {
                end();
            }
        }
    };
    setTimeout(function () {
        if (ended < propCount) {
            end();
        }
    }, timeout + 1);
    el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo (el, expectedType) {
    var styles = window.getComputedStyle(el);
    // JSDOM may return undefined for transition properties
    var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
    var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
    var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
    var animationTimeout = getTimeout(animationDelays, animationDurations);

    var type;
    var timeout = 0;
    var propCount = 0;
    /* istanbul ignore if */
    if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
            type = TRANSITION;
            timeout = transitionTimeout;
            propCount = transitionDurations.length;
        }
    } else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
            type = ANIMATION;
            timeout = animationTimeout;
            propCount = animationDurations.length;
        }
    } else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type = timeout > 0
            ? transitionTimeout > animationTimeout
                ? TRANSITION
                : ANIMATION
            : null;
        propCount = type
            ? type === TRANSITION
                ? transitionDurations.length
                : animationDurations.length
            : 0;
    }
    var hasTransform =
        type === TRANSITION &&
        transformRE.test(styles[transitionProp + 'Property']);
    return {
        type: type,
        timeout: timeout,
        propCount: propCount,
        hasTransform: hasTransform
    }
}

function getTimeout (delays, durations) {
    /* istanbul ignore next */
    while (delays.length < durations.length) {
        delays = delays.concat(delays);
    }

    return Math.max.apply(null, durations.map(function (d, i) {
        return toMs(d) + toMs(delays[i])
    }))
}

// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
// in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down (i.e. acting
// as a floor function) causing unexpected behaviors
function toMs (s) {
    return Number(s.slice(0, -1).replace(',', '.')) * 1000
}

/*  */

function enter (vnode, toggleDisplay) {
    var el = vnode.elm;

    // call leave callback now
    if (isDef(el._leaveCb)) {
        el._leaveCb.cancelled = true;
        el._leaveCb();
    }

    var data = resolveTransition(vnode.data.transition);
    if (isUndef(data)) {
        return
    }

    /* istanbul ignore if */
    if (isDef(el._enterCb) || el.nodeType !== 1) {
        return
    }

    var css = data.css;
    var type = data.type;
    var enterClass = data.enterClass;
    var enterToClass = data.enterToClass;
    var enterActiveClass = data.enterActiveClass;
    var appearClass = data.appearClass;
    var appearToClass = data.appearToClass;
    var appearActiveClass = data.appearActiveClass;
    var beforeEnter = data.beforeEnter;
    var enter = data.enter;
    var afterEnter = data.afterEnter;
    var enterCancelled = data.enterCancelled;
    var beforeAppear = data.beforeAppear;
    var appear = data.appear;
    var afterAppear = data.afterAppear;
    var appearCancelled = data.appearCancelled;
    var duration = data.duration;

    // activeInstance will always be the <transition> component managing this
    // transition. One edge case to check is when the <transition> is placed
    // as the root node of a child component. In that case we need to check
    // <transition>'s parent for appear check.
    var context = activeInstance;
    var transitionNode = activeInstance.$vnode;
    while (transitionNode && transitionNode.parent) {
        context = transitionNode.context;
        transitionNode = transitionNode.parent;
    }

    var isAppear = !context._isMounted || !vnode.isRootInsert;

    if (isAppear && !appear && appear !== '') {
        return
    }

    var startClass = isAppear && appearClass
        ? appearClass
        : enterClass;
    var activeClass = isAppear && appearActiveClass
        ? appearActiveClass
        : enterActiveClass;
    var toClass = isAppear && appearToClass
        ? appearToClass
        : enterToClass;

    var beforeEnterHook = isAppear
        ? (beforeAppear || beforeEnter)
        : beforeEnter;
    var enterHook = isAppear
        ? (typeof appear === 'function' ? appear : enter)
        : enter;
    var afterEnterHook = isAppear
        ? (afterAppear || afterEnter)
        : afterEnter;
    var enterCancelledHook = isAppear
        ? (appearCancelled || enterCancelled)
        : enterCancelled;

    var explicitEnterDuration = toNumber(
        isObject$4(duration)
            ? duration.enter
            : duration
    );

    if (explicitEnterDuration != null) {
        checkDuration(explicitEnterDuration, 'enter', vnode);
    }

    var expectsCSS = css !== false && !isIE9;
    var userWantsControl = getHookArgumentsLength(enterHook);

    var cb = el._enterCb = once(function () {
        if (expectsCSS) {
            removeTransitionClass(el, toClass);
            removeTransitionClass(el, activeClass);
        }
        if (cb.cancelled) {
            if (expectsCSS) {
                removeTransitionClass(el, startClass);
            }
            enterCancelledHook && enterCancelledHook(el);
        } else {
            afterEnterHook && afterEnterHook(el);
        }
        el._enterCb = null;
    });

    if (!vnode.data.show) {
        // remove pending leave element on enter by injecting an insert hook
        mergeVNodeHook(vnode, 'insert', function () {
            var parent = el.parentNode;
            var pendingNode = parent && parent._pending && parent._pending[vnode.key];
            if (pendingNode &&
                pendingNode.tag === vnode.tag &&
                pendingNode.elm._leaveCb
            ) {
                pendingNode.elm._leaveCb();
            }
            enterHook && enterHook(el, cb);
        });
    }

    // start enter transition
    beforeEnterHook && beforeEnterHook(el);
    if (expectsCSS) {
        addTransitionClass(el, startClass);
        addTransitionClass(el, activeClass);
        nextFrame(function () {
            removeTransitionClass(el, startClass);
            if (!cb.cancelled) {
                addTransitionClass(el, toClass);
                if (!userWantsControl) {
                    if (isValidDuration(explicitEnterDuration)) {
                        setTimeout(cb, explicitEnterDuration);
                    } else {
                        whenTransitionEnds(el, type, cb);
                    }
                }
            }
        });
    }

    if (vnode.data.show) {
        toggleDisplay && toggleDisplay();
        enterHook && enterHook(el, cb);
    }

    if (!expectsCSS && !userWantsControl) {
        cb();
    }
}

function leave (vnode, rm) {
    var el = vnode.elm;

    // call enter callback now
    if (isDef(el._enterCb)) {
        el._enterCb.cancelled = true;
        el._enterCb();
    }

    var data = resolveTransition(vnode.data.transition);
    if (isUndef(data) || el.nodeType !== 1) {
        return rm()
    }

    /* istanbul ignore if */
    if (isDef(el._leaveCb)) {
        return
    }

    var css = data.css;
    var type = data.type;
    var leaveClass = data.leaveClass;
    var leaveToClass = data.leaveToClass;
    var leaveActiveClass = data.leaveActiveClass;
    var beforeLeave = data.beforeLeave;
    var leave = data.leave;
    var afterLeave = data.afterLeave;
    var leaveCancelled = data.leaveCancelled;
    var delayLeave = data.delayLeave;
    var duration = data.duration;

    var expectsCSS = css !== false && !isIE9;
    var userWantsControl = getHookArgumentsLength(leave);

    var explicitLeaveDuration = toNumber(
        isObject$4(duration)
            ? duration.leave
            : duration
    );

    if (isDef(explicitLeaveDuration)) {
        checkDuration(explicitLeaveDuration, 'leave', vnode);
    }

    var cb = el._leaveCb = once(function () {
        if (el.parentNode && el.parentNode._pending) {
            el.parentNode._pending[vnode.key] = null;
        }
        if (expectsCSS) {
            removeTransitionClass(el, leaveToClass);
            removeTransitionClass(el, leaveActiveClass);
        }
        if (cb.cancelled) {
            if (expectsCSS) {
                removeTransitionClass(el, leaveClass);
            }
            leaveCancelled && leaveCancelled(el);
        } else {
            rm();
            afterLeave && afterLeave(el);
        }
        el._leaveCb = null;
    });

    if (delayLeave) {
        delayLeave(performLeave);
    } else {
        performLeave();
    }

    function performLeave () {
        // the delayed leave may have already been cancelled
        if (cb.cancelled) {
            return
        }
        // record leaving element
        if (!vnode.data.show && el.parentNode) {
            (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;
        }
        beforeLeave && beforeLeave(el);
        if (expectsCSS) {
            addTransitionClass(el, leaveClass);
            addTransitionClass(el, leaveActiveClass);
            nextFrame(function () {
                removeTransitionClass(el, leaveClass);
                if (!cb.cancelled) {
                    addTransitionClass(el, leaveToClass);
                    if (!userWantsControl) {
                        if (isValidDuration(explicitLeaveDuration)) {
                            setTimeout(cb, explicitLeaveDuration);
                        } else {
                            whenTransitionEnds(el, type, cb);
                        }
                    }
                }
            });
        }
        leave && leave(el, cb);
        if (!expectsCSS && !userWantsControl) {
            cb();
        }
    }
}

// only used in dev mode
function checkDuration (val, name, vnode) {
    if (typeof val !== 'number') {
        warn$1(
            "<transition> explicit " + name + " duration is not a valid number - " +
            "got " + (JSON.stringify(val)) + ".",
            vnode.context
        );
    } else if (isNaN(val)) {
        warn$1(
            "<transition> explicit " + name + " duration is NaN - " +
            'the duration expression might be incorrect.',
            vnode.context
        );
    }
}

function isValidDuration (val) {
    return typeof val === 'number' && !isNaN(val)
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength (fn) {
    if (isUndef(fn)) {
        return false
    }
    var invokerFns = fn.fns;
    if (isDef(invokerFns)) {
        // invoker
        return getHookArgumentsLength(
            Array.isArray(invokerFns)
                ? invokerFns[0]
                : invokerFns
        )
    } else {
        return (fn._length || fn.length) > 1
    }
}

function _enter (_, vnode) {
    if (vnode.data.show !== true) {
        enter(vnode);
    }
}

var transition = inBrowser ? {
    create: _enter,
    activate: _enter,
    remove: function remove$$1 (vnode, rm) {
        /* istanbul ignore else */
        if (vnode.data.show !== true) {
            leave(vnode, rm);
        } else {
            rm();
        }
    }
} : {};

var platformModules = [
    attrs,
    klass,
    events,
    domProps,
    style,
    transition
];

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */
if (isIE9) {
    // http://www.matts411.com/post/internet-explorer-9-oninput/
    document.addEventListener('selectionchange', function () {
        var el = document.activeElement;
        if (el && el.vmodel) {
            trigger(el, 'input');
        }
    });
}

var directive = {
    inserted: function inserted (el, binding, vnode, oldVnode) {
        if (vnode.tag === 'select') {
            // #6903
            if (oldVnode.elm && !oldVnode.elm._vOptions) {
                mergeVNodeHook(vnode, 'postpatch', function () {
                    directive.componentUpdated(el, binding, vnode);
                });
            } else {
                setSelected(el, binding, vnode.context);
            }
            el._vOptions = [].map.call(el.options, getValue);
        } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
            el._vModifiers = binding.modifiers;
            if (!binding.modifiers.lazy) {
                el.addEventListener('compositionstart', onCompositionStart);
                el.addEventListener('compositionend', onCompositionEnd);
                // Safari < 10.2 & UIWebView doesn't fire compositionend when
                // switching focus before confirming composition choice
                // this also fixes the issue where some browsers e.g. iOS Chrome
                // fires "change" instead of "input" on autocomplete.
                el.addEventListener('change', onCompositionEnd);
                /* istanbul ignore if */
                if (isIE9) {
                    el.vmodel = true;
                }
            }
        }
    },

    componentUpdated: function componentUpdated (el, binding, vnode) {
        if (vnode.tag === 'select') {
            setSelected(el, binding, vnode.context);
            // in case the options rendered by v-for have changed,
            // it's possible that the value is out-of-sync with the rendered options.
            // detect such cases and filter out values that no longer has a matching
            // option in the DOM.
            var prevOptions = el._vOptions;
            var curOptions = el._vOptions = [].map.call(el.options, getValue);
            if (curOptions.some(function (o, i) { return !looseEqual$1(o, prevOptions[i]); })) {
                // trigger change event if
                // no matching option found for at least one value
                var needReset = el.multiple
                    ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })
                    : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
                if (needReset) {
                    trigger(el, 'change');
                }
            }
        }
    }
};

function setSelected (el, binding, vm) {
    actuallySetSelected(el, binding, vm);
    /* istanbul ignore if */
    if (isIE$1 || isEdge) {
        setTimeout(function () {
            actuallySetSelected(el, binding, vm);
        }, 0);
    }
}

function actuallySetSelected (el, binding, vm) {
    var value = binding.value;
    var isMultiple = el.multiple;
    if (isMultiple && !Array.isArray(value)) {
        warn$1(
            "<select multiple v-model=\"" + (binding.expression) + "\"> " +
            "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
            vm
        );
        return
    }
    var selected, option;
    for (var i = 0, l = el.options.length; i < l; i++) {
        option = el.options[i];
        if (isMultiple) {
            selected = looseIndexOf(value, getValue(option)) > -1;
            if (option.selected !== selected) {
                option.selected = selected;
            }
        } else {
            if (looseEqual$1(getValue(option), value)) {
                if (el.selectedIndex !== i) {
                    el.selectedIndex = i;
                }
                return
            }
        }
    }
    if (!isMultiple) {
        el.selectedIndex = -1;
    }
}

function hasNoMatchingOption (value, options) {
    return options.every(function (o) { return !looseEqual$1(o, value); })
}

function getValue (option) {
    return '_value' in option
        ? option._value
        : option.value
}

function onCompositionStart (e) {
    e.target.composing = true;
}

function onCompositionEnd (e) {
    // prevent triggering an input event for no reason
    if (!e.target.composing) { return }
    e.target.composing = false;
    trigger(e.target, 'input');
}

function trigger (el, type) {
    var e = document.createEvent('HTMLEvents');
    e.initEvent(type, true, true);
    el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode (vnode) {
    return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
        ? locateNode(vnode.componentInstance._vnode)
        : vnode
}

var show = {
    bind: function bind (el, ref, vnode) {
        var value = ref.value;

        vnode = locateNode(vnode);
        var transition$$1 = vnode.data && vnode.data.transition;
        var originalDisplay = el.__vOriginalDisplay =
            el.style.display === 'none' ? '' : el.style.display;
        if (value && transition$$1) {
            vnode.data.show = true;
            enter(vnode, function () {
                el.style.display = originalDisplay;
            });
        } else {
            el.style.display = value ? originalDisplay : 'none';
        }
    },

    update: function update (el, ref, vnode) {
        var value = ref.value;
        var oldValue = ref.oldValue;

        /* istanbul ignore if */
        if (!value === !oldValue) { return }
        vnode = locateNode(vnode);
        var transition$$1 = vnode.data && vnode.data.transition;
        if (transition$$1) {
            vnode.data.show = true;
            if (value) {
                enter(vnode, function () {
                    el.style.display = el.__vOriginalDisplay;
                });
            } else {
                leave(vnode, function () {
                    el.style.display = 'none';
                });
            }
        } else {
            el.style.display = value ? el.__vOriginalDisplay : 'none';
        }
    },

    unbind: function unbind (
        el,
        binding,
        vnode,
        oldVnode,
        isDestroy
    ) {
        if (!isDestroy) {
            el.style.display = el.__vOriginalDisplay;
        }
    }
};

var platformDirectives = {
    model: directive,
    show: show
};

/*  */

var transitionProps = {
    name: String,
    appear: Boolean,
    css: Boolean,
    mode: String,
    type: String,
    enterClass: String,
    leaveClass: String,
    enterToClass: String,
    leaveToClass: String,
    enterActiveClass: String,
    leaveActiveClass: String,
    appearClass: String,
    appearActiveClass: String,
    appearToClass: String,
    duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild (vnode) {
    var compOptions = vnode && vnode.componentOptions;
    if (compOptions && compOptions.Ctor.options.abstract) {
        return getRealChild(getFirstComponentChild(compOptions.children))
    } else {
        return vnode
    }
}

function extractTransitionData (comp) {
    var data = {};
    var options = comp.$options;
    // props
    for (var key in options.propsData) {
        data[key] = comp[key];
    }
    // events.
    // extract listeners and pass them directly to the transition methods
    var listeners = options._parentListeners;
    for (var key$1 in listeners) {
        data[camelize(key$1)] = listeners[key$1];
    }
    return data
}

function placeholder (h, rawChild) {
    if (/\d-keep-alive$/.test(rawChild.tag)) {
        return h('keep-alive', {
            props: rawChild.componentOptions.propsData
        })
    }
}

function hasParentTransition (vnode) {
    while ((vnode = vnode.parent)) {
        if (vnode.data.transition) {
            return true
        }
    }
}

function isSameChild (child, oldChild) {
    return oldChild.key === child.key && oldChild.tag === child.tag
}

var isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };

var isVShowDirective = function (d) { return d.name === 'show'; };

var Transition = {
    name: 'transition',
    props: transitionProps,
    abstract: true,

    render: function render (h) {
        var this$1 = this;

        var children = this.$slots.default;
        if (!children) {
            return
        }

        // filter out text nodes (possible whitespaces)
        children = children.filter(isNotTextNode);
        /* istanbul ignore if */
        if (!children.length) {
            return
        }

        // warn multiple elements
        if (children.length > 1) {
            warn$1(
                '<transition> can only be used on a single element. Use ' +
                '<transition-group> for lists.',
                this.$parent
            );
        }

        var mode = this.mode;

        // warn invalid mode
        if (mode && mode !== 'in-out' && mode !== 'out-in'
        ) {
            warn$1(
                'invalid <transition> mode: ' + mode,
                this.$parent
            );
        }

        var rawChild = children[0];

        // if this is a component root node and the component's
        // parent container node also has transition, skip.
        if (hasParentTransition(this.$vnode)) {
            return rawChild
        }

        // apply transition data to child
        // use getRealChild() to ignore abstract components e.g. keep-alive
        var child = getRealChild(rawChild);
        /* istanbul ignore if */
        if (!child) {
            return rawChild
        }

        if (this._leaving) {
            return placeholder(h, rawChild)
        }

        // ensure a key that is unique to the vnode type and to this transition
        // component instance. This key will be used to remove pending leaving nodes
        // during entering.
        var id = "__transition-" + (this._uid) + "-";
        child.key = child.key == null
            ? child.isComment
                ? id + 'comment'
                : id + child.tag
            : isPrimitive(child.key)
                ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
                : child.key;

        var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
        var oldRawChild = this._vnode;
        var oldChild = getRealChild(oldRawChild);

        // mark v-show
        // so that the transition module can hand over the control to the directive
        if (child.data.directives && child.data.directives.some(isVShowDirective)) {
            child.data.show = true;
        }

        if (
            oldChild &&
            oldChild.data &&
            !isSameChild(child, oldChild) &&
            !isAsyncPlaceholder(oldChild) &&
            // #6687 component root is a comment node
            !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)
        ) {
            // replace old child transition data with fresh one
            // important for dynamic transitions!
            var oldData = oldChild.data.transition = extend$1({}, data);
            // handle transition mode
            if (mode === 'out-in') {
                // return placeholder node and queue update when leave finishes
                this._leaving = true;
                mergeVNodeHook(oldData, 'afterLeave', function () {
                    this$1._leaving = false;
                    this$1.$forceUpdate();
                });
                return placeholder(h, rawChild)
            } else if (mode === 'in-out') {
                if (isAsyncPlaceholder(child)) {
                    return oldRawChild
                }
                var delayedLeave;
                var performLeave = function () { delayedLeave(); };
                mergeVNodeHook(data, 'afterEnter', performLeave);
                mergeVNodeHook(data, 'enterCancelled', performLeave);
                mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });
            }
        }

        return rawChild
    }
};

/*  */

var props$f = extend$1({
    tag: String,
    moveClass: String
}, transitionProps);

delete props$f.mode;

var TransitionGroup = {
    props: props$f,

    beforeMount: function beforeMount () {
        var this$1 = this;

        var update = this._update;
        this._update = function (vnode, hydrating) {
            var restoreActiveInstance = setActiveInstance(this$1);
            // force removing pass
            this$1.__patch__(
                this$1._vnode,
                this$1.kept,
                false, // hydrating
                true // removeOnly (!important, avoids unnecessary moves)
            );
            this$1._vnode = this$1.kept;
            restoreActiveInstance();
            update.call(this$1, vnode, hydrating);
        };
    },

    render: function render (h) {
        var tag = this.tag || this.$vnode.data.tag || 'span';
        var map = Object.create(null);
        var prevChildren = this.prevChildren = this.children;
        var rawChildren = this.$slots.default || [];
        var children = this.children = [];
        var transitionData = extractTransitionData(this);

        for (var i = 0; i < rawChildren.length; i++) {
            var c = rawChildren[i];
            if (c.tag) {
                if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
                    children.push(c);
                    map[c.key] = c
                    ;(c.data || (c.data = {})).transition = transitionData;
                } else {
                    var opts = c.componentOptions;
                    var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;
                    warn$1(("<transition-group> children must be keyed: <" + name + ">"));
                }
            }
        }

        if (prevChildren) {
            var kept = [];
            var removed = [];
            for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
                var c$1 = prevChildren[i$1];
                c$1.data.transition = transitionData;
                c$1.data.pos = c$1.elm.getBoundingClientRect();
                if (map[c$1.key]) {
                    kept.push(c$1);
                } else {
                    removed.push(c$1);
                }
            }
            this.kept = h(tag, null, kept);
            this.removed = removed;
        }

        return h(tag, null, children)
    },

    updated: function updated () {
        var children = this.prevChildren;
        var moveClass = this.moveClass || ((this.name || 'v') + '-move');
        if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
            return
        }

        // we divide the work into three loops to avoid mixing DOM reads and writes
        // in each iteration - which helps prevent layout thrashing.
        children.forEach(callPendingCbs);
        children.forEach(recordPosition);
        children.forEach(applyTranslation);

        // force reflow to put everything in position
        // assign to this to avoid being removed in tree-shaking
        // $flow-disable-line
        this._reflow = document.body.offsetHeight;

        children.forEach(function (c) {
            if (c.data.moved) {
                var el = c.elm;
                var s = el.style;
                addTransitionClass(el, moveClass);
                s.transform = s.WebkitTransform = s.transitionDuration = '';
                el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
                    if (e && e.target !== el) {
                        return
                    }
                    if (!e || /transform$/.test(e.propertyName)) {
                        el.removeEventListener(transitionEndEvent, cb);
                        el._moveCb = null;
                        removeTransitionClass(el, moveClass);
                    }
                });
            }
        });
    },

    methods: {
        hasMove: function hasMove (el, moveClass) {
            /* istanbul ignore if */
            if (!hasTransition) {
                return false
            }
            /* istanbul ignore if */
            if (this._hasMove) {
                return this._hasMove
            }
            // Detect whether an element with the move class applied has
            // CSS transitions. Since the element may be inside an entering
            // transition at this very moment, we make a clone of it and remove
            // all other transition classes applied to ensure only the move class
            // is applied.
            var clone = el.cloneNode();
            if (el._transitionClasses) {
                el._transitionClasses.forEach(function (cls) { removeClass$1(clone, cls); });
            }
            addClass$1(clone, moveClass);
            clone.style.display = 'none';
            this.$el.appendChild(clone);
            var info = getTransitionInfo(clone);
            this.$el.removeChild(clone);
            return (this._hasMove = info.hasTransform)
        }
    }
};

function callPendingCbs (c) {
    /* istanbul ignore if */
    if (c.elm._moveCb) {
        c.elm._moveCb();
    }
    /* istanbul ignore if */
    if (c.elm._enterCb) {
        c.elm._enterCb();
    }
}

function recordPosition (c) {
    c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation (c) {
    var oldPos = c.data.pos;
    var newPos = c.data.newPos;
    var dx = oldPos.left - newPos.left;
    var dy = oldPos.top - newPos.top;
    if (dx || dy) {
        c.data.moved = true;
        var s = c.elm.style;
        s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
        s.transitionDuration = '0s';
    }
}

var platformComponents = {
    Transition: Transition,
    TransitionGroup: TransitionGroup
};

/*  */

// install platform specific utils
Vue$1.config.mustUseProp = mustUseProp;
Vue$1.config.isReservedTag = isReservedTag;
Vue$1.config.isReservedAttr = isReservedAttr;
Vue$1.config.getTagNamespace = getTagNamespace;
Vue$1.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend$1(Vue$1.options.directives, platformDirectives);
extend$1(Vue$1.options.components, platformComponents);

// install platform patch function
Vue$1.prototype.__patch__ = inBrowser ? patch : noop$1;

// public mount method
Vue$1.prototype.$mount = function (
    el,
    hydrating
) {
    el = el && inBrowser ? query(el) : undefined;
    return mountComponent(this, el, hydrating)
};

// devtools global hook
/* istanbul ignore next */
if (inBrowser) {
    setTimeout(function () {
        if (config.devtools) {
            if (devtools) {
                devtools.emit('init', Vue$1);
            } else {
                console[console.info ? 'info' : 'log'](
                    'Download the Vue Devtools extension for a better development experience:\n' +
                    'https://github.com/vuejs/vue-devtools'
                );
            }
        }
        if (config.productionTip !== false &&
            typeof console !== 'undefined'
        ) {
            console[console.info ? 'info' : 'log'](
                "You are running Vue in development mode.\n" +
                "Make sure to turn on production mode when deploying for production.\n" +
                "See more tips at https://vuejs.org/guide/deployment.html"
            );
        }
    }, 0);
}

/*!
 * vuex v3.6.2
 * (c) 2021 Evan You
 * @license MIT
 */
function applyMixin (Vue) {
    var version = Number(Vue.version.split('.')[0]);

    if (version >= 2) {
        Vue.mixin({ beforeCreate: vuexInit });
    } else {
        // override init and inject vuex init procedure
        // for 1.x backwards compatibility.
        var _init = Vue.prototype._init;
        Vue.prototype._init = function (options) {
            if ( options === void 0 ) options = {};

            options.init = options.init
                ? [vuexInit].concat(options.init)
                : vuexInit;
            _init.call(this, options);
        };
    }

    /**
     * Vuex init hook, injected into each instances init hooks list.
     */

    function vuexInit () {
        var options = this.$options;
        // store injection
        if (options.store) {
            this.$store = typeof options.store === 'function'
                ? options.store()
                : options.store;
        } else if (options.parent && options.parent.$store) {
            this.$store = options.parent.$store;
        }
    }
}

var target = typeof window !== 'undefined'
    ? window
    : typeof global !== 'undefined'
        ? global
        : {};
var devtoolHook = target.__VUE_DEVTOOLS_GLOBAL_HOOK__;

function devtoolPlugin (store) {
    if (!devtoolHook) { return }

    store._devtoolHook = devtoolHook;

    devtoolHook.emit('vuex:init', store);

    devtoolHook.on('vuex:travel-to-state', function (targetState) {
        store.replaceState(targetState);
    });

    store.subscribe(function (mutation, state) {
        devtoolHook.emit('vuex:mutation', mutation, state);
    }, { prepend: true });

    store.subscribeAction(function (action, state) {
        devtoolHook.emit('vuex:action', action, state);
    }, { prepend: true });
}

/**
 * Get the first item that pass the test
 * by second argument function
 *
 * @param {Array} list
 * @param {Function} f
 * @return {*}
 */
function find$1 (list, f) {
    return list.filter(f)[0]
}

/**
 * Deep copy the given object considering circular structure.
 * This function caches all nested objects and its copies.
 * If it detects circular structure, use cached copy to avoid infinite loop.
 *
 * @param {*} obj
 * @param {Array<Object>} cache
 * @return {*}
 */
function deepCopy (obj, cache) {
    if ( cache === void 0 ) cache = [];

    // just return if obj is immutable value
    if (obj === null || typeof obj !== 'object') {
        return obj
    }

    // if obj is hit, it is in circular structure
    var hit = find$1(cache, function (c) { return c.original === obj; });
    if (hit) {
        return hit.copy
    }

    var copy = Array.isArray(obj) ? [] : {};
    // put the copy into cache at first
    // because we want to refer it in recursive deepCopy
    cache.push({
        original: obj,
        copy: copy
    });

    Object.keys(obj).forEach(function (key) {
        copy[key] = deepCopy(obj[key], cache);
    });

    return copy
}

/**
 * forEach for object
 */
function forEachValue (obj, fn) {
    Object.keys(obj).forEach(function (key) { return fn(obj[key], key); });
}

function isObject$3 (obj) {
    return obj !== null && typeof obj === 'object'
}

function isPromise (val) {
    return val && typeof val.then === 'function'
}

function assert (condition, msg) {
    if (!condition) { throw new Error(("[vuex] " + msg)) }
}

function partial (fn, arg) {
    return function () {
        return fn(arg)
    }
}

// Base data struct for store's module, package with some attribute and method
var Module = function Module (rawModule, runtime) {
    this.runtime = runtime;
    // Store some children item
    this._children = Object.create(null);
    // Store the origin module object which passed by programmer
    this._rawModule = rawModule;
    var rawState = rawModule.state;

    // Store the origin module's state
    this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};
};

var prototypeAccessors = { namespaced: { configurable: true } };

prototypeAccessors.namespaced.get = function () {
    return !!this._rawModule.namespaced
};

Module.prototype.addChild = function addChild (key, module) {
    this._children[key] = module;
};

Module.prototype.removeChild = function removeChild (key) {
    delete this._children[key];
};

Module.prototype.getChild = function getChild (key) {
    return this._children[key]
};

Module.prototype.hasChild = function hasChild (key) {
    return key in this._children
};

Module.prototype.update = function update (rawModule) {
    this._rawModule.namespaced = rawModule.namespaced;
    if (rawModule.actions) {
        this._rawModule.actions = rawModule.actions;
    }
    if (rawModule.mutations) {
        this._rawModule.mutations = rawModule.mutations;
    }
    if (rawModule.getters) {
        this._rawModule.getters = rawModule.getters;
    }
};

Module.prototype.forEachChild = function forEachChild (fn) {
    forEachValue(this._children, fn);
};

Module.prototype.forEachGetter = function forEachGetter (fn) {
    if (this._rawModule.getters) {
        forEachValue(this._rawModule.getters, fn);
    }
};

Module.prototype.forEachAction = function forEachAction (fn) {
    if (this._rawModule.actions) {
        forEachValue(this._rawModule.actions, fn);
    }
};

Module.prototype.forEachMutation = function forEachMutation (fn) {
    if (this._rawModule.mutations) {
        forEachValue(this._rawModule.mutations, fn);
    }
};

Object.defineProperties( Module.prototype, prototypeAccessors );

var ModuleCollection = function ModuleCollection (rawRootModule) {
    // register root module (Vuex.Store options)
    this.register([], rawRootModule, false);
};

ModuleCollection.prototype.get = function get (path) {
    return path.reduce(function (module, key) {
        return module.getChild(key)
    }, this.root)
};

ModuleCollection.prototype.getNamespace = function getNamespace (path) {
    var module = this.root;
    return path.reduce(function (namespace, key) {
        module = module.getChild(key);
        return namespace + (module.namespaced ? key + '/' : '')
    }, '')
};

ModuleCollection.prototype.update = function update$1$1 (rawRootModule) {
    update$1([], this.root, rawRootModule);
};

ModuleCollection.prototype.register = function register (path, rawModule, runtime) {
    var this$1 = this;
    if ( runtime === void 0 ) runtime = true;

    {
        assertRawModule(path, rawModule);
    }

    var newModule = new Module(rawModule, runtime);
    if (path.length === 0) {
        this.root = newModule;
    } else {
        var parent = this.get(path.slice(0, -1));
        parent.addChild(path[path.length - 1], newModule);
    }

    // register nested modules
    if (rawModule.modules) {
        forEachValue(rawModule.modules, function (rawChildModule, key) {
            this$1.register(path.concat(key), rawChildModule, runtime);
        });
    }
};

ModuleCollection.prototype.unregister = function unregister (path) {
    var parent = this.get(path.slice(0, -1));
    var key = path[path.length - 1];
    var child = parent.getChild(key);

    if (!child) {
        {
            console.warn(
                "[vuex] trying to unregister module '" + key + "', which is " +
                "not registered"
            );
        }
        return
    }

    if (!child.runtime) {
        return
    }

    parent.removeChild(key);
};

ModuleCollection.prototype.isRegistered = function isRegistered (path) {
    var parent = this.get(path.slice(0, -1));
    var key = path[path.length - 1];

    if (parent) {
        return parent.hasChild(key)
    }

    return false
};

function update$1 (path, targetModule, newModule) {
    {
        assertRawModule(path, newModule);
    }

    // update target module
    targetModule.update(newModule);

    // update nested modules
    if (newModule.modules) {
        for (var key in newModule.modules) {
            if (!targetModule.getChild(key)) {
                {
                    console.warn(
                        "[vuex] trying to add a new module '" + key + "' on hot reloading, " +
                        'manual reload is needed'
                    );
                }
                return
            }
            update$1(
                path.concat(key),
                targetModule.getChild(key),
                newModule.modules[key]
            );
        }
    }
}

var functionAssert = {
    assert: function (value) { return typeof value === 'function'; },
    expected: 'function'
};

var objectAssert = {
    assert: function (value) { return typeof value === 'function' ||
        (typeof value === 'object' && typeof value.handler === 'function'); },
    expected: 'function or object with "handler" function'
};

var assertTypes = {
    getters: functionAssert,
    mutations: functionAssert,
    actions: objectAssert
};

function assertRawModule (path, rawModule) {
    Object.keys(assertTypes).forEach(function (key) {
        if (!rawModule[key]) { return }

        var assertOptions = assertTypes[key];

        forEachValue(rawModule[key], function (value, type) {
            assert(
                assertOptions.assert(value),
                makeAssertionMessage(path, key, type, value, assertOptions.expected)
            );
        });
    });
}

function makeAssertionMessage (path, key, type, value, expected) {
    var buf = key + " should be " + expected + " but \"" + key + "." + type + "\"";
    if (path.length > 0) {
        buf += " in module \"" + (path.join('.')) + "\"";
    }
    buf += " is " + (JSON.stringify(value)) + ".";
    return buf
}

var Vue; // bind on install

var Store = function Store (options) {
    var this$1 = this;
    if ( options === void 0 ) options = {};

    // Auto install if it is not done yet and `window` has `Vue`.
    // To allow users to avoid auto-installation in some cases,
    // this code should be placed here. See #731
    if (!Vue && typeof window !== 'undefined' && window.Vue) {
        install$1(window.Vue);
    }

    {
        assert(Vue, "must call Vue.use(Vuex) before creating a store instance.");
        assert(typeof Promise !== 'undefined', "vuex requires a Promise polyfill in this browser.");
        assert(this instanceof Store, "store must be called with the new operator.");
    }

    var plugins = options.plugins; if ( plugins === void 0 ) plugins = [];
    var strict = options.strict; if ( strict === void 0 ) strict = false;

    // store internal state
    this._committing = false;
    this._actions = Object.create(null);
    this._actionSubscribers = [];
    this._mutations = Object.create(null);
    this._wrappedGetters = Object.create(null);
    this._modules = new ModuleCollection(options);
    this._modulesNamespaceMap = Object.create(null);
    this._subscribers = [];
    this._watcherVM = new Vue();
    this._makeLocalGettersCache = Object.create(null);

    // bind commit and dispatch to self
    var store = this;
    var ref = this;
    var dispatch = ref.dispatch;
    var commit = ref.commit;
    this.dispatch = function boundDispatch (type, payload) {
        return dispatch.call(store, type, payload)
    };
    this.commit = function boundCommit (type, payload, options) {
        return commit.call(store, type, payload, options)
    };

    // strict mode
    this.strict = strict;

    var state = this._modules.root.state;

    // init root module.
    // this also recursively registers all sub-modules
    // and collects all module getters inside this._wrappedGetters
    installModule(this, state, [], this._modules.root);

    // initialize the store vm, which is responsible for the reactivity
    // (also registers _wrappedGetters as computed properties)
    resetStoreVM(this, state);

    // apply plugins
    plugins.forEach(function (plugin) { return plugin(this$1); });

    var useDevtools = options.devtools !== undefined ? options.devtools : Vue.config.devtools;
    if (useDevtools) {
        devtoolPlugin(this);
    }
};

var prototypeAccessors$1 = { state: { configurable: true } };

prototypeAccessors$1.state.get = function () {
    return this._vm._data.$$state
};

prototypeAccessors$1.state.set = function (v) {
    {
        assert(false, "use store.replaceState() to explicit replace store state.");
    }
};

Store.prototype.commit = function commit (_type, _payload, _options) {
    var this$1 = this;

    // check object-style commit
    var ref = unifyObjectStyle(_type, _payload, _options);
    var type = ref.type;
    var payload = ref.payload;
    var options = ref.options;

    var mutation = { type: type, payload: payload };
    var entry = this._mutations[type];
    if (!entry) {
        {
            console.error(("[vuex] unknown mutation type: " + type));
        }
        return
    }
    this._withCommit(function () {
        entry.forEach(function commitIterator (handler) {
            handler(payload);
        });
    });

    this._subscribers
        .slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe
        .forEach(function (sub) { return sub(mutation, this$1.state); });

    if (
        options && options.silent
    ) {
        console.warn(
            "[vuex] mutation type: " + type + ". Silent option has been removed. " +
            'Use the filter functionality in the vue-devtools'
        );
    }
};

Store.prototype.dispatch = function dispatch (_type, _payload) {
    var this$1 = this;

    // check object-style dispatch
    var ref = unifyObjectStyle(_type, _payload);
    var type = ref.type;
    var payload = ref.payload;

    var action = { type: type, payload: payload };
    var entry = this._actions[type];
    if (!entry) {
        {
            console.error(("[vuex] unknown action type: " + type));
        }
        return
    }

    try {
        this._actionSubscribers
            .slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe
            .filter(function (sub) { return sub.before; })
            .forEach(function (sub) { return sub.before(action, this$1.state); });
    } catch (e) {
        {
            console.warn("[vuex] error in before action subscribers: ");
            console.error(e);
        }
    }

    var result = entry.length > 1
        ? Promise.all(entry.map(function (handler) { return handler(payload); }))
        : entry[0](payload);

    return new Promise(function (resolve, reject) {
        result.then(function (res) {
            try {
                this$1._actionSubscribers
                    .filter(function (sub) { return sub.after; })
                    .forEach(function (sub) { return sub.after(action, this$1.state); });
            } catch (e) {
                {
                    console.warn("[vuex] error in after action subscribers: ");
                    console.error(e);
                }
            }
            resolve(res);
        }, function (error) {
            try {
                this$1._actionSubscribers
                    .filter(function (sub) { return sub.error; })
                    .forEach(function (sub) { return sub.error(action, this$1.state, error); });
            } catch (e) {
                {
                    console.warn("[vuex] error in error action subscribers: ");
                    console.error(e);
                }
            }
            reject(error);
        });
    })
};

Store.prototype.subscribe = function subscribe (fn, options) {
    return genericSubscribe(fn, this._subscribers, options)
};

Store.prototype.subscribeAction = function subscribeAction (fn, options) {
    var subs = typeof fn === 'function' ? { before: fn } : fn;
    return genericSubscribe(subs, this._actionSubscribers, options)
};

Store.prototype.watch = function watch (getter, cb, options) {
    var this$1 = this;

    {
        assert(typeof getter === 'function', "store.watch only accepts a function.");
    }
    return this._watcherVM.$watch(function () { return getter(this$1.state, this$1.getters); }, cb, options)
};

Store.prototype.replaceState = function replaceState (state) {
    var this$1 = this;

    this._withCommit(function () {
        this$1._vm._data.$$state = state;
    });
};

Store.prototype.registerModule = function registerModule (path, rawModule, options) {
    if ( options === void 0 ) options = {};

    if (typeof path === 'string') { path = [path]; }

    {
        assert(Array.isArray(path), "module path must be a string or an Array.");
        assert(path.length > 0, 'cannot register the root module by using registerModule.');
    }

    this._modules.register(path, rawModule);
    installModule(this, this.state, path, this._modules.get(path), options.preserveState);
    // reset store to update getters...
    resetStoreVM(this, this.state);
};

Store.prototype.unregisterModule = function unregisterModule (path) {
    var this$1 = this;

    if (typeof path === 'string') { path = [path]; }

    {
        assert(Array.isArray(path), "module path must be a string or an Array.");
    }

    this._modules.unregister(path);
    this._withCommit(function () {
        var parentState = getNestedState(this$1.state, path.slice(0, -1));
        Vue.delete(parentState, path[path.length - 1]);
    });
    resetStore(this);
};

Store.prototype.hasModule = function hasModule (path) {
    if (typeof path === 'string') { path = [path]; }

    {
        assert(Array.isArray(path), "module path must be a string or an Array.");
    }

    return this._modules.isRegistered(path)
};

Store.prototype.hotUpdate = function hotUpdate (newOptions) {
    this._modules.update(newOptions);
    resetStore(this, true);
};

Store.prototype._withCommit = function _withCommit (fn) {
    var committing = this._committing;
    this._committing = true;
    fn();
    this._committing = committing;
};

Object.defineProperties( Store.prototype, prototypeAccessors$1 );

function genericSubscribe (fn, subs, options) {
    if (subs.indexOf(fn) < 0) {
        options && options.prepend
            ? subs.unshift(fn)
            : subs.push(fn);
    }
    return function () {
        var i = subs.indexOf(fn);
        if (i > -1) {
            subs.splice(i, 1);
        }
    }
}

function resetStore (store, hot) {
    store._actions = Object.create(null);
    store._mutations = Object.create(null);
    store._wrappedGetters = Object.create(null);
    store._modulesNamespaceMap = Object.create(null);
    var state = store.state;
    // init all modules
    installModule(store, state, [], store._modules.root, true);
    // reset vm
    resetStoreVM(store, state, hot);
}

function resetStoreVM (store, state, hot) {
    var oldVm = store._vm;

    // bind store public getters
    store.getters = {};
    // reset local getters cache
    store._makeLocalGettersCache = Object.create(null);
    var wrappedGetters = store._wrappedGetters;
    var computed = {};
    forEachValue(wrappedGetters, function (fn, key) {
        // use computed to leverage its lazy-caching mechanism
        // direct inline function use will lead to closure preserving oldVm.
        // using partial to return function with only arguments preserved in closure environment.
        computed[key] = partial(fn, store);
        Object.defineProperty(store.getters, key, {
            get: function () { return store._vm[key]; },
            enumerable: true // for local getters
        });
    });

    // use a Vue instance to store the state tree
    // suppress warnings just in case the user has added
    // some funky global mixins
    var silent = Vue.config.silent;
    Vue.config.silent = true;
    store._vm = new Vue({
        data: {
            $$state: state
        },
        computed: computed
    });
    Vue.config.silent = silent;

    // enable strict mode for new vm
    if (store.strict) {
        enableStrictMode(store);
    }

    if (oldVm) {
        if (hot) {
            // dispatch changes in all subscribed watchers
            // to force getter re-evaluation for hot reloading.
            store._withCommit(function () {
                oldVm._data.$$state = null;
            });
        }
        Vue.nextTick(function () { return oldVm.$destroy(); });
    }
}

function installModule (store, rootState, path, module, hot) {
    var isRoot = !path.length;
    var namespace = store._modules.getNamespace(path);

    // register in namespace map
    if (module.namespaced) {
        if (store._modulesNamespaceMap[namespace] && ("development" !== 'production')) {
            console.error(("[vuex] duplicate namespace " + namespace + " for the namespaced module " + (path.join('/'))));
        }
        store._modulesNamespaceMap[namespace] = module;
    }

    // set state
    if (!isRoot && !hot) {
        var parentState = getNestedState(rootState, path.slice(0, -1));
        var moduleName = path[path.length - 1];
        store._withCommit(function () {
            {
                if (moduleName in parentState) {
                    console.warn(
                        ("[vuex] state field \"" + moduleName + "\" was overridden by a module with the same name at \"" + (path.join('.')) + "\"")
                    );
                }
            }
            Vue.set(parentState, moduleName, module.state);
        });
    }

    var local = module.context = makeLocalContext(store, namespace, path);

    module.forEachMutation(function (mutation, key) {
        var namespacedType = namespace + key;
        registerMutation(store, namespacedType, mutation, local);
    });

    module.forEachAction(function (action, key) {
        var type = action.root ? key : namespace + key;
        var handler = action.handler || action;
        registerAction(store, type, handler, local);
    });

    module.forEachGetter(function (getter, key) {
        var namespacedType = namespace + key;
        registerGetter(store, namespacedType, getter, local);
    });

    module.forEachChild(function (child, key) {
        installModule(store, rootState, path.concat(key), child, hot);
    });
}

/**
 * make localized dispatch, commit, getters and state
 * if there is no namespace, just use root ones
 */
function makeLocalContext (store, namespace, path) {
    var noNamespace = namespace === '';

    var local = {
        dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {
            var args = unifyObjectStyle(_type, _payload, _options);
            var payload = args.payload;
            var options = args.options;
            var type = args.type;

            if (!options || !options.root) {
                type = namespace + type;
                if (!store._actions[type]) {
                    console.error(("[vuex] unknown local action type: " + (args.type) + ", global type: " + type));
                    return
                }
            }

            return store.dispatch(type, payload)
        },

        commit: noNamespace ? store.commit : function (_type, _payload, _options) {
            var args = unifyObjectStyle(_type, _payload, _options);
            var payload = args.payload;
            var options = args.options;
            var type = args.type;

            if (!options || !options.root) {
                type = namespace + type;
                if (!store._mutations[type]) {
                    console.error(("[vuex] unknown local mutation type: " + (args.type) + ", global type: " + type));
                    return
                }
            }

            store.commit(type, payload, options);
        }
    };

    // getters and state object must be gotten lazily
    // because they will be changed by vm update
    Object.defineProperties(local, {
        getters: {
            get: noNamespace
                ? function () { return store.getters; }
                : function () { return makeLocalGetters(store, namespace); }
        },
        state: {
            get: function () { return getNestedState(store.state, path); }
        }
    });

    return local
}

function makeLocalGetters (store, namespace) {
    if (!store._makeLocalGettersCache[namespace]) {
        var gettersProxy = {};
        var splitPos = namespace.length;
        Object.keys(store.getters).forEach(function (type) {
            // skip if the target getter is not match this namespace
            if (type.slice(0, splitPos) !== namespace) { return }

            // extract local getter type
            var localType = type.slice(splitPos);

            // Add a port to the getters proxy.
            // Define as getter property because
            // we do not want to evaluate the getters in this time.
            Object.defineProperty(gettersProxy, localType, {
                get: function () { return store.getters[type]; },
                enumerable: true
            });
        });
        store._makeLocalGettersCache[namespace] = gettersProxy;
    }

    return store._makeLocalGettersCache[namespace]
}

function registerMutation (store, type, handler, local) {
    var entry = store._mutations[type] || (store._mutations[type] = []);
    entry.push(function wrappedMutationHandler (payload) {
        handler.call(store, local.state, payload);
    });
}

function registerAction (store, type, handler, local) {
    var entry = store._actions[type] || (store._actions[type] = []);
    entry.push(function wrappedActionHandler (payload) {
        var res = handler.call(store, {
            dispatch: local.dispatch,
            commit: local.commit,
            getters: local.getters,
            state: local.state,
            rootGetters: store.getters,
            rootState: store.state
        }, payload);
        if (!isPromise(res)) {
            res = Promise.resolve(res);
        }
        if (store._devtoolHook) {
            return res.catch(function (err) {
                store._devtoolHook.emit('vuex:error', err);
                throw err
            })
        } else {
            return res
        }
    });
}

function registerGetter (store, type, rawGetter, local) {
    if (store._wrappedGetters[type]) {
        {
            console.error(("[vuex] duplicate getter key: " + type));
        }
        return
    }
    store._wrappedGetters[type] = function wrappedGetter (store) {
        return rawGetter(
            local.state, // local state
            local.getters, // local getters
            store.state, // root state
            store.getters // root getters
        )
    };
}

function enableStrictMode (store) {
    store._vm.$watch(function () { return this._data.$$state }, function () {
        {
            assert(store._committing, "do not mutate vuex store state outside mutation handlers.");
        }
    }, { deep: true, sync: true });
}

function getNestedState (state, path) {
    return path.reduce(function (state, key) { return state[key]; }, state)
}

function unifyObjectStyle (type, payload, options) {
    if (isObject$3(type) && type.type) {
        options = payload;
        payload = type;
        type = type.type;
    }

    {
        assert(typeof type === 'string', ("expects string as the type, but found " + (typeof type) + "."));
    }

    return { type: type, payload: payload, options: options }
}

function install$1 (_Vue) {
    if (Vue && _Vue === Vue) {
        {
            console.error(
                '[vuex] already installed. Vue.use(Vuex) should be called only once.'
            );
        }
        return
    }
    Vue = _Vue;
    applyMixin(Vue);
}

/**
 * Reduce the code which written in Vue.js for getting the state.
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} states # Object's item can be a function which accept state and getters for param, you can do something for state and getters in it.
 * @param {Object}
 */
var mapState = normalizeNamespace(function (namespace, states) {
    var res = {};
    if (!isValidMap(states)) {
        console.error('[vuex] mapState: mapper parameter must be either an Array or an Object');
    }
    normalizeMap(states).forEach(function (ref) {
        var key = ref.key;
        var val = ref.val;

        res[key] = function mappedState () {
            var state = this.$store.state;
            var getters = this.$store.getters;
            if (namespace) {
                var module = getModuleByNamespace(this.$store, 'mapState', namespace);
                if (!module) {
                    return
                }
                state = module.context.state;
                getters = module.context.getters;
            }
            return typeof val === 'function'
                ? val.call(this, state, getters)
                : state[val]
        };
        // mark vuex getter for devtools
        res[key].vuex = true;
    });
    return res
});

/**
 * Reduce the code which written in Vue.js for committing the mutation
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} mutations # Object's item can be a function which accept `commit` function as the first param, it can accept another params. You can commit mutation and do any other things in this function. specially, You need to pass anthor params from the mapped function.
 * @return {Object}
 */
var mapMutations = normalizeNamespace(function (namespace, mutations) {
    var res = {};
    if (!isValidMap(mutations)) {
        console.error('[vuex] mapMutations: mapper parameter must be either an Array or an Object');
    }
    normalizeMap(mutations).forEach(function (ref) {
        var key = ref.key;
        var val = ref.val;

        res[key] = function mappedMutation () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            // Get the commit method from store
            var commit = this.$store.commit;
            if (namespace) {
                var module = getModuleByNamespace(this.$store, 'mapMutations', namespace);
                if (!module) {
                    return
                }
                commit = module.context.commit;
            }
            return typeof val === 'function'
                ? val.apply(this, [commit].concat(args))
                : commit.apply(this.$store, [val].concat(args))
        };
    });
    return res
});

/**
 * Reduce the code which written in Vue.js for getting the getters
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} getters
 * @return {Object}
 */
var mapGetters = normalizeNamespace(function (namespace, getters) {
    var res = {};
    if (!isValidMap(getters)) {
        console.error('[vuex] mapGetters: mapper parameter must be either an Array or an Object');
    }
    normalizeMap(getters).forEach(function (ref) {
        var key = ref.key;
        var val = ref.val;

        // The namespace has been mutated by normalizeNamespace
        val = namespace + val;
        res[key] = function mappedGetter () {
            if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
                return
            }
            if (!(val in this.$store.getters)) {
                console.error(("[vuex] unknown getter: " + val));
                return
            }
            return this.$store.getters[val]
        };
        // mark vuex getter for devtools
        res[key].vuex = true;
    });
    return res
});

/**
 * Reduce the code which written in Vue.js for dispatch the action
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} actions # Object's item can be a function which accept `dispatch` function as the first param, it can accept anthor params. You can dispatch action and do any other things in this function. specially, You need to pass anthor params from the mapped function.
 * @return {Object}
 */
var mapActions = normalizeNamespace(function (namespace, actions) {
    var res = {};
    if (!isValidMap(actions)) {
        console.error('[vuex] mapActions: mapper parameter must be either an Array or an Object');
    }
    normalizeMap(actions).forEach(function (ref) {
        var key = ref.key;
        var val = ref.val;

        res[key] = function mappedAction () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            // get dispatch function from store
            var dispatch = this.$store.dispatch;
            if (namespace) {
                var module = getModuleByNamespace(this.$store, 'mapActions', namespace);
                if (!module) {
                    return
                }
                dispatch = module.context.dispatch;
            }
            return typeof val === 'function'
                ? val.apply(this, [dispatch].concat(args))
                : dispatch.apply(this.$store, [val].concat(args))
        };
    });
    return res
});

/**
 * Rebinding namespace param for mapXXX function in special scoped, and return them by simple object
 * @param {String} namespace
 * @return {Object}
 */
var createNamespacedHelpers = function (namespace) { return ({
    mapState: mapState.bind(null, namespace),
    mapGetters: mapGetters.bind(null, namespace),
    mapMutations: mapMutations.bind(null, namespace),
    mapActions: mapActions.bind(null, namespace)
}); };

/**
 * Normalize the map
 * normalizeMap([1, 2, 3]) => [ { key: 1, val: 1 }, { key: 2, val: 2 }, { key: 3, val: 3 } ]
 * normalizeMap({a: 1, b: 2, c: 3}) => [ { key: 'a', val: 1 }, { key: 'b', val: 2 }, { key: 'c', val: 3 } ]
 * @param {Array|Object} map
 * @return {Object}
 */
function normalizeMap (map) {
    if (!isValidMap(map)) {
        return []
    }
    return Array.isArray(map)
        ? map.map(function (key) { return ({ key: key, val: key }); })
        : Object.keys(map).map(function (key) { return ({ key: key, val: map[key] }); })
}

/**
 * Validate whether given map is valid or not
 * @param {*} map
 * @return {Boolean}
 */
function isValidMap (map) {
    return Array.isArray(map) || isObject$3(map)
}

/**
 * Return a function expect two param contains namespace and map. it will normalize the namespace and then the param's function will handle the new namespace and the map.
 * @param {Function} fn
 * @return {Function}
 */
function normalizeNamespace (fn) {
    return function (namespace, map) {
        if (typeof namespace !== 'string') {
            map = namespace;
            namespace = '';
        } else if (namespace.charAt(namespace.length - 1) !== '/') {
            namespace += '/';
        }
        return fn(namespace, map)
    }
}

/**
 * Search a special module from store by namespace. if module not exist, print error message.
 * @param {Object} store
 * @param {String} helper
 * @param {String} namespace
 * @return {Object}
 */
function getModuleByNamespace (store, helper, namespace) {
    var module = store._modulesNamespaceMap[namespace];
    if (!module) {
        console.error(("[vuex] module namespace not found in " + helper + "(): " + namespace));
    }
    return module
}

// Credits: borrowed code from fcomb/redux-logger

function createLogger (ref) {
    if ( ref === void 0 ) ref = {};
    var collapsed = ref.collapsed; if ( collapsed === void 0 ) collapsed = true;
    var filter = ref.filter; if ( filter === void 0 ) filter = function (mutation, stateBefore, stateAfter) { return true; };
    var transformer = ref.transformer; if ( transformer === void 0 ) transformer = function (state) { return state; };
    var mutationTransformer = ref.mutationTransformer; if ( mutationTransformer === void 0 ) mutationTransformer = function (mut) { return mut; };
    var actionFilter = ref.actionFilter; if ( actionFilter === void 0 ) actionFilter = function (action, state) { return true; };
    var actionTransformer = ref.actionTransformer; if ( actionTransformer === void 0 ) actionTransformer = function (act) { return act; };
    var logMutations = ref.logMutations; if ( logMutations === void 0 ) logMutations = true;
    var logActions = ref.logActions; if ( logActions === void 0 ) logActions = true;
    var logger = ref.logger; if ( logger === void 0 ) logger = console;

    return function (store) {
        var prevState = deepCopy(store.state);

        if (typeof logger === 'undefined') {
            return
        }

        if (logMutations) {
            store.subscribe(function (mutation, state) {
                var nextState = deepCopy(state);

                if (filter(mutation, prevState, nextState)) {
                    var formattedTime = getFormattedTime();
                    var formattedMutation = mutationTransformer(mutation);
                    var message = "mutation " + (mutation.type) + formattedTime;

                    startMessage(logger, message, collapsed);
                    logger.log('%c prev state', 'color: #9E9E9E; font-weight: bold', transformer(prevState));
                    logger.log('%c mutation', 'color: #03A9F4; font-weight: bold', formattedMutation);
                    logger.log('%c next state', 'color: #4CAF50; font-weight: bold', transformer(nextState));
                    endMessage(logger);
                }

                prevState = nextState;
            });
        }

        if (logActions) {
            store.subscribeAction(function (action, state) {
                if (actionFilter(action, state)) {
                    var formattedTime = getFormattedTime();
                    var formattedAction = actionTransformer(action);
                    var message = "action " + (action.type) + formattedTime;

                    startMessage(logger, message, collapsed);
                    logger.log('%c action', 'color: #03A9F4; font-weight: bold', formattedAction);
                    endMessage(logger);
                }
            });
        }
    }
}

function startMessage (logger, message, collapsed) {
    var startMessage = collapsed
        ? logger.groupCollapsed
        : logger.group;

    // render
    try {
        startMessage.call(logger, message);
    } catch (e) {
        logger.log(message);
    }
}

function endMessage (logger) {
    try {
        logger.groupEnd();
    } catch (e) {
        logger.log(' log end ');
    }
}

function getFormattedTime () {
    var time = new Date();
    return (" @ " + (pad(time.getHours(), 2)) + ":" + (pad(time.getMinutes(), 2)) + ":" + (pad(time.getSeconds(), 2)) + "." + (pad(time.getMilliseconds(), 3)))
}

function repeat (str, times) {
    return (new Array(times + 1)).join(str)
}

function pad (num, maxLength) {
    return repeat('0', maxLength - num.toString().length) + num
}

var index = {
    Store: Store,
    install: install$1,
    version: '3.6.2',
    mapState: mapState,
    mapMutations: mapMutations,
    mapGetters: mapGetters,
    mapActions: mapActions,
    createNamespacedHelpers: createNamespacedHelpers,
    createLogger: createLogger
};

var bind$1 = function bind(fn, thisArg) {
    return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
    };
};

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString$1 = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray$1(val) {
    return toString$1.call(val) === '[object Array]';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined$1(val) {
    return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
    return val !== null && !isUndefined$1(val) && val.constructor !== null && !isUndefined$1(val.constructor)
        && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
    return toString$1.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
    return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
    var result;
    if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
        result = ArrayBuffer.isView(val);
    } else {
        result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
    }
    return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString$2(val) {
    return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber$1(val) {
    return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject$2(val) {
    return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject$1(val) {
    if (toString$1.call(val) !== '[object Object]') {
        return false;
    }

    var prototype = Object.getPrototypeOf(val);
    return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate$1(val) {
    return toString$1.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
    return toString$1.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
    return toString$1.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction$2(val) {
    return toString$1.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
    return isObject$2(val) && isFunction$2(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
    return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
    return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
    if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
        navigator.product === 'NativeScript' ||
        navigator.product === 'NS')) {
        return false;
    }
    return (
        typeof window !== 'undefined' &&
        typeof document !== 'undefined'
    );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
    // Don't bother if no value provided
    if (obj === null || typeof obj === 'undefined') {
        return;
    }

    // Force an array if not already something iterable
    if (typeof obj !== 'object') {
        /*eslint no-param-reassign:0*/
        obj = [obj];
    }

    if (isArray$1(obj)) {
        // Iterate over array values
        for (var i = 0, l = obj.length; i < l; i++) {
            fn.call(null, obj[i], i, obj);
        }
    } else {
        // Iterate over object keys
        for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                fn.call(null, obj[key], key, obj);
            }
        }
    }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
    var result = {};
    function assignValue(val, key) {
        if (isPlainObject$1(result[key]) && isPlainObject$1(val)) {
            result[key] = merge(result[key], val);
        } else if (isPlainObject$1(val)) {
            result[key] = merge({}, val);
        } else if (isArray$1(val)) {
            result[key] = val.slice();
        } else {
            result[key] = val;
        }
    }

    for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
    }
    return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
    forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === 'function') {
            a[key] = bind$1(val, thisArg);
        } else {
            a[key] = val;
        }
    });
    return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
    if (content.charCodeAt(0) === 0xFEFF) {
        content = content.slice(1);
    }
    return content;
}

var utils = {
    isArray: isArray$1,
    isArrayBuffer: isArrayBuffer,
    isBuffer: isBuffer,
    isFormData: isFormData,
    isArrayBufferView: isArrayBufferView,
    isString: isString$2,
    isNumber: isNumber$1,
    isObject: isObject$2,
    isPlainObject: isPlainObject$1,
    isUndefined: isUndefined$1,
    isDate: isDate$1,
    isFile: isFile,
    isBlob: isBlob,
    isFunction: isFunction$2,
    isStream: isStream,
    isURLSearchParams: isURLSearchParams,
    isStandardBrowserEnv: isStandardBrowserEnv,
    forEach: forEach,
    merge: merge,
    extend: extend,
    trim: trim,
    stripBOM: stripBOM
};

function encode$1(val) {
    return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
var buildURL = function buildURL(url, params, paramsSerializer) {
    /*eslint no-param-reassign:0*/
    if (!params) {
        return url;
    }

    var serializedParams;
    if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
    } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
    } else {
        var parts = [];

        utils.forEach(params, function serialize(val, key) {
            if (val === null || typeof val === 'undefined') {
                return;
            }

            if (utils.isArray(val)) {
                key = key + '[]';
            } else {
                val = [val];
            }

            utils.forEach(val, function parseValue(v) {
                if (utils.isDate(v)) {
                    v = v.toISOString();
                } else if (utils.isObject(v)) {
                    v = JSON.stringify(v);
                }
                parts.push(encode$1(key) + '=' + encode$1(v));
            });
        });

        serializedParams = parts.join('&');
    }

    if (serializedParams) {
        var hashmarkIndex = url.indexOf('#');
        if (hashmarkIndex !== -1) {
            url = url.slice(0, hashmarkIndex);
        }

        url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
    }

    return url;
};

function InterceptorManager() {
    this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
    this.handlers.push({
        fulfilled: fulfilled,
        rejected: rejected
    });
    return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
    if (this.handlers[id]) {
        this.handlers[id] = null;
    }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
            fn(h);
        }
    });
};

var InterceptorManager_1 = InterceptorManager;

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
var transformData = function transformData(data, headers, fns) {
    /*eslint no-param-reassign:0*/
    utils.forEach(fns, function transform(fn) {
        data = fn(data, headers);
    });

    return data;
};

var isCancel = function isCancel(value) {
    return !!(value && value.__CANCEL__);
};

var normalizeHeaderName = function normalizeHeaderName(headers, normalizedName) {
    utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
            headers[normalizedName] = value;
            delete headers[name];
        }
    });
};

/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
var enhanceError = function enhanceError(error, config, code, request, response) {
    error.config = config;
    if (code) {
        error.code = code;
    }

    error.request = request;
    error.response = response;
    error.isAxiosError = true;

    error.toJSON = function toJSON() {
        return {
            // Standard
            message: this.message,
            name: this.name,
            // Microsoft
            description: this.description,
            number: this.number,
            // Mozilla
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            // Axios
            config: this.config,
            code: this.code
        };
    };
    return error;
};

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
var createError = function createError(message, config, code, request, response) {
    var error = new Error(message);
    return enhanceError(error, config, code, request, response);
};

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
var settle = function settle(resolve, reject, response) {
    var validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
    } else {
        reject(createError(
            'Request failed with status code ' + response.status,
            response.config,
            null,
            response.request,
            response
        ));
    }
};

var cookies = (
    utils.isStandardBrowserEnv() ?

        // Standard browser envs support document.cookie
        (function standardBrowserEnv() {
            return {
                write: function write(name, value, expires, path, domain, secure) {
                    var cookie = [];
                    cookie.push(name + '=' + encodeURIComponent(value));

                    if (utils.isNumber(expires)) {
                        cookie.push('expires=' + new Date(expires).toGMTString());
                    }

                    if (utils.isString(path)) {
                        cookie.push('path=' + path);
                    }

                    if (utils.isString(domain)) {
                        cookie.push('domain=' + domain);
                    }

                    if (secure === true) {
                        cookie.push('secure');
                    }

                    document.cookie = cookie.join('; ');
                },

                read: function read(name) {
                    var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
                    return (match ? decodeURIComponent(match[3]) : null);
                },

                remove: function remove(name) {
                    this.write(name, '', Date.now() - 86400000);
                }
            };
        })() :

        // Non standard browser env (web workers, react-native) lack needed support.
        (function nonStandardBrowserEnv() {
            return {
                write: function write() {},
                read: function read() { return null; },
                remove: function remove() {}
            };
        })()
);

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
var isAbsoluteURL = function isAbsoluteURL(url) {
    // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
    // by any combination of letters, digits, plus, period, or hyphen.
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
var combineURLs = function combineURLs(baseURL, relativeURL) {
    return relativeURL
        ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
        : baseURL;
};

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
var buildFullPath = function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
};

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
    'age', 'authorization', 'content-length', 'content-type', 'etag',
    'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
    'last-modified', 'location', 'max-forwards', 'proxy-authorization',
    'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
var parseHeaders = function parseHeaders(headers) {
    var parsed = {};
    var key;
    var val;
    var i;

    if (!headers) { return parsed; }

    utils.forEach(headers.split('\n'), function parser(line) {
        i = line.indexOf(':');
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));

        if (key) {
            if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
                return;
            }
            if (key === 'set-cookie') {
                parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
            } else {
                parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
            }
        }
    });

    return parsed;
};

var isURLSameOrigin = (
    utils.isStandardBrowserEnv() ?

        // Standard browser envs have full support of the APIs needed to test
        // whether the request URL is of the same origin as current location.
        (function standardBrowserEnv() {
            var msie = /(msie|trident)/i.test(navigator.userAgent);
            var urlParsingNode = document.createElement('a');
            var originURL;

            /**
             * Parse a URL to discover it's components
             *
             * @param {String} url The URL to be parsed
             * @returns {Object}
             */
            function resolveURL(url) {
                var href = url;

                if (msie) {
                    // IE needs attribute set twice to normalize properties
                    urlParsingNode.setAttribute('href', href);
                    href = urlParsingNode.href;
                }

                urlParsingNode.setAttribute('href', href);

                // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
                return {
                    href: urlParsingNode.href,
                    protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
                    host: urlParsingNode.host,
                    search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
                    hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
                    hostname: urlParsingNode.hostname,
                    port: urlParsingNode.port,
                    pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                        urlParsingNode.pathname :
                        '/' + urlParsingNode.pathname
                };
            }

            originURL = resolveURL(window.location.href);

            /**
             * Determine if a URL shares the same origin as the current location
             *
             * @param {String} requestURL The URL to test
             * @returns {boolean} True if URL shares the same origin, otherwise false
             */
            return function isURLSameOrigin(requestURL) {
                var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
                return (parsed.protocol === originURL.protocol &&
                    parsed.host === originURL.host);
            };
        })() :

        // Non standard browser envs (web workers, react-native) lack needed support.
        (function nonStandardBrowserEnv() {
            return function isURLSameOrigin() {
                return true;
            };
        })()
);

var xhr = function xhrAdapter(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;

        if (utils.isFormData(requestData)) {
            delete requestHeaders['Content-Type']; // Let the browser set it
        }

        var request = new XMLHttpRequest();

        // HTTP basic authentication
        if (config.auth) {
            var username = config.auth.username || '';
            var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
            requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
        }

        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

        // Set the request timeout in MS
        request.timeout = config.timeout;

        // Listen for ready state
        request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
                return;
            }

            // The request errored out and we didn't get a response, this will be
            // handled by onerror instead
            // With one exception: request that using file: protocol, most browsers
            // will return status as 0 even though it's a successful request
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
                return;
            }

            // Prepare the response
            var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
            var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
            var response = {
                data: responseData,
                status: request.status,
                statusText: request.statusText,
                headers: responseHeaders,
                config: config,
                request: request
            };

            settle(resolve, reject, response);

            // Clean up request
            request = null;
        };

        // Handle browser request cancellation (as opposed to a manual cancellation)
        request.onabort = function handleAbort() {
            if (!request) {
                return;
            }

            reject(createError('Request aborted', config, 'ECONNABORTED', request));

            // Clean up request
            request = null;
        };

        // Handle low level network errors
        request.onerror = function handleError() {
            // Real errors are hidden from us by the browser
            // onerror should only fire if it's a network error
            reject(createError('Network Error', config, null, request));

            // Clean up request
            request = null;
        };

        // Handle timeout
        request.ontimeout = function handleTimeout() {
            var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
            if (config.timeoutErrorMessage) {
                timeoutErrorMessage = config.timeoutErrorMessage;
            }
            reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',
                request));

            // Clean up request
            request = null;
        };

        // Add xsrf header
        // This is only done if running in a standard browser environment.
        // Specifically not if we're in a web worker, or react-native.
        if (utils.isStandardBrowserEnv()) {
            // Add xsrf header
            var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
                cookies.read(config.xsrfCookieName) :
                undefined;

            if (xsrfValue) {
                requestHeaders[config.xsrfHeaderName] = xsrfValue;
            }
        }

        // Add headers to the request
        if ('setRequestHeader' in request) {
            utils.forEach(requestHeaders, function setRequestHeader(val, key) {
                if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
                    // Remove Content-Type if data is undefined
                    delete requestHeaders[key];
                } else {
                    // Otherwise add header to the request
                    request.setRequestHeader(key, val);
                }
            });
        }

        // Add withCredentials to request if needed
        if (!utils.isUndefined(config.withCredentials)) {
            request.withCredentials = !!config.withCredentials;
        }

        // Add responseType to request if needed
        if (config.responseType) {
            try {
                request.responseType = config.responseType;
            } catch (e) {
                // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
                // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
                if (config.responseType !== 'json') {
                    throw e;
                }
            }
        }

        // Handle progress if needed
        if (typeof config.onDownloadProgress === 'function') {
            request.addEventListener('progress', config.onDownloadProgress);
        }

        // Not all browsers support upload events
        if (typeof config.onUploadProgress === 'function' && request.upload) {
            request.upload.addEventListener('progress', config.onUploadProgress);
        }

        if (config.cancelToken) {
            // Handle cancellation
            config.cancelToken.promise.then(function onCanceled(cancel) {
                if (!request) {
                    return;
                }

                request.abort();
                reject(cancel);
                // Clean up request
                request = null;
            });
        }

        if (!requestData) {
            requestData = null;
        }

        // Send the request
        request.send(requestData);
    });
};

var DEFAULT_CONTENT_TYPE = {
    'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
    if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
        headers['Content-Type'] = value;
    }
}

function getDefaultAdapter() {
    var adapter;
    if (typeof XMLHttpRequest !== 'undefined') {
        // For browsers use XHR adapter
        adapter = xhr;
    } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
        // For node use HTTP adapter
        adapter = xhr;
    }
    return adapter;
}

var defaults = {
    adapter: getDefaultAdapter(),

    transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, 'Accept');
        normalizeHeaderName(headers, 'Content-Type');
        if (utils.isFormData(data) ||
            utils.isArrayBuffer(data) ||
            utils.isBuffer(data) ||
            utils.isStream(data) ||
            utils.isFile(data) ||
            utils.isBlob(data)
        ) {
            return data;
        }
        if (utils.isArrayBufferView(data)) {
            return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
            setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
            return data.toString();
        }
        if (utils.isObject(data)) {
            setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
            return JSON.stringify(data);
        }
        return data;
    }],

    transformResponse: [function transformResponse(data) {
        /*eslint no-param-reassign:0*/
        if (typeof data === 'string') {
            try {
                data = JSON.parse(data);
            } catch (e) { /* Ignore */ }
        }
        return data;
    }],

    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,

    xsrfCookieName: 'XSRF-TOKEN',
    xsrfHeaderName: 'X-XSRF-TOKEN',

    maxContentLength: -1,
    maxBodyLength: -1,

    validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
    }
};

defaults.headers = {
    common: {
        'Accept': 'application/json, text/plain, */*'
    }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
    defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
    defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

var defaults_1 = defaults;

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
    }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
var dispatchRequest = function dispatchRequest(config) {
    throwIfCancellationRequested(config);

    // Ensure headers exist
    config.headers = config.headers || {};

    // Transform request data
    config.data = transformData(
        config.data,
        config.headers,
        config.transformRequest
    );

    // Flatten headers
    config.headers = utils.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
    );

    utils.forEach(
        ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
        function cleanHeaderConfig(method) {
            delete config.headers[method];
        }
    );

    var adapter = config.adapter || defaults_1.adapter;

    return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);

        // Transform response data
        response.data = transformData(
            response.data,
            response.headers,
            config.transformResponse
        );

        return response;
    }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
            throwIfCancellationRequested(config);

            // Transform response data
            if (reason && reason.response) {
                reason.response.data = transformData(
                    reason.response.data,
                    reason.response.headers,
                    config.transformResponse
                );
            }
        }

        return Promise.reject(reason);
    });
};

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
var mergeConfig = function mergeConfig(config1, config2) {
    // eslint-disable-next-line no-param-reassign
    config2 = config2 || {};
    var config = {};

    var valueFromConfig2Keys = ['url', 'method', 'data'];
    var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
    var defaultToConfig2Keys = [
        'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
        'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
        'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
        'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
        'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
    ];
    var directMergeKeys = ['validateStatus'];

    function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
            return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
            return utils.merge({}, source);
        } else if (utils.isArray(source)) {
            return source.slice();
        }
        return source;
    }

    function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
            config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
            config[prop] = getMergedValue(undefined, config1[prop]);
        }
    }

    utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
            config[prop] = getMergedValue(undefined, config2[prop]);
        }
    });

    utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

    utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
            config[prop] = getMergedValue(undefined, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
            config[prop] = getMergedValue(undefined, config1[prop]);
        }
    });

    utils.forEach(directMergeKeys, function merge(prop) {
        if (prop in config2) {
            config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
            config[prop] = getMergedValue(undefined, config1[prop]);
        }
    });

    var axiosKeys = valueFromConfig2Keys
        .concat(mergeDeepPropertiesKeys)
        .concat(defaultToConfig2Keys)
        .concat(directMergeKeys);

    var otherKeys = Object
        .keys(config1)
        .concat(Object.keys(config2))
        .filter(function filterAxiosKeys(key) {
            return axiosKeys.indexOf(key) === -1;
        });

    utils.forEach(otherKeys, mergeDeepProperties);

    return config;
};

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
        request: new InterceptorManager_1(),
        response: new InterceptorManager_1()
    };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof config === 'string') {
        config = arguments[1] || {};
        config.url = arguments[0];
    } else {
        config = config || {};
    }

    config = mergeConfig(this.defaults, config);

    // Set config.method
    if (config.method) {
        config.method = config.method.toLowerCase();
    } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
    } else {
        config.method = 'get';
    }

    // Hook up interceptors middleware
    var chain = [dispatchRequest, undefined];
    var promise = Promise.resolve(config);

    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        chain.unshift(interceptor.fulfilled, interceptor.rejected);
    });

    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        chain.push(interceptor.fulfilled, interceptor.rejected);
    });

    while (chain.length) {
        promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
};

Axios.prototype.getUri = function getUri(config) {
    config = mergeConfig(this.defaults, config);
    return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
    /*eslint func-names:0*/
    Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
            method: method,
            url: url,
            data: (config || {}).data
        }));
    };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
    /*eslint func-names:0*/
    Axios.prototype[method] = function(url, data, config) {
        return this.request(mergeConfig(config || {}, {
            method: method,
            url: url,
            data: data
        }));
    };
});

var Axios_1 = Axios;

/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
    this.message = message;
}

Cancel.prototype.toString = function toString() {
    return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

var Cancel_1 = Cancel;

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
    if (typeof executor !== 'function') {
        throw new TypeError('executor must be a function.');
    }

    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
    });

    var token = this;
    executor(function cancel(message) {
        if (token.reason) {
            // Cancellation has already been requested
            return;
        }

        token.reason = new Cancel_1(message);
        resolvePromise(token.reason);
    });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
        throw this.reason;
    }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
    var cancel;
    var token = new CancelToken(function executor(c) {
        cancel = c;
    });
    return {
        token: token,
        cancel: cancel
    };
};

var CancelToken_1 = CancelToken;

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
var spread = function spread(callback) {
    return function wrap(arr) {
        return callback.apply(null, arr);
    };
};

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
var isAxiosError = function isAxiosError(payload) {
    return (typeof payload === 'object') && (payload.isAxiosError === true);
};

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
    var context = new Axios_1(defaultConfig);
    var instance = bind$1(Axios_1.prototype.request, context);

    // Copy axios.prototype to instance
    utils.extend(instance, Axios_1.prototype, context);

    // Copy context to instance
    utils.extend(instance, context);

    return instance;
}

// Create the default instance to be exported
var axios$1 = createInstance(defaults_1);

// Expose Axios class to allow class inheritance
axios$1.Axios = Axios_1;

// Factory for creating new instances
axios$1.create = function create(instanceConfig) {
    return createInstance(mergeConfig(axios$1.defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios$1.Cancel = Cancel_1;
axios$1.CancelToken = CancelToken_1;
axios$1.isCancel = isCancel;

// Expose all/spread
axios$1.all = function all(promises) {
    return Promise.all(promises);
};
axios$1.spread = spread;

// Expose isAxiosError
axios$1.isAxiosError = isAxiosError;

var axios_1 = axios$1;

// Allow use of default import syntax in TypeScript
var default_1 = axios$1;
axios_1.default = default_1;

var axios = axios_1;

//

var script$d = {
    created() {
        window.init_map = () => {
            this.ymap = new ymaps.Map(document.getElementById('map'), {
                center: [41.2995, 69.2401],
                zoom: 13,
                controls: ['typeSelector']
            });

            this.marker = new ymaps.GeoObject(
                {
                    geometry: {
                        type: "Point",
                        coordinates: this.coords
                    }
                },
                {draggable: !this.manually}
            );

            this.marker.events.add("dragend", (event) => {
                // to solve bug
                this.coords = [...event.originalEvent.target.geometry.getCoordinates()];
                this.addressBindEnabled = false;
                this.dragged = !this.manually;
            });
            this.ymap.geoObjects.add(this.marker);
        };
    },

    props: {
        areas: Array
    },

    data() {
        return {
            hasDragged: false,
            manually: false,
            addressBindEnabled: true
        }
    },

    methods: {
        moveMapCoords(coordinates, moveCenter) {
            if (moveCenter)
                this.ymap && this.ymap.setCenter(coordinates);
            this.marker && this.marker.geometry.setCoordinates(coordinates);
        },

    },

    computed: {
        districts: function () {
            return (this.area && this.area.districts) || []
        },

        yAddress: function () {
            return this.$store.getters['details/yAddress'];
        },

        area: {
            get() {
                return this.$store.state.details.area;
            },
            set(area) {
                this.$store.commit('details/updateArea', area);
            }
        },

        address: {
            get() {
                return this.$store.state.details.address;
            },
            set(address) {
                this.$store.commit('details/updateAddress', address);
            }
        },

        district: {
            get() {
                return this.$store.state.details.district;
            },
            set(district) {
                this.$store.commit('details/updateDistrict', district);
            }
        },

        coords: {
            get() {
                return this.$store.state.details.coords;
            },
            set(coords) {
                this.$store.commit('details/updateCoords', coords);
            }
        },

        errors() {
            return this.$store.state.details.errors;
        }
    },

    watch: {
        manually: function (manually) {
            this.addressBindEnabled = false;
            this.ymap.geoObjects.get(0).options.set({draggable: !manually});
        },

        yAddress: function (newAddress) {
            if (newAddress && newAddress !== '' && this.addressBindEnabled) {
                ymaps.geocode(newAddress).then(result => {
                    this.coords = [...result.geoObjects.get(0).geometry.getCoordinates()];
                    this.moveMapCoords(this.coords, true);
                });
            }
        }
    }
};

/* script */
const __vue_script__$d = script$d;

/* template */
var __vue_render__$d = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('div',{staticClass:"row"},[_c('div',{staticClass:"col-md-6"},[_c('div',{staticClass:"form-group"},[_c('label',[_vm._v(_vm._s(_vm._f("t")('  ')))]),_vm._v(" "),_c('select',{directives:[{name:"model",rawName:"v-model",value:(_vm.area),expression:"area"}],staticClass:"form-control",class:{'is-invalid':_vm.errors.area},on:{"change":function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.area=$event.target.multiple ? $$selectedVal : $$selectedVal[0];}}},[_c('option',{attrs:{"value":""}}),_vm._v(" "),_vm._l((_vm.areas),function(area){return _c('option',{domProps:{"value":area}},[_vm._v(_vm._s(area.name))])})],2),_vm._v(" "),_c('div',{staticClass:"invalid-feedback"},[_vm._v("\n          "+_vm._s(_vm.errors.area)+"\n        ")])])]),_vm._v(" "),_c('div',{staticClass:"col-md-6"},[_c('div',{staticClass:"form-group"},[_c('label',[_vm._v(_vm._s(_vm._f("t")("")))]),_vm._v(" "),_c('select',{directives:[{name:"model",rawName:"v-model",value:(_vm.district),expression:"district"}],staticClass:"form-control",class:{'is-invalid':_vm.errors.district},on:{"change":function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.district=$event.target.multiple ? $$selectedVal : $$selectedVal[0];}}},[_c('option',{attrs:{"value":""}}),_vm._v(" "),_vm._l((_vm.districts),function(district){return _c('option',{domProps:{"value":district}},[_vm._v("\n            "+_vm._s(district.name)+"\n          ")])})],2),_vm._v(" "),_c('div',{staticClass:"invalid-feedback"},[_vm._v("\n          "+_vm._s(_vm.errors.district)+"\n        ")])])])]),_vm._v(" "),_c('div',{staticClass:"form-group"},[_c('label',[_vm._v(_vm._s(_vm._f("t")("")))]),_vm._v(" "),_c('div',{staticClass:"kt-input-icon"},[_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.address),expression:"address"}],staticClass:"form-control",class:{'is-invalid':_vm.errors.address},attrs:{"placeholder":_vm.t('///'),"required":"","type":"text"},domProps:{"value":(_vm.address)},on:{"input":function($event){if($event.target.composing){ return; }_vm.address=$event.target.value;}}}),_vm._v(" "),_c('div',{staticClass:"invalid-feedback"},[_vm._v("\n        "+_vm._s(_vm.errors.address)+"\n      ")])])]),_vm._v(" "),_c('div',{class:{'is-invalid':_vm.errors.coords&&!_vm.manually}},[_c('div',{staticStyle:{"min-height":"50vh"},attrs:{"id":"map"}}),_vm._v(" "),_c('div',{staticClass:"invalid-feedback"},[_vm._v(_vm._s(_vm.errors.coords))])]),_vm._v(" "),_c('label',{staticClass:"kt-checkbox my-4"},[_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.manually),expression:"manually"}],attrs:{"type":"checkbox"},domProps:{"checked":Array.isArray(_vm.manually)?_vm._i(_vm.manually,null)>-1:(_vm.manually)},on:{"change":function($event){var $$a=_vm.manually,$$el=$event.target,$$c=$$el.checked?(true):(false);if(Array.isArray($$a)){var $$v=null,$$i=_vm._i($$a,$$v);if($$el.checked){$$i<0&&(_vm.manually=$$a.concat([$$v]));}else {$$i>-1&&(_vm.manually=$$a.slice(0,$$i).concat($$a.slice($$i+1)));}}else {_vm.manually=$$c;}}}}),_vm._v(" "+_vm._s(_vm._f("t")("  "))+"\n    "),_c('span')]),_vm._v(" "),_c('transition',{attrs:{"name":"slide"}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.manually),expression:"manually"}],staticClass:"row align-middle form-group",class:{'is-invalid':_vm.errors.coords}},[_c('div',{staticClass:"col-md-6 col-sm-12"},[_c('div',[_c('label',[_vm._v(_vm._s(_vm._f("t")('')))]),_vm._v(" "),_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.coords[0]),expression:"coords[0]"}],staticClass:"form-control",class:{'is-invalid':_vm.errors.coords},attrs:{"disabled":!_vm.manually,"required":"","type":"number"},domProps:{"value":(_vm.coords[0])},on:{"focusout":function($event){return _vm.moveMapCoords(_vm.coords, true)},"input":function($event){if($event.target.composing){ return; }_vm.$set(_vm.coords, 0, $event.target.value);}}})])]),_vm._v(" "),_c('div',{staticClass:"col-md-6 col-sm-12"},[_c('div',[_c('label',[_vm._v(_vm._s(_vm._f("t")('')))]),_vm._v(" "),_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.coords[1]),expression:"coords[1]"}],staticClass:"form-control",class:{'is-invalid':_vm.errors.coords},attrs:{"disabled":!_vm.manually,"required":"","type":"number"},domProps:{"value":(_vm.coords[1])},on:{"focusout":function($event){return _vm.moveMapCoords(_vm.coords, true)},"input":function($event){if($event.target.composing){ return; }_vm.$set(_vm.coords, 1, $event.target.value);}}})])]),_vm._v(" "),_c('div',{staticClass:"col-12 invalid-feedback"},[_vm._v(_vm._s(_vm.errors.coords))])])])],1)};
var __vue_staticRenderFns__$d = [];

/* style */
const __vue_inject_styles__$d = undefined;
/* scoped */
const __vue_scope_id__$d = undefined;
/* functional template */
const __vue_is_functional_template__$d = false;
/* component normalizer */
function __vue_normalize__$d(
    template, style, script,
    scope, functional, moduleIdentifier,
    createInjector, createInjectorSSR
) {
    const component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "Location.vue";

    if (!component.render) {
        component.render = template.render;
        component.staticRenderFns = template.staticRenderFns;
        component._compiled = true;

        if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component
}
/* style inject */

/* style inject SSR */



var LocationForm = __vue_normalize__$d(
    { render: __vue_render__$d, staticRenderFns: __vue_staticRenderFns__$d },
    __vue_inject_styles__$d,
    __vue_script__$d,
    __vue_scope_id__$d,
    __vue_is_functional_template__$d);

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


var script$c = {
    mounted() {
        $(this.$refs.incidentTime).timepicker({
            defaultTime: this.time,
            minuteStep: 5,
            showMeridian: false
        }).on('changeTime.timepicker', e => {
            this.time = e.time.value;
        });
    },
    computed: {
        now(){
            return this.$store.state.details.now
        },
        yesterday: function () {
            return this.now.clone().subtract(1, 'days')
        },
        beforeYesterday: function () {
            return this.now.clone().subtract(2, 'days')
        },
        time: {
            get() {
                return this.$store.state.details.time;
            },
            set(time) {
                this.$store.commit('details/updateTime', time);
            }
        },
        date: {
            get() {
                return this.$store.state.details.date;
            },
            set(date) {
                this.$store.commit('details/updateDate', date);
            }
        },
        errors() {
            return this.$store.state.details.errors;
        }
    }
};

/* script */
const __vue_script__$c = script$c;

/* template */
var __vue_render__$c = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('div',{staticClass:"form-group  validate",class:{'is-invalid': _vm.errors.date}},[_c('label',[_vm._v(_vm._s(_vm._f("t")(' ')))]),_vm._v(" "),_c('div',{staticClass:"row"},[_c('div',{staticClass:"col-lg-4"},[_c('label',{staticClass:"kt-option"},[_c('span',{staticClass:"kt-option__control"},[_c('span',{staticClass:"kt-radio kt-radio--check-bold"},[_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.date),expression:"date"}],class:{'is-invalid': _vm.errors.date},attrs:{"type":"radio"},domProps:{"value":_vm.beforeYesterday,"checked":_vm._q(_vm.date,_vm.beforeYesterday)},on:{"change":function($event){_vm.date=_vm.beforeYesterday;}}}),_vm._v(" "),_c('span')])]),_vm._v(" "),_c('span',{staticClass:"kt-option__label"},[_c('span',{staticClass:"kt-option__head"},[_c('span',{staticClass:"kt-option__title"},[_vm._v("\n                "+_vm._s(_vm._f("t")(''))+"\n              ")])]),_vm._v(" "),_c('span',{staticClass:"kt-option__body pt-1"},[_vm._v(" "+_vm._s(_vm._f("localDateFormat")(_vm.beforeYesterday)))])])])]),_vm._v(" "),_c('div',{staticClass:"col-lg-4"},[_c('label',{staticClass:"kt-option"},[_c('span',{staticClass:"kt-option__control"},[_c('span',{staticClass:"kt-radio kt-radio--check-bold"},[_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.date),expression:"date"}],class:{'is-invalid': _vm.errors.date},attrs:{"type":"radio"},domProps:{"value":_vm.yesterday,"checked":_vm._q(_vm.date,_vm.yesterday)},on:{"change":function($event){_vm.date=_vm.yesterday;}}}),_vm._v(" "),_c('span')])]),_vm._v(" "),_c('span',{staticClass:"kt-option__label"},[_c('span',{staticClass:"kt-option__head"},[_c('span',{staticClass:"kt-option__title"},[_vm._v(_vm._s(_vm._f("t")('')))])]),_vm._v(" "),_c('span',{staticClass:"kt-option__body pt-1"},[_vm._v(" "+_vm._s(_vm._f("localDateFormat")(_vm.yesterday)))])])])]),_vm._v(" "),_c('div',{staticClass:"col-lg-4"},[_c('label',{staticClass:"kt-option"},[_c('span',{staticClass:"kt-option__control"},[_c('span',{staticClass:"kt-radio kt-radio--check-bold"},[_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.date),expression:"date"}],class:{'is-invalid': _vm.errors.date},attrs:{"type":"radio"},domProps:{"value":_vm.now,"checked":_vm._q(_vm.date,_vm.now)},on:{"change":function($event){_vm.date=_vm.now;}}}),_vm._v(" "),_c('span')])]),_vm._v(" "),_c('span',{staticClass:"kt-option__label"},[_c('span',{staticClass:"kt-option__head"},[_c('span',{staticClass:"kt-option__title"},[_vm._v("\n                "+_vm._s(_vm._f("t")(''))+"\n              ")])]),_vm._v(" "),_c('span',{staticClass:"kt-option__body pt-1"},[_vm._v(" "+_vm._s(_vm._f("localDateFormat")(_vm.now)))])])])])]),_vm._v(" "),_c('div',{staticClass:"error invalid-feedback"},[_vm._v(_vm._s(_vm.errors.date))])]),_vm._v(" "),_c('div',{staticClass:"row"},[_c('div',{staticClass:"col-md-4"},[_c('div',{staticClass:"form-group"},[_c('label',[_vm._v(_vm._s(_vm._f("t")(' ')))]),_vm._v(" "),_c('input',{ref:"incidentTime",staticClass:"form-control incidentTime",class:{'is-invalid': _vm.errors.time},attrs:{"required":"","type":"text","placeholder":"14:28"}}),_vm._v(" "),_c('div',{staticClass:"error invalid-feedback"},[_vm._v(_vm._s(_vm.errors.time))])])])])])};
var __vue_staticRenderFns__$c = [];

/* style */
const __vue_inject_styles__$c = undefined;
/* scoped */
const __vue_scope_id__$c = undefined;
/* functional template */
const __vue_is_functional_template__$c = false;
/* component normalizer */
function __vue_normalize__$c(
    template, style, script,
    scope, functional, moduleIdentifier,
    createInjector, createInjectorSSR
) {
    const component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "Time.vue";

    if (!component.render) {
        component.render = template.render;
        component.staticRenderFns = template.staticRenderFns;
        component._compiled = true;

        if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component
}
/* style inject */

/* style inject SSR */



var TimeForm = __vue_normalize__$c(
    { render: __vue_render__$c, staticRenderFns: __vue_staticRenderFns__$c },
    __vue_inject_styles__$c,
    __vue_script__$c,
    __vue_scope_id__$c,
    __vue_is_functional_template__$c);

//
var script$b = {
    components: {LocationForm, TimeForm},
    created() {
        this.areas = window.areas;
    }
};

/* script */
const __vue_script__$b = script$b;

/* template */
var __vue_render__$b = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('LocationForm',{attrs:{"areas":_vm.areas}}),_vm._v(" "),_c('TimeForm')],1)};
var __vue_staticRenderFns__$b = [];

/* style */
const __vue_inject_styles__$b = undefined;
/* scoped */
const __vue_scope_id__$b = undefined;
/* functional template */
const __vue_is_functional_template__$b = false;
/* component normalizer */
function __vue_normalize__$b(
    template, style, script,
    scope, functional, moduleIdentifier,
    createInjector, createInjectorSSR
) {
    const component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "Index.vue";

    if (!component.render) {
        component.render = template.render;
        component.staticRenderFns = template.staticRenderFns;
        component._compiled = true;

        if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component
}
/* style inject */

/* style inject SSR */



var DetailsForm = __vue_normalize__$b(
    { render: __vue_render__$b, staticRenderFns: __vue_staticRenderFns__$b },
    __vue_inject_styles__$b,
    __vue_script__$b,
    __vue_scope_id__$b,
    __vue_is_functional_template__$b);

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var script$a = {
    props: ['error', 'message'],
    data() {
        return {
            dragenter: false
        }
    },

    methods: {
        handleFileDrop(e) {
            this.$emit('change', e.dataTransfer.files[0]);
        },
        handleFileInputChange(e) {
            this.$emit('change', e.target.files[0]);
        }
    }
};

/* script */
const __vue_script__$a = script$a;

/* template */
var __vue_render__$a = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{on:{"drop":function($event){$event.preventDefault();return _vm.handleFileDrop($event)}}},[_c('input',{ref:"file",staticStyle:{"display":"none"},attrs:{"type":"file"},on:{"change":_vm.handleFileInputChange}}),_vm._v(" "),_c('a',{staticClass:"h-100 dropzone kt-label-font-color-3",class:{'is-invalid':_vm.error},on:{"click":function($event){return _vm.$refs.file.click()},"dragenter":function($event){$event.preventDefault();_vm.dragenter=true;},"dragover":function($event){$event.preventDefault();_vm.dragenter=true;},"dragleave":function($event){$event.preventDefault();_vm.dragenter=false;},"drop":function($event){$event.preventDefault();return _vm.handleFileDrop($event)}}},[(_vm.dragenter)?_c('h2',[_vm._v(_vm._s(_vm._f("t")("")))]):_c('div',[_c('h3',[_vm._v(_vm._s(_vm._f("t")("")))]),_vm._v(" "),_c('span',[_vm._v("\n        "+_vm._s(_vm._f("t")("     "))+"\n      ")]),_vm._v(" "),_c('div',{staticClass:"kt-font-warning mt-2"},[_vm._v(_vm._s(_vm.message))]),_vm._v(" "),_c('div',{staticClass:"invalid-feedback"},[_vm._v(_vm._s(_vm.error))])])])])};
var __vue_staticRenderFns__$a = [];

/* style */
const __vue_inject_styles__$a = function (inject) {
    if (!inject) return
    inject("data-v-6e8313ef_0", { source: ".dropzone{display:flex;align-items:center;justify-content:center;background-color:transparent;width:100%;height:100%}.dropzone.is-invalid{border-color:red!important}.dropzone *{pointer-events:none}", map: undefined, media: undefined });

};
/* scoped */
const __vue_scope_id__$a = undefined;
/* module identifier */
const __vue_module_identifier__$4 = undefined;
/* functional template */
const __vue_is_functional_template__$a = false;
/* component normalizer */
function __vue_normalize__$a(
    template, style, script,
    scope, functional, moduleIdentifier,
    createInjector, createInjectorSSR
) {
    const component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "dropzone.vue";

    if (!component.render) {
        component.render = template.render;
        component.staticRenderFns = template.staticRenderFns;
        component._compiled = true;

        if (functional) component.functional = true;
    }

    component._scopeId = scope;

    {
        let hook;
        if (style) {
            hook = function(context) {
                style.call(this, createInjector(context));
            };
        }

        if (hook !== undefined) {
            if (component.functional) {
                // register for functional component in vue file
                const originalRender = component.render;
                component.render = function renderWithStyleInjection(h, context) {
                    hook.call(context);
                    return originalRender(h, context)
                };
            } else {
                // inject component registration as beforeCreate hook
                const existing = component.beforeCreate;
                component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
            }
        }
    }

    return component
}
/* style inject */
function __vue_create_injector__$4() {
    const head = document.head || document.getElementsByTagName('head')[0];
    const styles = __vue_create_injector__$4.styles || (__vue_create_injector__$4.styles = {});
    const isOldIE =
        typeof navigator !== 'undefined' &&
        /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
        if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return // SSR styles are present.

        const group = isOldIE ? css.media || 'default' : id;
        const style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

        if (!style.ids.includes(id)) {
            let code = css.source;
            let index = style.ids.length;

            style.ids.push(id);

            if (css.map) {
                // https://developer.chrome.com/devtools/docs/javascript-debugging
                // this makes source maps inside style tags work properly in Chrome
                code += '\n/*# sourceURL=' + css.map.sources[0] + ' */';
                // http://stackoverflow.com/a/26603875
                code +=
                    '\n/*# sourceMappingURL=data:application/json;base64,' +
                    btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) +
                    ' */';
            }

            if (isOldIE) {
                style.element = style.element || document.querySelector('style[data-group=' + group + ']');
            }

            if (!style.element) {
                const el = style.element = document.createElement('style');
                el.type = 'text/css';

                if (css.media) el.setAttribute('media', css.media);
                if (isOldIE) {
                    el.setAttribute('data-group', group);
                    el.setAttribute('data-next-index', '0');
                }

                head.appendChild(el);
            }

            if (isOldIE) {
                index = parseInt(style.element.getAttribute('data-next-index'));
                style.element.setAttribute('data-next-index', index + 1);
            }

            if (style.element.styleSheet) {
                style.parts.push(code);
                style.element.styleSheet.cssText = style.parts
                    .filter(Boolean)
                    .join('\n');
            } else {
                const textNode = document.createTextNode(code);
                const nodes = style.element.childNodes;
                if (nodes[index]) style.element.removeChild(nodes[index]);
                if (nodes.length) style.element.insertBefore(textNode, nodes[index]);
                else style.element.appendChild(textNode);
            }
        }
    }
}
/* style inject SSR */



var Dropzone = __vue_normalize__$a(
    { render: __vue_render__$a, staticRenderFns: __vue_staticRenderFns__$a },
    __vue_inject_styles__$a,
    __vue_script__$a,
    __vue_scope_id__$a,
    __vue_is_functional_template__$a,
    __vue_module_identifier__$4,
    __vue_create_injector__$4);

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var script$9 = {
    mounted() {
        this.video = this.$refs.video;
        this.player = this.$refs.player;
        this.progressWrapper = this.$refs.progress;
        document.addEventListener('fullscreenchange', () => {
            this.isFullScreen = !this.isFullScreen;
        });
    },

    data() {
        return {
            paused: true,
            duration: 0,
            currentTime: 0,
            isFullScreen: false
        }
    },

    props: {
        url: String,
        downloadUrl: String,
        contentType: String,
    },

    watch: {
        paused: function (paused) {
            if (paused) {
                this.video.pause();
            } else
                this.video.play();
        }
    },

    computed: {
        playBackBarWidth: function () {
            return (this.currentTime / this.duration * 100);
        }
    },

    methods: {
        handleTimeUpdate(e) {
            this.currentTime = e.target.currentTime;
        },

        handleLoadMetaData(e) {
            let video = e.target;
            this.duration = video.duration;
            this.$emit('videoChange', video);
        },

        format_seconds(seconds) {
            seconds = Math.floor(seconds);
            let minutes = Math.floor(seconds / 60);
            seconds = seconds - (minutes * 60);
            if (minutes < 10) {
                minutes = "0" + minutes;
            }
            if (seconds < 10) {
                seconds = "0" + seconds;
            }
            return minutes + ':' + seconds;
        },

        togglePlayerFullscreen() {
            if (this.isFullScreen) {
                document.exitFullscreen();
            } else {
                this.player.requestFullscreen();
            }
        },

        seek(event) {
            let wrapper = this.progressWrapper.getBoundingClientRect();
            let x = event.clientX - wrapper.left;
            let time = x / wrapper.width * this.duration;
            this.currentTime = time;
            this.video.currentTime = time;
        },

        addMoveListener(e) {
            this.progressWrapper.addEventListener('mousemove', this.seek);
        },

        removeListener(e) {
            this.progressWrapper.removeEventListener('mousemove', this.seek);
        }

    }
};

/* script */
const __vue_script__$9 = script$9;

/* template */
var __vue_render__$9 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{ref:"player",staticClass:"player",style:({minHeight:'50vh'}),attrs:{"tabindex":"1"}},[_c('video',{ref:"video",class:{fullscreen:_vm.isFullScreen},attrs:{"crossorigin":"anonymous"},on:{"ended":function($event){_vm.paused=true;},"loadedmetadata":_vm.handleLoadMetaData,"timeupdate":_vm.handleTimeUpdate}},[_c('source',{attrs:{"src":_vm.url,"type":_vm.contentType}})]),_vm._v(" "),_c('div',{staticClass:"player__toolbar"},[_c('button',{staticClass:"player__play",on:{"click":function($event){_vm.paused=!_vm.paused;}}},[(_vm.paused)?_c('img',{staticStyle:{"width":"68%"},attrs:{"alt":"play","src":"/img/play.svg"}}):_c('img',{staticStyle:{"width":"68%"},attrs:{"alt":"pause","src":"/img/pause.svg"}})]),_vm._v(" "),_c('div',{staticClass:"player__track"},[_c('div',{ref:"progress",staticClass:"progress bg-dark",on:{"click":_vm.seek,"mousedown":_vm.addMoveListener,"mouseleave":_vm.removeListener,"mouseup":_vm.removeListener}},[_c('div',{staticClass:"progress-bar bg-white player__progress",style:({width:_vm.playBackBarWidth+'%'})})])]),_vm._v(" "),_c('div',{staticClass:"player__duration"},[_vm._v(_vm._s(_vm.format_seconds(_vm.currentTime)))]),_vm._v(" "),_c('a',{staticClass:"player__download btn",attrs:{"href":_vm.downloadUrl,"download":""}},[_c('img',{attrs:{"alt":"download","src":"/img/download.svg"}})]),_vm._v(" "),_c('button',{staticClass:"player__fullscreen",on:{"click":_vm.togglePlayerFullscreen}},[(_vm.isFullScreen)?_c('img',{staticStyle:{"width":"70%"},attrs:{"alt":"fullscreen","src":"/img/fullscreen_off.svg"}}):_c('img',{staticStyle:{"width":"70%"},attrs:{"alt":"fullscreen","src":"/img/fullscreen_on.svg"}})])])])};
var __vue_staticRenderFns__$9 = [];

/* style */
const __vue_inject_styles__$9 = function (inject) {
    if (!inject) return
    inject("data-v-7938abf4_0", { source: "video:not(.fullscreen){max-height:60vh!important}.progress{position:relative}.player__progress{z-index:999}", map: undefined, media: undefined });

};
/* scoped */
const __vue_scope_id__$9 = undefined;
/* module identifier */
const __vue_module_identifier__$3 = undefined;
/* functional template */
const __vue_is_functional_template__$9 = false;
/* component normalizer */
function __vue_normalize__$9(
    template, style, script,
    scope, functional, moduleIdentifier,
    createInjector, createInjectorSSR
) {
    const component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "player.vue";

    if (!component.render) {
        component.render = template.render;
        component.staticRenderFns = template.staticRenderFns;
        component._compiled = true;

        if (functional) component.functional = true;
    }

    component._scopeId = scope;

    {
        let hook;
        if (style) {
            hook = function(context) {
                style.call(this, createInjector(context));
            };
        }

        if (hook !== undefined) {
            if (component.functional) {
                // register for functional component in vue file
                const originalRender = component.render;
                component.render = function renderWithStyleInjection(h, context) {
                    hook.call(context);
                    return originalRender(h, context)
                };
            } else {
                // inject component registration as beforeCreate hook
                const existing = component.beforeCreate;
                component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
            }
        }
    }

    return component
}
/* style inject */
function __vue_create_injector__$3() {
    const head = document.head || document.getElementsByTagName('head')[0];
    const styles = __vue_create_injector__$3.styles || (__vue_create_injector__$3.styles = {});
    const isOldIE =
        typeof navigator !== 'undefined' &&
        /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
        if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return // SSR styles are present.

        const group = isOldIE ? css.media || 'default' : id;
        const style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

        if (!style.ids.includes(id)) {
            let code = css.source;
            let index = style.ids.length;

            style.ids.push(id);

            if (css.map) {
                // https://developer.chrome.com/devtools/docs/javascript-debugging
                // this makes source maps inside style tags work properly in Chrome
                code += '\n/*# sourceURL=' + css.map.sources[0] + ' */';
                // http://stackoverflow.com/a/26603875
                code +=
                    '\n/*# sourceMappingURL=data:application/json;base64,' +
                    btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) +
                    ' */';
            }

            if (isOldIE) {
                style.element = style.element || document.querySelector('style[data-group=' + group + ']');
            }

            if (!style.element) {
                const el = style.element = document.createElement('style');
                el.type = 'text/css';

                if (css.media) el.setAttribute('media', css.media);
                if (isOldIE) {
                    el.setAttribute('data-group', group);
                    el.setAttribute('data-next-index', '0');
                }

                head.appendChild(el);
            }

            if (isOldIE) {
                index = parseInt(style.element.getAttribute('data-next-index'));
                style.element.setAttribute('data-next-index', index + 1);
            }

            if (style.element.styleSheet) {
                style.parts.push(code);
                style.element.styleSheet.cssText = style.parts
                    .filter(Boolean)
                    .join('\n');
            } else {
                const textNode = document.createTextNode(code);
                const nodes = style.element.childNodes;
                if (nodes[index]) style.element.removeChild(nodes[index]);
                if (nodes.length) style.element.insertBefore(textNode, nodes[index]);
                else style.element.appendChild(textNode);
            }
        }
    }
}
/* style inject SSR */



var Player = __vue_normalize__$9(
    { render: __vue_render__$9, staticRenderFns: __vue_staticRenderFns__$9 },
    __vue_inject_styles__$9,
    __vue_script__$9,
    __vue_scope_id__$9,
    __vue_is_functional_template__$9,
    __vue_module_identifier__$3,
    __vue_create_injector__$3);

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var script$8 = {
    props: ['uploaded', 'filesize'],

    mounted() {
        let uploaded = this.uploaded;
        this.speedCheckInterval = setInterval(() => {
            this.uploadSpeed = (this.uploaded - uploaded);
            uploaded = this.uploaded;
        }, 1000);
    },

    destroyed() {
        clearInterval(this.speedCheckInterval);
    },

    data() {
        return {
            speedCheckInterval: null,
            uploadSpeed: 0
        }
    },

    computed: {
        percentage() {
            return Math.round((this.uploaded / this.filesize) * 100) + '%'
        },

        secondsLeft() {
            return Math.round((this.filesize - this.uploaded) / this.uploadSpeed);
        },
    }
};

/* script */
const __vue_script__$8 = script$8;

/* template */
var __vue_render__$8 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('div',{staticClass:"d-flex justify-content-between"},[_c('div',[_vm._v(_vm._s(_vm._f("humanFileSize")(this.uploadSpeed))+"/s")]),_vm._v(" "),_c('div',[_vm._v(_vm._s(_vm._f("humanRemainingTime")(_vm.secondsLeft)))])]),_vm._v(" "),_c('div',{staticClass:"progress"},[_c('div',{staticClass:"progress-bar progress-bar-striped progress-bar-animated",style:({width: _vm.percentage})})]),_vm._v(" "),_c('h5',{staticClass:"text-center mt-2"},[_vm._v(_vm._s(_vm._f("t")(""))+" "+_vm._s(_vm.percentage))])])};
var __vue_staticRenderFns__$8 = [];

/* style */
const __vue_inject_styles__$8 = undefined;
/* scoped */
const __vue_scope_id__$8 = undefined;
/* functional template */
const __vue_is_functional_template__$8 = false;
/* component normalizer */
function __vue_normalize__$8(
    template, style, script,
    scope, functional, moduleIdentifier,
    createInjector, createInjectorSSR
) {
    const component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "uploadProgress.vue";

    if (!component.render) {
        component.render = template.render;
        component.staticRenderFns = template.staticRenderFns;
        component._compiled = true;

        if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component
}
/* style inject */

/* style inject SSR */



var UploadProgress = __vue_normalize__$8(
    { render: __vue_render__$8, staticRenderFns: __vue_staticRenderFns__$8 },
    __vue_inject_styles__$8,
    __vue_script__$8,
    __vue_scope_id__$8,
    __vue_is_functional_template__$8);

var e=function(){return (e=Object.assign||function(e){for(var t,r=1,s=arguments.length;r<s;r++)for(var a in t=arguments[r])Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a]);return e}).apply(this,arguments)},t$1={kebab:/-(\w)/g,styleProp:/:(.*)/,styleList:/;(?![^(]*\))/g};function r(e,t){return t?t.toUpperCase():""}function s(e){for(var s,a={},c=0,o=e.split(t$1.styleList);c<o.length;c++){var n=o[c].split(t$1.styleProp),i=n[0],l=n[1];(i=i.trim())&&("string"==typeof l&&(l=l.trim()),a[(s=i,s.replace(t$1.kebab,r))]=l);}return a}function a(){for(var t,r,a={},c=arguments.length;c--;)for(var o=0,n=Object.keys(arguments[c]);o<n.length;o++)switch(t=n[o]){case"class":case"style":case"directives":if(Array.isArray(a[t])||(a[t]=[]),"style"===t){var i=void 0;i=Array.isArray(arguments[c].style)?arguments[c].style:[arguments[c].style];for(var l=0;l<i.length;l++){var y=i[l];"string"==typeof y&&(i[l]=s(y));}arguments[c].style=i;}a[t]=a[t].concat(arguments[c][t]);break;case"staticClass":if(!arguments[c][t])break;void 0===a[t]&&(a[t]=""),a[t]&&(a[t]+=" "),a[t]+=arguments[c][t].trim();break;case"on":case"nativeOn":a[t]||(a[t]={});for(var p=0,f=Object.keys(arguments[c][t]||{});p<f.length;p++)r=f[p],a[t][r]?a[t][r]=[].concat(a[t][r],arguments[c][t][r]):a[t][r]=arguments[c][t][r];break;case"attrs":case"props":case"domProps":case"scopedSlots":case"staticStyle":case"hook":case"transition":a[t]||(a[t]={}),a[t]=e({},arguments[c][t],a[t]);break;case"slot":case"key":case"ref":case"tag":case"show":case"keepAlive":default:a[t]||(a[t]=arguments[c][t]);}return a}

var COMPONENT_UID_KEY = '_uid';

var HAS_WINDOW_SUPPORT = typeof window !== 'undefined';
var HAS_DOCUMENT_SUPPORT = typeof document !== 'undefined';
var HAS_NAVIGATOR_SUPPORT = typeof navigator !== 'undefined';
/* istanbul ignore next: JSDOM always returns false */

var HAS_MUTATION_OBSERVER_SUPPORT = typeof MutationObserver !== 'undefined' || typeof WebKitMutationObserver !== 'undefined' || typeof MozMutationObserver !== 'undefined';
var IS_BROWSER = HAS_WINDOW_SUPPORT && HAS_DOCUMENT_SUPPORT && HAS_NAVIGATOR_SUPPORT;
var WINDOW = HAS_WINDOW_SUPPORT ? window : {};
var DOCUMENT = HAS_DOCUMENT_SUPPORT ? document : {};
var NAVIGATOR = HAS_NAVIGATOR_SUPPORT ? navigator : {};
var USER_AGENT = (NAVIGATOR.userAgent || '').toLowerCase();
USER_AGENT.indexOf('jsdom') > 0;
/msie|trident/.test(USER_AGENT); // Determine if the browser supports the option passive for events

var HAS_PASSIVE_EVENT_SUPPORT = function () {
    var passiveEventSupported = false;

    if (IS_BROWSER) {
        try {
            var options = {
                // This function will be called when the browser
                // attempts to access the passive property
                get passive() {
                    /* istanbul ignore next: will never be called in JSDOM */
                    passiveEventSupported = true;
                }

            };
            WINDOW.addEventListener('test', options, options);
            WINDOW.removeEventListener('test', options, options);
        } catch (_unused) {
            /* istanbul ignore next: will never be called in JSDOM */
            passiveEventSupported = false;
        }
    }

    return passiveEventSupported;
}();
/* istanbul ignore next: JSDOM only checks for 'IntersectionObserver' */

IS_BROWSER && 'IntersectionObserver' in WINDOW && 'IntersectionObserverEntry' in WINDOW && // Edge 15 and UC Browser lack support for `isIntersecting`
// but we an use `intersectionRatio > 0` instead
// 'isIntersecting' in window.IntersectionObserverEntry.prototype &&
'intersectionRatio' in WINDOW.IntersectionObserverEntry.prototype;

var PROP_NAME = '$bvConfig';

// --- General ---
var RX_BV_PREFIX = /^(BV?)/;
var RX_HYPHENATE = /\B([A-Z])/g;
var RX_ENCODED_COMMA = /%2C/g;
var RX_ENCODE_REVERSE = /[!'()*]/g;

function _typeof$2(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$2 = function _typeof(obj) { return typeof obj; }; } else { _typeof$2 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$2(obj); }

function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits$1(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$1(subClass, superClass); }

function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf$1(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$1(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$1(this, result); }; }

function _possibleConstructorReturn$1(self, call) { if (call && (_typeof$2(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$1(self); }

function _assertThisInitialized$1(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf$1(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf$1(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct$1()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf$1(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf$1(o, p) { _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$1(o, p); }

function _getPrototypeOf$1(o) { _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$1(o); }
/* istanbul ignore next */

var Element$1 = HAS_WINDOW_SUPPORT ? WINDOW.Element : /*#__PURE__*/function (_Object) {
    _inherits$1(Element, _Object);

    var _super = _createSuper$1(Element);

    function Element() {
        _classCallCheck$2(this, Element);

        return _super.apply(this, arguments);
    }

    return Element;
}( /*#__PURE__*/_wrapNativeSuper(Object));
/* istanbul ignore next */

var HTMLElement = HAS_WINDOW_SUPPORT ? WINDOW.HTMLElement : /*#__PURE__*/function (_Element) {
    _inherits$1(HTMLElement, _Element);

    var _super2 = _createSuper$1(HTMLElement);

    function HTMLElement() {
        _classCallCheck$2(this, HTMLElement);

        return _super2.apply(this, arguments);
    }

    return HTMLElement;
}(Element$1);
/* istanbul ignore next */

var SVGElement = HAS_WINDOW_SUPPORT ? WINDOW.SVGElement : /*#__PURE__*/function (_Element2) {
    _inherits$1(SVGElement, _Element2);

    var _super3 = _createSuper$1(SVGElement);

    function SVGElement() {
        _classCallCheck$2(this, SVGElement);

        return _super3.apply(this, arguments);
    }

    return SVGElement;
}(Element$1);

function _typeof$1(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$1 = function _typeof(obj) { return typeof obj; }; } else { _typeof$1 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$1(obj); }

var toType = function toType(value) {
    return _typeof$1(value);
};
var isUndefined = function isUndefined(value) {
    return value === undefined;
};
var isNull = function isNull(value) {
    return value === null;
};
var isUndefinedOrNull = function isUndefinedOrNull(value) {
    return isUndefined(value) || isNull(value);
};
var isFunction$1 = function isFunction(value) {
    return toType(value) === 'function';
};
var isBoolean = function isBoolean(value) {
    return toType(value) === 'boolean';
};
var isString$1 = function isString(value) {
    return toType(value) === 'string';
};
var isNumber = function isNumber(value) {
    return toType(value) === 'number';
};
var isArray = function isArray(value) {
    return Array.isArray(value);
}; // Quick object check
// This is primarily used to tell Objects from primitive values
// when we know the value is a JSON-compliant type
// Note object could be a complex type like array, Date, etc.

var isObject$1 = function isObject(obj) {
    return obj !== null && _typeof$1(obj) === 'object';
}; // Strict object type check
// Only returns true for plain JavaScript objects

var isPlainObject = function isPlainObject(obj) {
    return Object.prototype.toString.call(obj) === '[object Object]';
};
var isDate = function isDate(value) {
    return value instanceof Date;
};
var isEvent = function isEvent(value) {
    return value instanceof Event;
};

function ownKeys$g(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$g(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$g(Object(source), true).forEach(function (key) { _defineProperty$l(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$g(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty$l(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var assign = function assign() {
    return Object.assign.apply(Object, arguments);
};
var defineProperties = function defineProperties(obj, props) {
    return Object.defineProperties(obj, props);
};
var defineProperty$1 = function defineProperty(obj, prop, descriptor) {
    return Object.defineProperty(obj, prop, descriptor);
};
var keys = function keys(obj) {
    return Object.keys(obj);
}; // --- "Instance" ---

var hasOwnProperty = function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
};
// See: https://gist.github.com/bisubus/2da8af7e801ffd813fab7ac221aa7afc

var pick = function pick(obj, props) {
    return keys(obj).filter(function (key) {
        return props.indexOf(key) !== -1;
    }).reduce(function (result, key) {
        return _objectSpread$g(_objectSpread$g({}, result), {}, _defineProperty$l({}, key, obj[key]));
    }, {});
}; // Return a shallow copy of object with the specified properties omitted
// See: https://gist.github.com/bisubus/2da8af7e801ffd813fab7ac221aa7afc

var omit = function omit(obj, props) {
    return keys(obj).filter(function (key) {
        return props.indexOf(key) === -1;
    }).reduce(function (result, key) {
        return _objectSpread$g(_objectSpread$g({}, result), {}, _defineProperty$l({}, key, obj[key]));
    }, {});
}; // Merges two object deeply together
// See: https://gist.github.com/Salakar/1d7137de9cb8b704e48a

var mergeDeep = function mergeDeep(target, source) {
    if (isObject$1(target) && isObject$1(source)) {
        keys(source).forEach(function (key) {
            if (isObject$1(source[key])) {
                if (!target[key] || !isObject$1(target[key])) {
                    target[key] = source[key];
                }

                mergeDeep(target[key], source[key]);
            } else {
                assign(target, _defineProperty$l({}, key, source[key]));
            }
        });
    }

    return target;
}; // Returns a shallow copy of the object with keys in sorted order

var sortKeys = function sortKeys(obj) {
    return keys(obj).sort().reduce(function (result, key) {
        return _objectSpread$g(_objectSpread$g({}, result), {}, _defineProperty$l({}, key, obj[key]));
    }, {});
}; // Convenience method to create a read-only descriptor

var readonlyDescriptor = function readonlyDescriptor() {
    return {
        enumerable: true,
        configurable: false,
        writable: false
    };
};

function ownKeys$f(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$f(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$f(Object(source), true).forEach(function (key) { _defineProperty$k(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$f(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty$k(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray$2(arr) { return _arrayWithoutHoles$2(arr) || _iterableToArray$2(arr) || _unsupportedIterableToArray$3(arr) || _nonIterableSpread$2(); }

function _nonIterableSpread$2() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray$3(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$3(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }

function _iterableToArray$2(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles$2(arr) { if (Array.isArray(arr)) return _arrayLikeToArray$3(arr); }

function _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
var cloneDeep = function cloneDeep(obj) {
    var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : obj;

    if (isArray(obj)) {
        return obj.reduce(function (result, val) {
            return [].concat(_toConsumableArray$2(result), [cloneDeep(val, val)]);
        }, []);
    }

    if (isPlainObject(obj)) {
        return keys(obj).reduce(function (result, key) {
            return _objectSpread$f(_objectSpread$f({}, result), {}, _defineProperty$k({}, key, cloneDeep(obj[key], obj[key])));
        }, {});
    }

    return defaultValue;
};

var identity = function identity(x) {
    return x;
};

/**
 * Utilities to get information about the current environment
 */
var getEnv = function getEnv(key) {
    var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var env = typeof process !== 'undefined' && process ? process.env || {} : {};

    if (!key) {
        /* istanbul ignore next */
        return env;
    }

    return env[key] || fallback;
};
var getNoWarn = function getNoWarn() {
    return getEnv('BOOTSTRAP_VUE_NO_WARN') || getEnv('NODE_ENV') === 'production';
};

/**
 * Log a warning message to the console with BootstrapVue formatting
 * @param {string} message
 */

var warn = function warn(message)
    /* istanbul ignore next */
{
    var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    if (!getNoWarn()) {
        console.warn("[BootstrapVue warn]: ".concat(source ? "".concat(source, " - ") : '').concat(message));
    }
};
/**
 * Warn when no MutationObserver support is given
 * @param {string} source
 * @returns {boolean} warned
 */

var warnNoMutationObserverSupport = function warnNoMutationObserverSupport(source) {
    /* istanbul ignore else */
    if (HAS_MUTATION_OBSERVER_SUPPORT) {
        return false;
    } else {
        warn("".concat(source, ": Requires MutationObserver support."));
        return true;
    }
};

// Component names
var NAME_BUTTON = 'BButton';
var NAME_DROPDOWN = 'BDropdown';
var NAME_DROPDOWN_ITEM = 'BDropdownItem';
var NAME_LINK = 'BLink';
var NAME_MODAL = 'BModal';
var NAME_NAV = 'BNav';
var NAME_NAV_ITEM = 'BNavItem';
var NAME_NAV_ITEM_DROPDOWN = 'BNavItemDropdown';
var NAME_TAB = 'BTab';
var NAME_TABS = 'BTabs';
var NAME_TOOLTIP = 'BTooltip';
var NAME_POPPER = 'BVPopper';
var NAME_TAB_BUTTON_HELPER = 'BVTabButton';
var NAME_TOOLTIP_HELPER = 'BVTooltip';
var NAME_TOOLTIP_TEMPLATE = 'BVTooltipTemplate';
var NAME_TRANSITION = 'BVTransition';

var EVENT_NAME_ACTIVATE_TAB = 'activate-tab';
var EVENT_NAME_CHANGED = 'changed';
var EVENT_NAME_CLICK = 'click';
var EVENT_NAME_CLOSE = 'close';
var EVENT_NAME_DISABLE = 'disable';
var EVENT_NAME_DISABLED = 'disabled';
var EVENT_NAME_ENABLE = 'enable';
var EVENT_NAME_ENABLED = 'enabled';
var EVENT_NAME_FIRST = 'first';
var EVENT_NAME_FOCUSIN = 'focusin';
var EVENT_NAME_FOCUSOUT = 'focusout';
var EVENT_NAME_HIDDEN = 'hidden';
var EVENT_NAME_HIDE = 'hide';
var EVENT_NAME_INPUT = 'input';
var EVENT_NAME_LAST = 'last';
var EVENT_NAME_MOUSEENTER = 'mouseenter';
var EVENT_NAME_MOUSELEAVE = 'mouseleave';
var EVENT_NAME_NEXT = 'next';
var EVENT_NAME_OPEN = 'open';
var EVENT_NAME_PREV = 'prev';
var EVENT_NAME_SHOW = 'show';
var EVENT_NAME_SHOWN = 'shown';
var EVENT_NAME_TOGGLE = 'toggle';
var HOOK_EVENT_NAME_BEFORE_DESTROY = 'hook:beforeDestroy';
var HOOK_EVENT_NAME_DESTROYED = 'hook:destroyed';
var MODEL_EVENT_NAME_PREFIX = 'update:';
var ROOT_EVENT_NAME_PREFIX = 'bv';
var ROOT_EVENT_NAME_SEPARATOR = '::';
var EVENT_OPTIONS_NO_CAPTURE = {
    passive: true,
    capture: false
};

// General types
var PROP_TYPE_ANY = undefined;
var PROP_TYPE_ARRAY = Array;
var PROP_TYPE_BOOLEAN = Boolean;
var PROP_TYPE_FUNCTION = Function;
var PROP_TYPE_NUMBER = Number;
var PROP_TYPE_OBJECT = Object;
var PROP_TYPE_STRING = String; // Multiple types
var PROP_TYPE_ARRAY_OBJECT_STRING = [PROP_TYPE_ARRAY, PROP_TYPE_OBJECT, PROP_TYPE_STRING];
var PROP_TYPE_ARRAY_STRING = [PROP_TYPE_ARRAY, PROP_TYPE_STRING];
var PROP_TYPE_NUMBER_STRING = [PROP_TYPE_NUMBER, PROP_TYPE_STRING];
var PROP_TYPE_NUMBER_OBJECT_STRING = [PROP_TYPE_NUMBER, PROP_TYPE_OBJECT, PROP_TYPE_STRING];
var PROP_TYPE_OBJECT_STRING = [PROP_TYPE_OBJECT, PROP_TYPE_STRING];

var SLOT_NAME_BUTTON_CONTENT = 'button-content';
var SLOT_NAME_DEFAULT = 'default';
var SLOT_NAME_EMPTY = 'empty';
var SLOT_NAME_TABS_END = 'tabs-end';
var SLOT_NAME_TABS_START = 'tabs-start';
var SLOT_NAME_TEXT = 'text';
var SLOT_NAME_TITLE = 'title';

var from = function from() {
    return Array.from.apply(Array, arguments);
}; // --- Instance ---

var arrayIncludes = function arrayIncludes(array, value) {
    return array.indexOf(value) !== -1;
};
var concat = function concat() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
    }

    return Array.prototype.concat.apply([], args);
}; // --- Utilities ---

// Number utilities
// Converts a value (string, number, etc.) to an integer number
// Assumes radix base 10
var toInteger = function toInteger(value) {
    var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NaN;
    var integer = parseInt(value, 10);
    return isNaN(integer) ? defaultValue : integer;
}; // Converts a value (string, number, etc.) to a number

var toFloat = function toFloat(value) {
    var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NaN;
    var float = parseFloat(value);
    return isNaN(float) ? defaultValue : float;
}; // Converts a value (string, number, etc.) to a string

// String utilities
// Converts PascalCase or camelCase to kebab-case

var kebabCase = function kebabCase(str) {
    return str.replace(RX_HYPHENATE, '-$1').toLowerCase();
}; // Converts a kebab-case or camelCase string to PascalCase
// `undefined`/`null` will be converted to `''`
// Plain objects and arrays will be JSON stringified

var toString = function toString(val) {
    var spaces = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
    return isUndefinedOrNull(val) ? '' : isArray(val) || isPlainObject(val) && val.toString === Object.prototype.toString ? JSON.stringify(val, null, spaces) : String(val);
}; // Remove leading white space from a string

var ELEMENT_PROTO = Element$1.prototype;
// See: https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill

/* istanbul ignore next */

var matchesEl = ELEMENT_PROTO.matches || ELEMENT_PROTO.msMatchesSelector || ELEMENT_PROTO.webkitMatchesSelector; // See: https://developer.mozilla.org/en-US/docs/Web/API/Element/closest

/* istanbul ignore next */

var closestEl = ELEMENT_PROTO.closest || function (sel) {
    var el = this;

    do {
        // Use our "patched" matches function
        if (matches(el, sel)) {
            return el;
        }

        el = el.parentElement || el.parentNode;
    } while (!isNull(el) && el.nodeType === Node.ELEMENT_NODE);

    return null;
}; // `requestAnimationFrame()` convenience method

/* istanbul ignore next: JSDOM always returns the first option */

var requestAF = WINDOW.requestAnimationFrame || WINDOW.webkitRequestAnimationFrame || WINDOW.mozRequestAnimationFrame || WINDOW.msRequestAnimationFrame || WINDOW.oRequestAnimationFrame || // Fallback, but not a true polyfill
    // Only needed for Opera Mini

    /* istanbul ignore next */
    function (cb) {
        return setTimeout(cb, 16);
    };
var MutationObs = WINDOW.MutationObserver || WINDOW.WebKitMutationObserver || WINDOW.MozMutationObserver || null; // --- Utils ---

var isElement = function isElement(el) {
    return !!(el && el.nodeType === Node.ELEMENT_NODE);
}; // Get the currently active HTML element

var getActiveElement = function getActiveElement() {
    var excludes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var activeElement = DOCUMENT.activeElement;
    return activeElement && !excludes.some(function (el) {
        return el === activeElement;
    }) ? activeElement : null;
}; // Returns `true` if a tag's name equals `name`

var isTag = function isTag(tag, name) {
    return toString(tag).toLowerCase() === toString(name).toLowerCase();
}; // Determine if an HTML element is the currently active element

var isActiveElement = function isActiveElement(el) {
    return isElement(el) && el === getActiveElement();
}; // Determine if an HTML element is visible - Faster than CSS check

var isVisible = function isVisible(el) {
    if (!isElement(el) || !el.parentNode || !contains(DOCUMENT.body, el)) {
        // Note this can fail for shadow dom elements since they
        // are not a direct descendant of document.body
        return false;
    }

    if (getStyle(el, 'display') === 'none') {
        // We do this check to help with vue-test-utils when using v-show

        /* istanbul ignore next */
        return false;
    } // All browsers support getBoundingClientRect(), except JSDOM as it returns all 0's for values :(
    // So any tests that need isVisible will fail in JSDOM
    // Except when we override the getBCR prototype in some tests


    var bcr = getBCR(el);
    return !!(bcr && bcr.height > 0 && bcr.width > 0);
}; // Determine if an element is disabled

var isDisabled = function isDisabled(el) {
    return !isElement(el) || el.disabled || hasAttr(el, 'disabled') || hasClass(el, 'disabled');
}; // Cause/wait-for an element to reflow its content (adjusting its height/width)

var selectAll = function selectAll(selector, root) {
    return from((isElement(root) ? root : DOCUMENT).querySelectorAll(selector));
}; // Select a single element, returns `null` if not found

var select = function select(selector, root) {
    return (isElement(root) ? root : DOCUMENT).querySelector(selector) || null;
}; // Determine if an element matches a selector

var matches = function matches(el, selector) {
    return isElement(el) ? matchesEl.call(el, selector) : false;
}; // Finds closest element matching selector. Returns `null` if not found

var closest = function closest(selector, root) {
    var includeRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (!isElement(root)) {
        return null;
    }

    var el = closestEl.call(root, selector); // Native closest behaviour when `includeRoot` is truthy,
    // else emulate jQuery closest and return `null` if match is
    // the passed in root element when `includeRoot` is falsey

    return includeRoot ? el : el === root ? null : el;
}; // Returns true if the parent element contains the child element

var contains = function contains(parent, child) {
    return parent && isFunction$1(parent.contains) ? parent.contains(child) : false;
}; // Get an element given an ID

var getById = function getById(id) {
    return DOCUMENT.getElementById(/^#/.test(id) ? id.slice(1) : id) || null;
}; // Add a class to an element

var addClass = function addClass(el, className) {
    // We are checking for `el.classList` existence here since IE 11
    // returns `undefined` for some elements (e.g. SVG elements)
    // See https://github.com/bootstrap-vue/bootstrap-vue/issues/2713
    if (className && isElement(el) && el.classList) {
        el.classList.add(className);
    }
}; // Remove a class from an element

var removeClass = function removeClass(el, className) {
    // We are checking for `el.classList` existence here since IE 11
    // returns `undefined` for some elements (e.g. SVG elements)
    // See https://github.com/bootstrap-vue/bootstrap-vue/issues/2713
    if (className && isElement(el) && el.classList) {
        el.classList.remove(className);
    }
}; // Test if an element has a class

var hasClass = function hasClass(el, className) {
    // We are checking for `el.classList` existence here since IE 11
    // returns `undefined` for some elements (e.g. SVG elements)
    // See https://github.com/bootstrap-vue/bootstrap-vue/issues/2713
    if (className && isElement(el) && el.classList) {
        return el.classList.contains(className);
    }

    return false;
}; // Set an attribute on an element

var setAttr = function setAttr(el, attr, value) {
    if (attr && isElement(el)) {
        el.setAttribute(attr, value);
    }
}; // Remove an attribute from an element

var removeAttr = function removeAttr(el, attr) {
    if (attr && isElement(el)) {
        el.removeAttribute(attr);
    }
}; // Get an attribute value from an element
// Returns `null` if not found

var getAttr = function getAttr(el, attr) {
    return attr && isElement(el) ? el.getAttribute(attr) : null;
}; // Determine if an attribute exists on an element
// Returns `true` or `false`, or `null` if element not found

var hasAttr = function hasAttr(el, attr) {
    return attr && isElement(el) ? el.hasAttribute(attr) : null;
}; // Set an style property on an element
// Returns `null` if not found

var getStyle = function getStyle(el, prop) {
    return prop && isElement(el) ? el.style[prop] || null : null;
}; // Return the Bounding Client Rect of an element
// Returns `null` if not an element

/* istanbul ignore next: getBoundingClientRect() doesn't work in JSDOM */

var getBCR = function getBCR(el) {
    return isElement(el) ? el.getBoundingClientRect() : null;
}; // Get computed style object for an element

/* istanbul ignore next: getComputedStyle() doesn't work in JSDOM */

var getCS = function getCS(el) {
    var getComputedStyle = WINDOW.getComputedStyle;
    return getComputedStyle && isElement(el) ? getComputedStyle(el) : {};
}; // Returns a `Selection` object representing the range of text selected

var attemptFocus = function attemptFocus(el) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    try {
        el.focus(options);
    } catch (_unused) {}

    return isActiveElement(el);
}; // Attempt to blur an element, and return `true` if successful

var attemptBlur = function attemptBlur(el) {
    try {
        el.blur();
    } catch (_unused2) {}

    return !isActiveElement(el);
};

var VueProto = Vue$1.prototype; // --- Getter methods ---

var getConfigValue = function getConfigValue(key) {
    var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
    var bvConfig = VueProto[PROP_NAME];
    return bvConfig ? bvConfig.getConfigValue(key, defaultValue) : cloneDeep(defaultValue);
}; // Method to grab a config value for a particular component

var getComponentConfig = function getComponentConfig(key) {
    var propKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
    // Return the particular config value for key if specified,
    // otherwise we return the full config (or an empty object if not found)
    return propKey ? getConfigValue("".concat(key, ".").concat(propKey), defaultValue) : getConfigValue(key, {});
}; // Get all breakpoint names

function ownKeys$e(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$e(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$e(Object(source), true).forEach(function (key) { _defineProperty$j(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$e(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty$j(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var makeProp = function makeProp() {
    var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : PROP_TYPE_ANY;
    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
    var requiredOrValidator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
    var validator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;
    var required = requiredOrValidator === true;
    validator = required ? validator : requiredOrValidator;
    return _objectSpread$e(_objectSpread$e(_objectSpread$e({}, type ? {
        type: type
    } : {}), required ? {
        required: required
    } : isUndefined(value) ? {} : {
        default: isObject$1(value) ? function () {
            return value;
        } : value
    }), isUndefined(validator) ? {} : {
        validator: validator
    });
}; // Copies props from one array/object to a new array/object
// plucks all the values off the target object, returning a new object
// that has props that reference the original prop values

var pluckProps = function pluckProps(keysToPluck, objToPluck) {
    var transformFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity;
    return (isArray(keysToPluck) ? keysToPluck.slice() : keys(keysToPluck)).reduce(function (memo, prop) {
        memo[transformFn(prop)] = objToPluck[prop];
        return memo;
    }, {});
}; // Make a prop object configurable by global configuration
// Replaces the current `default` key of each prop with a `getComponentConfig()`
// call that falls back to the current default value of the prop

var makePropConfigurable = function makePropConfigurable(prop, key, componentKey) {
    return _objectSpread$e(_objectSpread$e({}, cloneDeep(prop)), {}, {
        default: function bvConfigurablePropDefault() {
            var value = getComponentConfig(componentKey, key, prop.default);
            return isFunction$1(value) ? value() : value;
        }
    });
}; // Make a props object configurable by global configuration
// Replaces the current `default` key of each prop with a `getComponentConfig()`
// call that falls back to the current default value of the prop

var makePropsConfigurable = function makePropsConfigurable(props, componentKey) {
    return keys(props).reduce(function (result, key) {
        return _objectSpread$e(_objectSpread$e({}, result), {}, _defineProperty$j({}, key, makePropConfigurable(props[key], key, componentKey)));
    }, {});
}; // Get function name we use in `makePropConfigurable()`
// for the prop default value override to compare
// against in `hasPropFunction()`

makePropConfigurable({}, '', '').default.name; // Detect wether the given value is currently a function

function _defineProperty$i(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var makeModelMixin = function makeModelMixin(prop) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$type = _ref.type,
        type = _ref$type === void 0 ? PROP_TYPE_ANY : _ref$type,
        _ref$defaultValue = _ref.defaultValue,
        defaultValue = _ref$defaultValue === void 0 ? undefined : _ref$defaultValue,
        _ref$validator = _ref.validator,
        validator = _ref$validator === void 0 ? undefined : _ref$validator,
        _ref$event = _ref.event,
        event = _ref$event === void 0 ? EVENT_NAME_INPUT : _ref$event;

    var props = _defineProperty$i({}, prop, makeProp(type, defaultValue, validator)); // @vue/component


    var mixin = Vue$1.extend({
        model: {
            prop: prop,
            event: event
        },
        props: props
    });
    return {
        mixin: mixin,
        props: props,
        prop: prop,
        event: event
    };
};

// In functional components, `slots` is a function so it must be called
// first before passing to the below methods. `scopedSlots` is always an
// object and may be undefined (for Vue < 2.6.x)

/**
 * Returns true if either scoped or unscoped named slot exists
 *
 * @param {String, Array} name or name[]
 * @param {Object} scopedSlots
 * @param {Object} slots
 * @returns {Array|undefined} VNodes
 */

var hasNormalizedSlot = function hasNormalizedSlot(names) {
    var $scopedSlots = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var $slots = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    // Ensure names is an array
    names = concat(names).filter(identity); // Returns true if the either a $scopedSlot or $slot exists with the specified name

    return names.some(function (name) {
        return $scopedSlots[name] || $slots[name];
    });
};
/**
 * Returns VNodes for named slot either scoped or unscoped
 *
 * @param {String, Array} name or name[]
 * @param {String} scope
 * @param {Object} scopedSlots
 * @param {Object} slots
 * @returns {Array|undefined} VNodes
 */

var normalizeSlot = function normalizeSlot(names) {
    var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var $scopedSlots = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var $slots = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    // Ensure names is an array
    names = concat(names).filter(identity);
    var slot;

    for (var i = 0; i < names.length && !slot; i++) {
        var name = names[i];
        slot = $scopedSlots[name] || $slots[name];
    } // Note: in Vue 2.6.x, all named slots are also scoped slots


    return isFunction$1(slot) ? slot(scope) : slot;
};

var normalizeSlotMixin = Vue$1.extend({
    methods: {
        // Returns `true` if the either a `$scopedSlot` or `$slot` exists with the specified name
        // `name` can be a string name or an array of names
        hasNormalizedSlot: function hasNormalizedSlot$1() {
            var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SLOT_NAME_DEFAULT;
            var scopedSlots = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.$scopedSlots;
            var slots = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.$slots;
            return hasNormalizedSlot(name, scopedSlots, slots);
        },
        // Returns an array of rendered VNodes if slot found, otherwise `undefined`
        // `name` can be a string name or an array of names
        normalizeSlot: function normalizeSlot$1() {
            var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SLOT_NAME_DEFAULT;
            var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var scopedSlots = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.$scopedSlots;
            var slots = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.$slots;

            var vNodes = normalizeSlot(name, scope, scopedSlots, slots);

            return vNodes ? concat(vNodes) : vNodes;
        }
    }
});

// Normalize event options based on support of passive option
// Exported only for testing purposes

var parseEventOptions = function parseEventOptions(options) {
    /* istanbul ignore else: can't test in JSDOM, as it supports passive */
    if (HAS_PASSIVE_EVENT_SUPPORT) {
        return isObject$1(options) ? options : {
            capture: !!options || false
        };
    } else {
        // Need to translate to actual Boolean value
        return !!(isObject$1(options) ? options.capture : options);
    }
}; // Attach an event listener to an element

var eventOn = function eventOn(el, eventName, handler, options) {
    if (el && el.addEventListener) {
        el.addEventListener(eventName, handler, parseEventOptions(options));
    }
}; // Remove an event listener from an element

var eventOff = function eventOff(el, eventName, handler, options) {
    if (el && el.removeEventListener) {
        el.removeEventListener(eventName, handler, parseEventOptions(options));
    }
}; // Utility method to add/remove a event listener based on first argument (boolean)
// It passes all other arguments to the `eventOn()` or `eventOff` method

var eventOnOff = function eventOnOff(on) {
    var method = on ? eventOn : eventOff;

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
    }

    method.apply(void 0, args);
}; // Utility method to prevent the default event handling and propagation

var stopEvent = function stopEvent(event) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$preventDefault = _ref.preventDefault,
        preventDefault = _ref$preventDefault === void 0 ? true : _ref$preventDefault,
        _ref$propagation = _ref.propagation,
        propagation = _ref$propagation === void 0 ? true : _ref$propagation,
        _ref$immediatePropaga = _ref.immediatePropagation,
        immediatePropagation = _ref$immediatePropaga === void 0 ? false : _ref$immediatePropaga;

    if (preventDefault) {
        event.preventDefault();
    }

    if (propagation) {
        event.stopPropagation();
    }

    if (immediatePropagation) {
        event.stopImmediatePropagation();
    }
}; // Helper method to convert a component/directive name to a base event name
// `getBaseEventName('BNavigationItem')` => 'navigation-item'
// `getBaseEventName('BVToggle')` => 'toggle'

var getBaseEventName = function getBaseEventName(value) {
    return kebabCase(value.replace(RX_BV_PREFIX, ''));
}; // Get a root event name by component/directive and event name
// `getBaseEventName('BModal', 'show')` => 'bv::modal::show'


var getRootEventName = function getRootEventName(name, eventName) {
    return [ROOT_EVENT_NAME_PREFIX, getBaseEventName(name), eventName].join(ROOT_EVENT_NAME_SEPARATOR);
}; // Get a root action event name by component/directive and action name
// `getRootActionEventName('BModal', 'show')` => 'bv::show::modal'

var getRootActionEventName = function getRootActionEventName(name, actionName) {
    return [ROOT_EVENT_NAME_PREFIX, actionName, getBaseEventName(name)].join(ROOT_EVENT_NAME_SEPARATOR);
};

function ownKeys$d(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$d(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$d(Object(source), true).forEach(function (key) { _defineProperty$h(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$d(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty$h(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var NO_FADE_PROPS = {
    name: '',
    enterClass: '',
    enterActiveClass: '',
    enterToClass: 'show',
    leaveClass: 'show',
    leaveActiveClass: '',
    leaveToClass: ''
};

var FADE_PROPS = _objectSpread$d(_objectSpread$d({}, NO_FADE_PROPS), {}, {
    enterActiveClass: 'fade',
    leaveActiveClass: 'fade'
}); // --- Props ---


var props$e = {
    // Has no effect if `trans-props` provided
    appear: makeProp(PROP_TYPE_BOOLEAN, false),
    // Can be overridden by user supplied `trans-props`
    mode: makeProp(PROP_TYPE_STRING),
    // Only applicable to the built in transition
    // Has no effect if `trans-props` provided
    noFade: makeProp(PROP_TYPE_BOOLEAN, false),
    // For user supplied transitions (if needed)
    transProps: makeProp(PROP_TYPE_OBJECT)
}; // --- Main component ---
// @vue/component

var BVTransition = /*#__PURE__*/Vue$1.extend({
    name: NAME_TRANSITION,
    functional: true,
    props: props$e,
    render: function render(h, _ref) {
        var children = _ref.children,
            data = _ref.data,
            props = _ref.props;
        var transProps = props.transProps;

        if (!isPlainObject(transProps)) {
            transProps = props.noFade ? NO_FADE_PROPS : FADE_PROPS;

            if (props.appear) {
                // Default the appear classes to equal the enter classes
                transProps = _objectSpread$d(_objectSpread$d({}, transProps), {}, {
                    appear: true,
                    appearClass: transProps.enterClass,
                    appearActiveClass: transProps.enterActiveClass,
                    appearToClass: transProps.enterToClass
                });
            }
        }

        transProps = _objectSpread$d(_objectSpread$d({
            mode: props.mode
        }, transProps), {}, {
            // We always need `css` true
            css: true
        });
        return h('transition', // Any transition event listeners will get merged here
            a(data, {
                props: transProps
            }), children);
    }
});

// Math utilty functions
var mathMax = Math.max;

var ANCHOR_TAG = 'a'; // Method to replace reserved chars

var encodeReserveReplacer = function encodeReserveReplacer(c) {
    return '%' + c.charCodeAt(0).toString(16);
}; // Fixed encodeURIComponent which is more conformant to RFC3986:
// - escapes [!'()*]
// - preserve commas


var encode = function encode(str) {
    return encodeURIComponent(toString(str)).replace(RX_ENCODE_REVERSE, encodeReserveReplacer).replace(RX_ENCODED_COMMA, ',');
};
// See: https://github.com/vuejs/vue-router/blob/dev/src/util/query.js

var stringifyQueryObj = function stringifyQueryObj(obj) {
    if (!isPlainObject(obj)) {
        return '';
    }

    var query = keys(obj).map(function (key) {
        var value = obj[key];

        if (isUndefined(value)) {
            return '';
        } else if (isNull(value)) {
            return encode(key);
        } else if (isArray(value)) {
            return value.reduce(function (results, value2) {
                if (isNull(value2)) {
                    results.push(encode(key));
                } else if (!isUndefined(value2)) {
                    // Faster than string interpolation
                    results.push(encode(key) + '=' + encode(value2));
                }

                return results;
            }, []).join('&');
        } // Faster than string interpolation


        return encode(key) + '=' + encode(value);
    })
        /* must check for length, as we only want to filter empty strings, not things that look falsey! */
        .filter(function (x) {
            return x.length > 0;
        }).join('&');
    return query ? "?".concat(query) : '';
};
var isLink$1 = function isLink(props) {
    return !!(props.href || props.to);
};
var isRouterLink = function isRouterLink(tag) {
    return !!(tag && !isTag(tag, 'a'));
};
var computeTag = function computeTag(_ref, thisOrParent) {
    var to = _ref.to,
        disabled = _ref.disabled,
        routerComponentName = _ref.routerComponentName;
    var hasRouter = !!thisOrParent.$router;

    if (!hasRouter || hasRouter && (disabled || !to)) {
        return ANCHOR_TAG;
    } // TODO:
    //   Check registered components for existence of user supplied router link component name
    //   We would need to check PascalCase, kebab-case, and camelCase versions of name:
    //   const name = routerComponentName
    //   const names = [name, PascalCase(name), KebabCase(name), CamelCase(name)]
    //   exists = names.some(name => !!thisOrParent.$options.components[name])
    //   And may want to cache the result for performance or we just let the render fail
    //   if the component is not registered


    return routerComponentName || (thisOrParent.$nuxt ? 'nuxt-link' : 'router-link');
};
var computeRel = function computeRel() {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        target = _ref2.target,
        rel = _ref2.rel;

    return target === '_blank' && isNull(rel) ? 'noopener' : rel || null;
};
var computeHref = function computeHref() {
    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        href = _ref3.href,
        to = _ref3.to;

    var tag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ANCHOR_TAG;
    var fallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '#';
    var toFallback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '/';

    // Return `href` when explicitly provided
    if (href) {
        return href;
    } // We've checked for `$router` in `computeTag()`, so `isRouterLink()` indicates a live router
    // When deferring to Vue Router's `<router-link>`, don't use the `href` attribute at all
    // We return `null`, and then remove `href` from the attributes passed to `<router-link>`


    if (isRouterLink(tag)) {
        return null;
    } // Fallback to `to` prop (if `to` is a string)


    if (isString$1(to)) {
        return to || toFallback;
    } // Fallback to `to.path' + `to.query` + `to.hash` prop (if `to` is an object)


    if (isPlainObject(to) && (to.path || to.query || to.hash)) {
        var path = toString(to.path);
        var query = stringifyQueryObj(to.query);
        var hash = toString(to.hash);
        hash = !hash || hash.charAt(0) === '#' ? hash : "#".concat(hash);
        return "".concat(path).concat(query).concat(hash) || toFallback;
    } // If nothing is provided return the fallback


    return fallback;
};

var CODE_DOWN = 40;
var CODE_END = 35;
var CODE_ENTER = 13;
var CODE_ESC = 27;
var CODE_HOME = 36;
var CODE_LEFT = 37;
var CODE_RIGHT = 39;
var CODE_SPACE = 32;
var CODE_UP = 38;

// Handles when arrays are "sparse" (array.every(...) doesn't handle sparse)

var compareArrays = function compareArrays(a, b) {
    if (a.length !== b.length) {
        return false;
    }

    var equal = true;

    for (var i = 0; equal && i < a.length; i++) {
        equal = looseEqual(a[i], b[i]);
    }

    return equal;
};
/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 * Returns boolean true or false
 */


var looseEqual = function looseEqual(a, b) {
    if (a === b) {
        return true;
    }

    var aValidType = isDate(a);
    var bValidType = isDate(b);

    if (aValidType || bValidType) {
        return aValidType && bValidType ? a.getTime() === b.getTime() : false;
    }

    aValidType = isArray(a);
    bValidType = isArray(b);

    if (aValidType || bValidType) {
        return aValidType && bValidType ? compareArrays(a, b) : false;
    }

    aValidType = isObject$1(a);
    bValidType = isObject$1(b);

    if (aValidType || bValidType) {
        /* istanbul ignore if: this if will probably never be called */
        if (!aValidType || !bValidType) {
            return false;
        }

        var aKeysCount = keys(a).length;
        var bKeysCount = keys(b).length;

        if (aKeysCount !== bKeysCount) {
            return false;
        }

        for (var key in a) {
            var aHasKey = hasOwnProperty(a, key);
            var bHasKey = hasOwnProperty(b, key);

            if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
                return false;
            }
        }
    }

    return String(a) === String(b);
};

function _defineProperty$g(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var isEmpty = function isEmpty(value) {
    return !value || keys(value).length === 0;
};

var makePropWatcher = function makePropWatcher(propName) {
    return {
        handler: function handler(newValue, oldValue) {
            if (looseEqual(newValue, oldValue)) {
                return;
            }

            if (isEmpty(newValue) || isEmpty(oldValue)) {
                this[propName] = cloneDeep(newValue);
                return;
            }

            for (var key in oldValue) {
                if (!hasOwnProperty(newValue, key)) {
                    this.$delete(this.$data[propName], key);
                }
            }

            for (var _key in newValue) {
                this.$set(this.$data[propName], _key, newValue[_key]);
            }
        }
    };
};
var makePropCacheMixin = function makePropCacheMixin(propName, proxyPropName) {
    return Vue$1.extend({
        data: function data() {
            return _defineProperty$g({}, proxyPropName, cloneDeep(this[propName]));
        },
        watch: _defineProperty$g({}, propName, makePropWatcher(proxyPropName))
    });
};

var attrsMixin = makePropCacheMixin('$attrs', 'bvAttrs');

var listenOnRootMixin = Vue$1.extend({
    methods: {
        /**
         * Safely register event listeners on the root Vue node
         * While Vue automatically removes listeners for individual components,
         * when a component registers a listener on root and is destroyed,
         * this orphans a callback because the node is gone,
         * but the root does not clear the callback
         *
         * When registering a `$root` listener, it also registers a listener on
         * the component's `beforeDestroy()` hook to automatically remove the
         * event listener from the `$root` instance
         *
         * @param {string} event
         * @param {function} callback
         */
        listenOnRoot: function listenOnRoot(event, callback) {
            var _this = this;

            this.$root.$on(event, callback);
            this.$on(HOOK_EVENT_NAME_BEFORE_DESTROY, function () {
                _this.$root.$off(event, callback);
            });
        },

        /**
         * Safely register a `$once()` event listener on the root Vue node
         * While Vue automatically removes listeners for individual components,
         * when a component registers a listener on root and is destroyed,
         * this orphans a callback because the node is gone,
         * but the root does not clear the callback
         *
         * When registering a $root listener, it also registers a listener on
         * the component's `beforeDestroy` hook to automatically remove the
         * event listener from the $root instance.
         *
         * @param {string} event
         * @param {function} callback
         */
        listenOnRootOnce: function listenOnRootOnce(event, callback) {
            var _this2 = this;

            this.$root.$once(event, callback);
            this.$on(HOOK_EVENT_NAME_BEFORE_DESTROY, function () {
                _this2.$root.$off(event, callback);
            });
        },

        /**
         * Convenience method for calling `vm.$emit()` on `vm.$root`
         *
         * @param {string} event
         * @param {*} args
         */
        emitOnRoot: function emitOnRoot(event) {
            var _this$$root;

            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
            }

            (_this$$root = this.$root).$emit.apply(_this$$root, [event].concat(args));
        }
    }
});

var listenersMixin = makePropCacheMixin('$listeners', 'bvListeners');

function _toConsumableArray$1(arr) { return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$2(arr) || _nonIterableSpread$1(); }

function _nonIterableSpread$1() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray$2(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$2(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }

function _iterableToArray$1(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles$1(arr) { if (Array.isArray(arr)) return _arrayLikeToArray$2(arr); }

function _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys$c(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$c(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$c(Object(source), true).forEach(function (key) { _defineProperty$f(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$c(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty$f(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ROOT_EVENT_NAME_CLICKED = getRootEventName(NAME_LINK, 'clicked'); // --- Props ---
// `<router-link>` specific props

var routerLinkProps = {
    activeClass: makeProp(PROP_TYPE_STRING),
    append: makeProp(PROP_TYPE_BOOLEAN, false),
    event: makeProp(PROP_TYPE_ARRAY_STRING, EVENT_NAME_CLICK),
    exact: makeProp(PROP_TYPE_BOOLEAN, false),
    exactActiveClass: makeProp(PROP_TYPE_STRING),
    replace: makeProp(PROP_TYPE_BOOLEAN, false),
    routerTag: makeProp(PROP_TYPE_STRING, 'a'),
    to: makeProp(PROP_TYPE_OBJECT_STRING)
}; // `<nuxt-link>` specific props

var nuxtLinkProps = {
    noPrefetch: makeProp(PROP_TYPE_BOOLEAN, false),
    // Must be `null` to fall back to the value defined in the
    // `nuxt.config.js` configuration file for `router.prefetchLinks`
    // We convert `null` to `undefined`, so that Nuxt.js will use the
    // compiled default
    // Vue treats `undefined` as default of `false` for Boolean props,
    // so we must set it as `null` here to be a true tri-state prop
    prefetch: makeProp(PROP_TYPE_BOOLEAN, null)
}; // All `<b-link>` props

var props$d = makePropsConfigurable(sortKeys(_objectSpread$c(_objectSpread$c(_objectSpread$c({}, nuxtLinkProps), routerLinkProps), {}, {
    active: makeProp(PROP_TYPE_BOOLEAN, false),
    disabled: makeProp(PROP_TYPE_BOOLEAN, false),
    href: makeProp(PROP_TYPE_STRING),
    // Must be `null` if no value provided
    rel: makeProp(PROP_TYPE_STRING, null),
    // To support 3rd party router links based on `<router-link>` (i.e. `g-link` for Gridsome)
    // Default is to auto choose between `<router-link>` and `<nuxt-link>`
    // Gridsome doesn't provide a mechanism to auto detect and has caveats
    // such as not supporting FQDN URLs or hash only URLs
    routerComponentName: makeProp(PROP_TYPE_STRING),
    target: makeProp(PROP_TYPE_STRING, '_self')
})), NAME_LINK); // --- Main component ---
// @vue/component

var BLink = /*#__PURE__*/Vue$1.extend({
    name: NAME_LINK,
    // Mixin order is important!
    mixins: [attrsMixin, listenersMixin, listenOnRootMixin, normalizeSlotMixin],
    inheritAttrs: false,
    props: props$d,
    computed: {
        computedTag: function computedTag() {
            // We don't pass `this` as the first arg as we need reactivity of the props
            var to = this.to,
                disabled = this.disabled,
                routerComponentName = this.routerComponentName;
            return computeTag({
                to: to,
                disabled: disabled,
                routerComponentName: routerComponentName
            }, this);
        },
        isRouterLink: function isRouterLink$1() {
            return isRouterLink(this.computedTag);
        },
        computedRel: function computedRel() {
            // We don't pass `this` as the first arg as we need reactivity of the props
            var target = this.target,
                rel = this.rel;
            return computeRel({
                target: target,
                rel: rel
            });
        },
        computedHref: function computedHref() {
            // We don't pass `this` as the first arg as we need reactivity of the props
            var to = this.to,
                href = this.href;
            return computeHref({
                to: to,
                href: href
            }, this.computedTag);
        },
        computedProps: function computedProps() {
            var prefetch = this.prefetch;
            return this.isRouterLink ? _objectSpread$c(_objectSpread$c({}, pluckProps(_objectSpread$c(_objectSpread$c({}, routerLinkProps), nuxtLinkProps), this)), {}, {
                // Coerce `prefetch` value `null` to be `undefined`
                prefetch: isBoolean(prefetch) ? prefetch : undefined,
                // Pass `router-tag` as `tag` prop
                tag: this.routerTag
            }) : {};
        },
        computedAttrs: function computedAttrs() {
            var bvAttrs = this.bvAttrs,
                href = this.computedHref,
                rel = this.computedRel,
                disabled = this.disabled,
                target = this.target,
                routerTag = this.routerTag,
                isRouterLink = this.isRouterLink;
            return _objectSpread$c(_objectSpread$c(_objectSpread$c(_objectSpread$c({}, bvAttrs), href ? {
                href: href
            } : {}), isRouterLink && !isTag(routerTag, 'a') ? {} : {
                rel: rel,
                target: target
            }), {}, {
                tabindex: disabled ? '-1' : isUndefined(bvAttrs.tabindex) ? null : bvAttrs.tabindex,
                'aria-disabled': disabled ? 'true' : null
            });
        },
        computedListeners: function computedListeners() {
            return _objectSpread$c(_objectSpread$c({}, this.bvListeners), {}, {
                // We want to overwrite any click handler since our callback
                // will invoke the user supplied handler(s) if `!this.disabled`
                click: this.onClick
            });
        }
    },
    methods: {
        onClick: function onClick(event) {
            var _arguments = arguments;
            var eventIsEvent = isEvent(event);
            var isRouterLink = this.isRouterLink;
            var suppliedHandler = this.bvListeners.click;

            if (eventIsEvent && this.disabled) {
                // Stop event from bubbling up
                // Kill the event loop attached to this specific `EventTarget`
                // Needed to prevent `vue-router` for doing its thing
                stopEvent(event, {
                    immediatePropagation: true
                });
            } else {
                /* istanbul ignore next: difficult to test, but we know it works */
                if (isRouterLink && event.currentTarget.__vue__) {
                    // Router links do not emit instance `click` events, so we
                    // add in an `$emit('click', event)` on its Vue instance
                    event.currentTarget.__vue__.$emit(EVENT_NAME_CLICK, event);
                } // Call the suppliedHandler(s), if any provided


                concat(suppliedHandler).filter(function (h) {
                    return isFunction$1(h);
                }).forEach(function (handler) {
                    handler.apply(void 0, _toConsumableArray$1(_arguments));
                }); // Emit the global `$root` click event

                this.emitOnRoot(ROOT_EVENT_NAME_CLICKED, event); // TODO: Remove deprecated 'clicked::link' event with next major release

                this.emitOnRoot('clicked::link', event);
            } // Stop scroll-to-top behavior or navigation on
            // regular links when href is just '#'


            if (eventIsEvent && !isRouterLink && this.computedHref === '#') {
                stopEvent(event, {
                    propagation: false
                });
            }
        },
        focus: function focus() {
            attemptFocus(this.$el);
        },
        blur: function blur() {
            attemptBlur(this.$el);
        }
    },
    render: function render(h) {
        var active = this.active,
            disabled = this.disabled;
        return h(this.computedTag, _defineProperty$f({
            class: {
                active: active,
                disabled: disabled
            },
            attrs: this.computedAttrs,
            props: this.computedProps
        }, this.isRouterLink ? 'nativeOn' : 'on', this.computedListeners), this.normalizeSlot());
    }
});

function ownKeys$b(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$b(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$b(Object(source), true).forEach(function (key) { _defineProperty$e(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$b(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty$e(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var linkProps$2 = omit(props$d, ['event', 'routerTag']);
delete linkProps$2.href.default;
delete linkProps$2.to.default;
var props$c = makePropsConfigurable(sortKeys(_objectSpread$b(_objectSpread$b({}, linkProps$2), {}, {
    block: makeProp(PROP_TYPE_BOOLEAN, false),
    disabled: makeProp(PROP_TYPE_BOOLEAN, false),
    pill: makeProp(PROP_TYPE_BOOLEAN, false),
    // Tri-state: `true`, `false` or `null`
    // => On, off, not a toggle
    pressed: makeProp(PROP_TYPE_BOOLEAN, null),
    size: makeProp(PROP_TYPE_STRING),
    squared: makeProp(PROP_TYPE_BOOLEAN, false),
    tag: makeProp(PROP_TYPE_STRING, 'button'),
    type: makeProp(PROP_TYPE_STRING, 'button'),
    variant: makeProp(PROP_TYPE_STRING, 'secondary')
})), NAME_BUTTON); // --- Helper methods ---
// Focus handler for toggle buttons
// Needs class of 'focus' when focused

var handleFocus = function handleFocus(event) {
    if (event.type === 'focusin') {
        addClass(event.target, 'focus');
    } else if (event.type === 'focusout') {
        removeClass(event.target, 'focus');
    }
}; // Is the requested button a link?
// If tag prop is set to `a`, we use a <b-link> to get proper disabled handling


var isLink = function isLink(props) {
    return isLink$1(props) || isTag(props.tag, 'a');
}; // Is the button to be a toggle button?


var isToggle = function isToggle(props) {
    return isBoolean(props.pressed);
}; // Is the button "really" a button?


var isButton = function isButton(props) {
    return !(isLink(props) || props.tag && !isTag(props.tag, 'button'));
}; // Is the requested tag not a button or link?


var isNonStandardTag = function isNonStandardTag(props) {
    return !isLink(props) && !isButton(props);
}; // Compute required classes (non static classes)


var computeClass = function computeClass(props) {
    var _ref;

    return ["btn-".concat(props.variant || 'secondary'), (_ref = {}, _defineProperty$e(_ref, "btn-".concat(props.size), props.size), _defineProperty$e(_ref, 'btn-block', props.block), _defineProperty$e(_ref, 'rounded-pill', props.pill), _defineProperty$e(_ref, 'rounded-0', props.squared && !props.pill), _defineProperty$e(_ref, "disabled", props.disabled), _defineProperty$e(_ref, "active", props.pressed), _ref)];
}; // Compute the link props to pass to b-link (if required)


var computeLinkProps = function computeLinkProps(props) {
    return isLink(props) ? pluckProps(linkProps$2, props) : {};
}; // Compute the attributes for a button


var computeAttrs = function computeAttrs(props, data) {
    var button = isButton(props);
    var link = isLink(props);
    var toggle = isToggle(props);
    var nonStandardTag = isNonStandardTag(props);
    var hashLink = link && props.href === '#';
    var role = data.attrs && data.attrs.role ? data.attrs.role : null;
    var tabindex = data.attrs ? data.attrs.tabindex : null;

    if (nonStandardTag || hashLink) {
        tabindex = '0';
    }

    return {
        // Type only used for "real" buttons
        type: button && !link ? props.type : null,
        // Disabled only set on "real" buttons
        disabled: button ? props.disabled : null,
        // We add a role of button when the tag is not a link or button for ARIA
        // Don't bork any role provided in `data.attrs` when `isLink` or `isButton`
        // Except when link has `href` of `#`
        role: nonStandardTag || hashLink ? 'button' : role,
        // We set the `aria-disabled` state for non-standard tags
        'aria-disabled': nonStandardTag ? String(props.disabled) : null,
        // For toggles, we need to set the pressed state for ARIA
        'aria-pressed': toggle ? String(props.pressed) : null,
        // `autocomplete="off"` is needed in toggle mode to prevent some browsers
        // from remembering the previous setting when using the back button
        autocomplete: toggle ? 'off' : null,
        // `tabindex` is used when the component is not a button
        // Links are tabbable, but don't allow disabled, while non buttons or links
        // are not tabbable, so we mimic that functionality by disabling tabbing
        // when disabled, and adding a `tabindex="0"` to non buttons or non links
        tabindex: props.disabled && !button ? '-1' : tabindex
    };
}; // --- Main component ---
// @vue/component


var BButton = /*#__PURE__*/Vue$1.extend({
    name: NAME_BUTTON,
    functional: true,
    props: props$c,
    render: function render(h, _ref2) {
        var props = _ref2.props,
            data = _ref2.data,
            listeners = _ref2.listeners,
            children = _ref2.children;
        var toggle = isToggle(props);
        var link = isLink(props);
        var nonStandardTag = isNonStandardTag(props);
        var hashLink = link && props.href === '#';
        var on = {
            keydown: function keydown(event) {
                // When the link is a `href="#"` or a non-standard tag (has `role="button"`),
                // we add a keydown handlers for CODE_SPACE/CODE_ENTER

                /* istanbul ignore next */
                if (props.disabled || !(nonStandardTag || hashLink)) {
                    return;
                }

                var keyCode = event.keyCode; // Add CODE_SPACE handler for `href="#"` and CODE_ENTER handler for non-standard tags

                if (keyCode === CODE_SPACE || keyCode === CODE_ENTER && nonStandardTag) {
                    var target = event.currentTarget || event.target;
                    stopEvent(event, {
                        propagation: false
                    });
                    target.click();
                }
            },
            click: function click(event) {
                /* istanbul ignore if: blink/button disabled should handle this */
                if (props.disabled && isEvent(event)) {
                    stopEvent(event);
                } else if (toggle && listeners && listeners['update:pressed']) {
                    // Send `.sync` updates to any "pressed" prop (if `.sync` listeners)
                    // `concat()` will normalize the value to an array without
                    // double wrapping an array value in an array
                    concat(listeners['update:pressed']).forEach(function (fn) {
                        if (isFunction$1(fn)) {
                            fn(!props.pressed);
                        }
                    });
                }
            }
        };

        if (toggle) {
            on.focusin = handleFocus;
            on.focusout = handleFocus;
        }

        var componentData = {
            staticClass: 'btn',
            class: computeClass(props),
            props: computeLinkProps(props),
            attrs: computeAttrs(props, data),
            on: on
        };
        return h(link ? BLink : props.tag, a(data, componentData), children);
    }
});

var htmlOrText = function htmlOrText(innerHTML, textContent) {
    return innerHTML ? {
        innerHTML: innerHTML
    } : textContent ? {
        textContent: textContent
    } : {};
};

// SSR safe client-side ID attribute generation

var props$b = {
    id: makeProp(PROP_TYPE_STRING)
}; // --- Mixin ---
// @vue/component

var idMixin = Vue$1.extend({
    props: props$b,
    data: function data() {
        return {
            localId_: null
        };
    },
    computed: {
        safeId: function safeId() {
            // Computed property that returns a dynamic function for creating the ID
            // Reacts to changes in both `.id` and `.localId_` and regenerates a new function
            var id = this.id || this.localId_; // We return a function that accepts an optional suffix string
            // So this computed prop looks and works like a method
            // but benefits from Vue's computed prop caching

            var fn = function fn(suffix) {
                if (!id) {
                    return null;
                }

                suffix = String(suffix || '').replace(/\s+/g, '_');
                return suffix ? id + '_' + suffix : id;
            };

            return fn;
        }
    },
    mounted: function mounted() {
        var _this = this;

        // `mounted()` only occurs client-side
        this.$nextTick(function () {
            // Update DOM with auto-generated ID after mount
            // to prevent SSR hydration errors
            _this.localId_ = "__BVID__".concat(_this[COMPONENT_UID_KEY]);
        });
    }
});

var noop = function noop() {};

function ownKeys$a(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$a(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$a(Object(source), true).forEach(function (key) { _defineProperty$d(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$a(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty$d(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
/**
 * Observe a DOM element changes, falls back to eventListener mode
 * @param {Element} el The DOM element to observe
 * @param {Function} callback callback to be called on change
 * @param {object} [options={childList: true, subtree: true}] observe options
 * @see https://stackoverflow.com/questions/3219758
 */

var observeDom = function observeDom(el, callback, options)
    /* istanbul ignore next: difficult to test in JSDOM */
{
    // Handle cases where we might be passed a Vue instance
    el = el ? el.$el || el : null; // Early exit when we have no element

    /* istanbul ignore next: difficult to test in JSDOM */

    if (!isElement(el)) {
        return null;
    } // Exit and throw a warning when `MutationObserver` isn't available


    if (warnNoMutationObserverSupport('observeDom')) {
        return null;
    } // Define a new observer


    var obs = new MutationObs(function (mutations) {
        var changed = false; // A mutation can contain several change records, so we loop
        // through them to see what has changed
        // We break out of the loop early if any "significant" change
        // has been detected

        for (var i = 0; i < mutations.length && !changed; i++) {
            // The mutation record
            var mutation = mutations[i]; // Mutation type

            var type = mutation.type; // DOM node (could be any DOM node type - HTMLElement, Text, comment, etc.)

            var target = mutation.target; // Detect whether a change happened based on type and target

            if (type === 'characterData' && target.nodeType === Node.TEXT_NODE) {
                // We ignore nodes that are not TEXT (i.e. comments, etc.)
                // as they don't change layout
                changed = true;
            } else if (type === 'attributes') {
                changed = true;
            } else if (type === 'childList' && (mutation.addedNodes.length > 0 || mutation.removedNodes.length > 0)) {
                // This includes HTMLElement and text nodes being
                // added/removed/re-arranged
                changed = true;
            }
        } // We only call the callback if a change that could affect
        // layout/size truly happened


        if (changed) {
            callback();
        }
    }); // Have the observer observe foo for changes in children, etc

    obs.observe(el, _objectSpread$a({
        childList: true,
        subtree: true
    }, options)); // We return a reference to the observer so that `obs.disconnect()`
    // can be called if necessary
    // To reduce overhead when the root element is hidden

    return obs;
};

/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.16.1
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';

var timeoutDuration = function () {
    var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
    for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
        if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
            return 1;
        }
    }
    return 0;
}();

function microtaskDebounce(fn) {
    var called = false;
    return function () {
        if (called) {
            return;
        }
        called = true;
        window.Promise.resolve().then(function () {
            called = false;
            fn();
        });
    };
}

function taskDebounce(fn) {
    var scheduled = false;
    return function () {
        if (!scheduled) {
            scheduled = true;
            setTimeout(function () {
                scheduled = false;
                fn();
            }, timeoutDuration);
        }
    };
}

var supportsMicroTasks = isBrowser && window.Promise;

/**
 * Create a debounced version of a method, that's asynchronously deferred
 * but called in the minimum time possible.
 *
 * @method
 * @memberof Popper.Utils
 * @argument {Function} fn
 * @returns {Function}
 */
var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction(functionToCheck) {
    var getType = {};
    return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}

/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */
function getStyleComputedProperty(element, property) {
    if (element.nodeType !== 1) {
        return [];
    }
    // NOTE: 1 DOM access here
    var window = element.ownerDocument.defaultView;
    var css = window.getComputedStyle(element, null);
    return property ? css[property] : css;
}

/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */
function getParentNode(element) {
    if (element.nodeName === 'HTML') {
        return element;
    }
    return element.parentNode || element.host;
}

/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */
function getScrollParent(element) {
    // Return body, `getScroll` will take care to get the correct `scrollTop` from it
    if (!element) {
        return document.body;
    }

    switch (element.nodeName) {
        case 'HTML':
        case 'BODY':
            return element.ownerDocument.body;
        case '#document':
            return element.body;
    }

    // Firefox want us to check `-x` and `-y` variations as well

    var _getStyleComputedProp = getStyleComputedProperty(element),
        overflow = _getStyleComputedProp.overflow,
        overflowX = _getStyleComputedProp.overflowX,
        overflowY = _getStyleComputedProp.overflowY;

    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
        return element;
    }

    return getScrollParent(getParentNode(element));
}

/**
 * Returns the reference node of the reference object, or the reference object itself.
 * @method
 * @memberof Popper.Utils
 * @param {Element|Object} reference - the reference element (the popper will be relative to this)
 * @returns {Element} parent
 */
function getReferenceNode(reference) {
    return reference && reference.referenceNode ? reference.referenceNode : reference;
}

var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */
function isIE(version) {
    if (version === 11) {
        return isIE11;
    }
    if (version === 10) {
        return isIE10;
    }
    return isIE11 || isIE10;
}

/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */
function getOffsetParent(element) {
    if (!element) {
        return document.documentElement;
    }

    var noOffsetParent = isIE(10) ? document.body : null;

    // NOTE: 1 DOM access here
    var offsetParent = element.offsetParent || null;
    // Skip hidden elements which don't have an offsetParent
    while (offsetParent === noOffsetParent && element.nextElementSibling) {
        offsetParent = (element = element.nextElementSibling).offsetParent;
    }

    var nodeName = offsetParent && offsetParent.nodeName;

    if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
        return element ? element.ownerDocument.documentElement : document.documentElement;
    }

    // .offsetParent will return the closest TH, TD or TABLE in case
    // no offsetParent is present, I hate this job...
    if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
        return getOffsetParent(offsetParent);
    }

    return offsetParent;
}

function isOffsetContainer(element) {
    var nodeName = element.nodeName;

    if (nodeName === 'BODY') {
        return false;
    }
    return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}

/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */
function getRoot(node) {
    if (node.parentNode !== null) {
        return getRoot(node.parentNode);
    }

    return node;
}

/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */
function findCommonOffsetParent(element1, element2) {
    // This check is needed to avoid errors in case one of the elements isn't defined for any reason
    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
        return document.documentElement;
    }

    // Here we make sure to give as "start" the element that comes first in the DOM
    var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
    var start = order ? element1 : element2;
    var end = order ? element2 : element1;

    // Get common ancestor container
    var range = document.createRange();
    range.setStart(start, 0);
    range.setEnd(end, 0);
    var commonAncestorContainer = range.commonAncestorContainer;

    // Both nodes are inside #document

    if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
        if (isOffsetContainer(commonAncestorContainer)) {
            return commonAncestorContainer;
        }

        return getOffsetParent(commonAncestorContainer);
    }

    // one of the nodes is inside shadowDOM, find which one
    var element1root = getRoot(element1);
    if (element1root.host) {
        return findCommonOffsetParent(element1root.host, element2);
    } else {
        return findCommonOffsetParent(element1, getRoot(element2).host);
    }
}

/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */
function getScroll(element) {
    var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

    var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
    var nodeName = element.nodeName;

    if (nodeName === 'BODY' || nodeName === 'HTML') {
        var html = element.ownerDocument.documentElement;
        var scrollingElement = element.ownerDocument.scrollingElement || html;
        return scrollingElement[upperSide];
    }

    return element[upperSide];
}

/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */
function includeScroll(rect, element) {
    var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    var scrollTop = getScroll(element, 'top');
    var scrollLeft = getScroll(element, 'left');
    var modifier = subtract ? -1 : 1;
    rect.top += scrollTop * modifier;
    rect.bottom += scrollTop * modifier;
    rect.left += scrollLeft * modifier;
    rect.right += scrollLeft * modifier;
    return rect;
}

/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */

function getBordersSize(styles, axis) {
    var sideA = axis === 'x' ? 'Left' : 'Top';
    var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

    return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border' + sideB + 'Width']);
}

function getSize(axis, body, html, computedStyle) {
    return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
}

function getWindowSizes(document) {
    var body = document.body;
    var html = document.documentElement;
    var computedStyle = isIE(10) && getComputedStyle(html);

    return {
        height: getSize('Height', body, html, computedStyle),
        width: getSize('Width', body, html, computedStyle)
    };
}

var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
};

var createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }

    return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
    };
}();





var defineProperty = function (obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }

    return obj;
};

var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
            }
        }
    }

    return target;
};

/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect(offsets) {
    return _extends({}, offsets, {
        right: offsets.left + offsets.width,
        bottom: offsets.top + offsets.height
    });
}

/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */
function getBoundingClientRect(element) {
    var rect = {};

    // IE10 10 FIX: Please, don't ask, the element isn't
    // considered in DOM in some circumstances...
    // This isn't reproducible in IE10 compatibility mode of IE11
    try {
        if (isIE(10)) {
            rect = element.getBoundingClientRect();
            var scrollTop = getScroll(element, 'top');
            var scrollLeft = getScroll(element, 'left');
            rect.top += scrollTop;
            rect.left += scrollLeft;
            rect.bottom += scrollTop;
            rect.right += scrollLeft;
        } else {
            rect = element.getBoundingClientRect();
        }
    } catch (e) {}

    var result = {
        left: rect.left,
        top: rect.top,
        width: rect.right - rect.left,
        height: rect.bottom - rect.top
    };

    // subtract scrollbar size from sizes
    var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
    var width = sizes.width || element.clientWidth || result.width;
    var height = sizes.height || element.clientHeight || result.height;

    var horizScrollbar = element.offsetWidth - width;
    var vertScrollbar = element.offsetHeight - height;

    // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
    // we make this check conditional for performance reasons
    if (horizScrollbar || vertScrollbar) {
        var styles = getStyleComputedProperty(element);
        horizScrollbar -= getBordersSize(styles, 'x');
        vertScrollbar -= getBordersSize(styles, 'y');

        result.width -= horizScrollbar;
        result.height -= vertScrollbar;
    }

    return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
    var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    var isIE10 = isIE(10);
    var isHTML = parent.nodeName === 'HTML';
    var childrenRect = getBoundingClientRect(children);
    var parentRect = getBoundingClientRect(parent);
    var scrollParent = getScrollParent(children);

    var styles = getStyleComputedProperty(parent);
    var borderTopWidth = parseFloat(styles.borderTopWidth);
    var borderLeftWidth = parseFloat(styles.borderLeftWidth);

    // In cases where the parent is fixed, we must ignore negative scroll in offset calc
    if (fixedPosition && isHTML) {
        parentRect.top = Math.max(parentRect.top, 0);
        parentRect.left = Math.max(parentRect.left, 0);
    }
    var offsets = getClientRect({
        top: childrenRect.top - parentRect.top - borderTopWidth,
        left: childrenRect.left - parentRect.left - borderLeftWidth,
        width: childrenRect.width,
        height: childrenRect.height
    });
    offsets.marginTop = 0;
    offsets.marginLeft = 0;

    // Subtract margins of documentElement in case it's being used as parent
    // we do this only on HTML because it's the only element that behaves
    // differently when margins are applied to it. The margins are included in
    // the box of the documentElement, in the other cases not.
    if (!isIE10 && isHTML) {
        var marginTop = parseFloat(styles.marginTop);
        var marginLeft = parseFloat(styles.marginLeft);

        offsets.top -= borderTopWidth - marginTop;
        offsets.bottom -= borderTopWidth - marginTop;
        offsets.left -= borderLeftWidth - marginLeft;
        offsets.right -= borderLeftWidth - marginLeft;

        // Attach marginTop and marginLeft because in some circumstances we may need them
        offsets.marginTop = marginTop;
        offsets.marginLeft = marginLeft;
    }

    if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
        offsets = includeScroll(offsets, parent);
    }

    return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
    var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var html = element.ownerDocument.documentElement;
    var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
    var width = Math.max(html.clientWidth, window.innerWidth || 0);
    var height = Math.max(html.clientHeight, window.innerHeight || 0);

    var scrollTop = !excludeScroll ? getScroll(html) : 0;
    var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

    var offset = {
        top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
        left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
        width: width,
        height: height
    };

    return getClientRect(offset);
}

/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */
function isFixed(element) {
    var nodeName = element.nodeName;
    if (nodeName === 'BODY' || nodeName === 'HTML') {
        return false;
    }
    if (getStyleComputedProperty(element, 'position') === 'fixed') {
        return true;
    }
    var parentNode = getParentNode(element);
    if (!parentNode) {
        return false;
    }
    return isFixed(parentNode);
}

/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */

function getFixedPositionOffsetParent(element) {
    // This check is needed to avoid errors in case one of the elements isn't defined for any reason
    if (!element || !element.parentElement || isIE()) {
        return document.documentElement;
    }
    var el = element.parentElement;
    while (el && getStyleComputedProperty(el, 'transform') === 'none') {
        el = el.parentElement;
    }
    return el || document.documentElement;
}

/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */
function getBoundaries(popper, reference, padding, boundariesElement) {
    var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

    // NOTE: 1 DOM access here

    var boundaries = { top: 0, left: 0 };
    var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));

    // Handle viewport case
    if (boundariesElement === 'viewport') {
        boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
    } else {
        // Handle other cases based on DOM element used as boundaries
        var boundariesNode = void 0;
        if (boundariesElement === 'scrollParent') {
            boundariesNode = getScrollParent(getParentNode(reference));
            if (boundariesNode.nodeName === 'BODY') {
                boundariesNode = popper.ownerDocument.documentElement;
            }
        } else if (boundariesElement === 'window') {
            boundariesNode = popper.ownerDocument.documentElement;
        } else {
            boundariesNode = boundariesElement;
        }

        var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

        // In case of HTML, we need a different computation
        if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
            var _getWindowSizes = getWindowSizes(popper.ownerDocument),
                height = _getWindowSizes.height,
                width = _getWindowSizes.width;

            boundaries.top += offsets.top - offsets.marginTop;
            boundaries.bottom = height + offsets.top;
            boundaries.left += offsets.left - offsets.marginLeft;
            boundaries.right = width + offsets.left;
        } else {
            // for all the other DOM elements, this one is good
            boundaries = offsets;
        }
    }

    // Add paddings
    padding = padding || 0;
    var isPaddingNumber = typeof padding === 'number';
    boundaries.left += isPaddingNumber ? padding : padding.left || 0;
    boundaries.top += isPaddingNumber ? padding : padding.top || 0;
    boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
    boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;

    return boundaries;
}

function getArea(_ref) {
    var width = _ref.width,
        height = _ref.height;

    return width * height;
}

/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
    var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

    if (placement.indexOf('auto') === -1) {
        return placement;
    }

    var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

    var rects = {
        top: {
            width: boundaries.width,
            height: refRect.top - boundaries.top
        },
        right: {
            width: boundaries.right - refRect.right,
            height: boundaries.height
        },
        bottom: {
            width: boundaries.width,
            height: boundaries.bottom - refRect.bottom
        },
        left: {
            width: refRect.left - boundaries.left,
            height: boundaries.height
        }
    };

    var sortedAreas = Object.keys(rects).map(function (key) {
        return _extends({
            key: key
        }, rects[key], {
            area: getArea(rects[key])
        });
    }).sort(function (a, b) {
        return b.area - a.area;
    });

    var filteredAreas = sortedAreas.filter(function (_ref2) {
        var width = _ref2.width,
            height = _ref2.height;
        return width >= popper.clientWidth && height >= popper.clientHeight;
    });

    var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

    var variation = placement.split('-')[1];

    return computedPlacement + (variation ? '-' + variation : '');
}

/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */
function getReferenceOffsets(state, popper, reference) {
    var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
    return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}

/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */
function getOuterSizes(element) {
    var window = element.ownerDocument.defaultView;
    var styles = window.getComputedStyle(element);
    var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
    var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
    var result = {
        width: element.offsetWidth + y,
        height: element.offsetHeight + x
    };
    return result;
}

/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */
function getOppositePlacement(placement) {
    var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
    return placement.replace(/left|right|bottom|top/g, function (matched) {
        return hash[matched];
    });
}

/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */
function getPopperOffsets(popper, referenceOffsets, placement) {
    placement = placement.split('-')[0];

    // Get popper node sizes
    var popperRect = getOuterSizes(popper);

    // Add position, width and height to our offsets object
    var popperOffsets = {
        width: popperRect.width,
        height: popperRect.height
    };

    // depending by the popper placement we have to compute its offsets slightly differently
    var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
    var mainSide = isHoriz ? 'top' : 'left';
    var secondarySide = isHoriz ? 'left' : 'top';
    var measurement = isHoriz ? 'height' : 'width';
    var secondaryMeasurement = !isHoriz ? 'height' : 'width';

    popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
    if (placement === secondarySide) {
        popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
    } else {
        popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
    }

    return popperOffsets;
}

/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function find(arr, check) {
    // use native find if supported
    if (Array.prototype.find) {
        return arr.find(check);
    }

    // use `filter` to obtain the same behavior of `find`
    return arr.filter(check)[0];
}

/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function findIndex(arr, prop, value) {
    // use native findIndex if supported
    if (Array.prototype.findIndex) {
        return arr.findIndex(function (cur) {
            return cur[prop] === value;
        });
    }

    // use `find` + `indexOf` if `findIndex` isn't supported
    var match = find(arr, function (obj) {
        return obj[prop] === value;
    });
    return arr.indexOf(match);
}

/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */
function runModifiers(modifiers, data, ends) {
    var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

    modifiersToRun.forEach(function (modifier) {
        if (modifier['function']) {
            // eslint-disable-line dot-notation
            console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
        }
        var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
        if (modifier.enabled && isFunction(fn)) {
            // Add properties to offsets to make them a complete clientRect object
            // we do this before each modifier to make sure the previous one doesn't
            // mess with these values
            data.offsets.popper = getClientRect(data.offsets.popper);
            data.offsets.reference = getClientRect(data.offsets.reference);

            data = fn(data, modifier);
        }
    });

    return data;
}

/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */
function update() {
    // if popper is destroyed, don't perform any further update
    if (this.state.isDestroyed) {
        return;
    }

    var data = {
        instance: this,
        styles: {},
        arrowStyles: {},
        attributes: {},
        flipped: false,
        offsets: {}
    };

    // compute reference element offsets
    data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

    // compute auto placement, store placement inside the data object,
    // modifiers will be able to edit `placement` if needed
    // and refer to originalPlacement to know the original value
    data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

    // store the computed placement inside `originalPlacement`
    data.originalPlacement = data.placement;

    data.positionFixed = this.options.positionFixed;

    // compute the popper offsets
    data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);

    data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

    // run the modifiers
    data = runModifiers(this.modifiers, data);

    // the first `update` will call `onCreate` callback
    // the other ones will call `onUpdate` callback
    if (!this.state.isCreated) {
        this.state.isCreated = true;
        this.options.onCreate(data);
    } else {
        this.options.onUpdate(data);
    }
}

/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */
function isModifierEnabled(modifiers, modifierName) {
    return modifiers.some(function (_ref) {
        var name = _ref.name,
            enabled = _ref.enabled;
        return enabled && name === modifierName;
    });
}

/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */
function getSupportedPropertyName(property) {
    var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
    var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

    for (var i = 0; i < prefixes.length; i++) {
        var prefix = prefixes[i];
        var toCheck = prefix ? '' + prefix + upperProp : property;
        if (typeof document.body.style[toCheck] !== 'undefined') {
            return toCheck;
        }
    }
    return null;
}

/**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */
function destroy() {
    this.state.isDestroyed = true;

    // touch DOM only if `applyStyle` modifier is enabled
    if (isModifierEnabled(this.modifiers, 'applyStyle')) {
        this.popper.removeAttribute('x-placement');
        this.popper.style.position = '';
        this.popper.style.top = '';
        this.popper.style.left = '';
        this.popper.style.right = '';
        this.popper.style.bottom = '';
        this.popper.style.willChange = '';
        this.popper.style[getSupportedPropertyName('transform')] = '';
    }

    this.disableEventListeners();

    // remove the popper if user explicitly asked for the deletion on destroy
    // do not use `remove` because IE11 doesn't support it
    if (this.options.removeOnDestroy) {
        this.popper.parentNode.removeChild(this.popper);
    }
    return this;
}

/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */
function getWindow(element) {
    var ownerDocument = element.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView : window;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
    var isBody = scrollParent.nodeName === 'BODY';
    var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
    target.addEventListener(event, callback, { passive: true });

    if (!isBody) {
        attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
    }
    scrollParents.push(target);
}

/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function setupEventListeners(reference, options, state, updateBound) {
    // Resize event listener on window
    state.updateBound = updateBound;
    getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

    // Scroll event listener on scroll parents
    var scrollElement = getScrollParent(reference);
    attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
    state.scrollElement = scrollElement;
    state.eventsEnabled = true;

    return state;
}

/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */
function enableEventListeners() {
    if (!this.state.eventsEnabled) {
        this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
    }
}

/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function removeEventListeners(reference, state) {
    // Remove resize event listener on window
    getWindow(reference).removeEventListener('resize', state.updateBound);

    // Remove scroll event listener on scroll parents
    state.scrollParents.forEach(function (target) {
        target.removeEventListener('scroll', state.updateBound);
    });

    // Reset state
    state.updateBound = null;
    state.scrollParents = [];
    state.scrollElement = null;
    state.eventsEnabled = false;
    return state;
}

/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */
function disableEventListeners() {
    if (this.state.eventsEnabled) {
        cancelAnimationFrame(this.scheduleUpdate);
        this.state = removeEventListeners(this.reference, this.state);
    }
}

/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */
function isNumeric(n) {
    return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}

/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setStyles(element, styles) {
    Object.keys(styles).forEach(function (prop) {
        var unit = '';
        // add unit if the value is numeric and is one of the following
        if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
            unit = 'px';
        }
        element.style[prop] = styles[prop] + unit;
    });
}

/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setAttributes(element, attributes) {
    Object.keys(attributes).forEach(function (prop) {
        var value = attributes[prop];
        if (value !== false) {
            element.setAttribute(prop, attributes[prop]);
        } else {
            element.removeAttribute(prop);
        }
    });
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */
function applyStyle(data) {
    // any property present in `data.styles` will be applied to the popper,
    // in this way we can make the 3rd party modifiers add custom styles to it
    // Be aware, modifiers could override the properties defined in the previous
    // lines of this modifier!
    setStyles(data.instance.popper, data.styles);

    // any property present in `data.attributes` will be applied to the popper,
    // they will be set as HTML attributes of the element
    setAttributes(data.instance.popper, data.attributes);

    // if arrowElement is defined and arrowStyles has some properties
    if (data.arrowElement && Object.keys(data.arrowStyles).length) {
        setStyles(data.arrowElement, data.arrowStyles);
    }

    return data;
}

/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
    // compute reference element offsets
    var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

    // compute auto placement, store placement inside the data object,
    // modifiers will be able to edit `placement` if needed
    // and refer to originalPlacement to know the original value
    var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

    popper.setAttribute('x-placement', placement);

    // Apply `position` to popper before anything else because
    // without the position applied we can't guarantee correct computations
    setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });

    return options;
}

/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */
function getRoundedOffsets(data, shouldRound) {
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
    var round = Math.round,
        floor = Math.floor;

    var noRound = function noRound(v) {
        return v;
    };

    var referenceWidth = round(reference.width);
    var popperWidth = round(popper.width);

    var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
    var isVariation = data.placement.indexOf('-') !== -1;
    var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
    var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;

    var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
    var verticalToInteger = !shouldRound ? noRound : round;

    return {
        left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
        top: verticalToInteger(popper.top),
        bottom: verticalToInteger(popper.bottom),
        right: horizontalToInteger(popper.right)
    };
}

var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeStyle(data, options) {
    var x = options.x,
        y = options.y;
    var popper = data.offsets.popper;

    // Remove this legacy support in Popper.js v2

    var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
        return modifier.name === 'applyStyle';
    }).gpuAcceleration;
    if (legacyGpuAccelerationOption !== undefined) {
        console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
    }
    var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

    var offsetParent = getOffsetParent(data.instance.popper);
    var offsetParentRect = getBoundingClientRect(offsetParent);

    // Styles
    var styles = {
        position: popper.position
    };

    var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);

    var sideA = x === 'bottom' ? 'top' : 'bottom';
    var sideB = y === 'right' ? 'left' : 'right';

    // if gpuAcceleration is set to `true` and transform is supported,
    //  we use `translate3d` to apply the position to the popper we
    // automatically use the supported prefixed version if needed
    var prefixedProperty = getSupportedPropertyName('transform');

    // now, let's make a step back and look at this code closely (wtf?)
    // If the content of the popper grows once it's been positioned, it
    // may happen that the popper gets misplaced because of the new content
    // overflowing its reference element
    // To avoid this problem, we provide two options (x and y), which allow
    // the consumer to define the offset origin.
    // If we position a popper on top of a reference element, we can set
    // `x` to `top` to make the popper grow towards its top instead of
    // its bottom.
    var left = void 0,
        top = void 0;
    if (sideA === 'bottom') {
        // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
        // and not the bottom of the html element
        if (offsetParent.nodeName === 'HTML') {
            top = -offsetParent.clientHeight + offsets.bottom;
        } else {
            top = -offsetParentRect.height + offsets.bottom;
        }
    } else {
        top = offsets.top;
    }
    if (sideB === 'right') {
        if (offsetParent.nodeName === 'HTML') {
            left = -offsetParent.clientWidth + offsets.right;
        } else {
            left = -offsetParentRect.width + offsets.right;
        }
    } else {
        left = offsets.left;
    }
    if (gpuAcceleration && prefixedProperty) {
        styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
        styles[sideA] = 0;
        styles[sideB] = 0;
        styles.willChange = 'transform';
    } else {
        // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
        var invertTop = sideA === 'bottom' ? -1 : 1;
        var invertLeft = sideB === 'right' ? -1 : 1;
        styles[sideA] = top * invertTop;
        styles[sideB] = left * invertLeft;
        styles.willChange = sideA + ', ' + sideB;
    }

    // Attributes
    var attributes = {
        'x-placement': data.placement
    };

    // Update `data` attributes, styles and arrowStyles
    data.attributes = _extends({}, attributes, data.attributes);
    data.styles = _extends({}, styles, data.styles);
    data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

    return data;
}

/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */
function isModifierRequired(modifiers, requestingName, requestedName) {
    var requesting = find(modifiers, function (_ref) {
        var name = _ref.name;
        return name === requestingName;
    });

    var isRequired = !!requesting && modifiers.some(function (modifier) {
        return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
    });

    if (!isRequired) {
        var _requesting = '`' + requestingName + '`';
        var requested = '`' + requestedName + '`';
        console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
    }
    return isRequired;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function arrow(data, options) {
    var _data$offsets$arrow;

    // arrow depends on keepTogether in order to work
    if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
        return data;
    }

    var arrowElement = options.element;

    // if arrowElement is a string, suppose it's a CSS selector
    if (typeof arrowElement === 'string') {
        arrowElement = data.instance.popper.querySelector(arrowElement);

        // if arrowElement is not found, don't run the modifier
        if (!arrowElement) {
            return data;
        }
    } else {
        // if the arrowElement isn't a query selector we must check that the
        // provided DOM node is child of its popper node
        if (!data.instance.popper.contains(arrowElement)) {
            console.warn('WARNING: `arrow.element` must be child of its popper element!');
            return data;
        }
    }

    var placement = data.placement.split('-')[0];
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;

    var isVertical = ['left', 'right'].indexOf(placement) !== -1;

    var len = isVertical ? 'height' : 'width';
    var sideCapitalized = isVertical ? 'Top' : 'Left';
    var side = sideCapitalized.toLowerCase();
    var altSide = isVertical ? 'left' : 'top';
    var opSide = isVertical ? 'bottom' : 'right';
    var arrowElementSize = getOuterSizes(arrowElement)[len];

    //
    // extends keepTogether behavior making sure the popper and its
    // reference have enough pixels in conjunction
    //

    // top/left side
    if (reference[opSide] - arrowElementSize < popper[side]) {
        data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
    }
    // bottom/right side
    if (reference[side] + arrowElementSize > popper[opSide]) {
        data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
    }
    data.offsets.popper = getClientRect(data.offsets.popper);

    // compute center of the popper
    var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

    // Compute the sideValue using the updated popper offsets
    // take popper margin in account because we don't have this info available
    var css = getStyleComputedProperty(data.instance.popper);
    var popperMarginSide = parseFloat(css['margin' + sideCapitalized]);
    var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width']);
    var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

    // prevent arrowElement from being placed not contiguously to its popper
    sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

    data.arrowElement = arrowElement;
    data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

    return data;
}

/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */
function getOppositeVariation(variation) {
    if (variation === 'end') {
        return 'start';
    } else if (variation === 'start') {
        return 'end';
    }
    return variation;
}

/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */
var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

// Get rid of `auto` `auto-start` and `auto-end`
var validPlacements = placements.slice(3);

/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise(placement) {
    var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var index = validPlacements.indexOf(placement);
    var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
    return counter ? arr.reverse() : arr;
}

var BEHAVIORS = {
    FLIP: 'flip',
    CLOCKWISE: 'clockwise',
    COUNTERCLOCKWISE: 'counterclockwise'
};

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function flip(data, options) {
    // if `inner` modifier is enabled, we can't use the `flip` modifier
    if (isModifierEnabled(data.instance.modifiers, 'inner')) {
        return data;
    }

    if (data.flipped && data.placement === data.originalPlacement) {
        // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
        return data;
    }

    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

    var placement = data.placement.split('-')[0];
    var placementOpposite = getOppositePlacement(placement);
    var variation = data.placement.split('-')[1] || '';

    var flipOrder = [];

    switch (options.behavior) {
        case BEHAVIORS.FLIP:
            flipOrder = [placement, placementOpposite];
            break;
        case BEHAVIORS.CLOCKWISE:
            flipOrder = clockwise(placement);
            break;
        case BEHAVIORS.COUNTERCLOCKWISE:
            flipOrder = clockwise(placement, true);
            break;
        default:
            flipOrder = options.behavior;
    }

    flipOrder.forEach(function (step, index) {
        if (placement !== step || flipOrder.length === index + 1) {
            return data;
        }

        placement = data.placement.split('-')[0];
        placementOpposite = getOppositePlacement(placement);

        var popperOffsets = data.offsets.popper;
        var refOffsets = data.offsets.reference;

        // using floor because the reference offsets may contain decimals we are not going to consider here
        var floor = Math.floor;
        var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

        var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
        var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
        var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
        var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

        var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

        // flip the variation if required
        var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;

        // flips variation if reference element overflows boundaries
        var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

        // flips variation if popper content overflows boundaries
        var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);

        var flippedVariation = flippedVariationByRef || flippedVariationByContent;

        if (overlapsRef || overflowsBoundaries || flippedVariation) {
            // this boolean to detect any flip loop
            data.flipped = true;

            if (overlapsRef || overflowsBoundaries) {
                placement = flipOrder[index + 1];
            }

            if (flippedVariation) {
                variation = getOppositeVariation(variation);
            }

            data.placement = placement + (variation ? '-' + variation : '');

            // this object contains `position`, we want to preserve it along with
            // any additional property we may add in the future
            data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

            data = runModifiers(data.instance.modifiers, data, 'flip');
        }
    });
    return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function keepTogether(data) {
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;

    var placement = data.placement.split('-')[0];
    var floor = Math.floor;
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
    var side = isVertical ? 'right' : 'bottom';
    var opSide = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    if (popper[side] < floor(reference[opSide])) {
        data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
    }
    if (popper[opSide] > floor(reference[side])) {
        data.offsets.popper[opSide] = floor(reference[side]);
    }

    return data;
}

/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */
function toValue(str, measurement, popperOffsets, referenceOffsets) {
    // separate value from unit
    var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
    var value = +split[1];
    var unit = split[2];

    // If it's not a number it's an operator, I guess
    if (!value) {
        return str;
    }

    if (unit.indexOf('%') === 0) {
        var element = void 0;
        switch (unit) {
            case '%p':
                element = popperOffsets;
                break;
            case '%':
            case '%r':
            default:
                element = referenceOffsets;
        }

        var rect = getClientRect(element);
        return rect[measurement] / 100 * value;
    } else if (unit === 'vh' || unit === 'vw') {
        // if is a vh or vw, we calculate the size based on the viewport
        var size = void 0;
        if (unit === 'vh') {
            size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
        } else {
            size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
        }
        return size / 100 * value;
    } else {
        // if is an explicit pixel unit, we get rid of the unit and keep the value
        // if is an implicit unit, it's px, and we return just the value
        return value;
    }
}

/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */
function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
    var offsets = [0, 0];

    // Use height if placement is left or right and index is 0 otherwise use width
    // in this way the first offset will use an axis and the second one
    // will use the other one
    var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

    // Split the offset string to obtain a list of values and operands
    // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
    var fragments = offset.split(/(\+|\-)/).map(function (frag) {
        return frag.trim();
    });

    // Detect if the offset string contains a pair of values or a single one
    // they could be separated by comma or space
    var divider = fragments.indexOf(find(fragments, function (frag) {
        return frag.search(/,|\s/) !== -1;
    }));

    if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
        console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
    }

    // If divider is found, we divide the list of values and operands to divide
    // them by ofset X and Y.
    var splitRegex = /\s*,\s*|\s+/;
    var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

    // Convert the values with units to absolute pixels to allow our computations
    ops = ops.map(function (op, index) {
        // Most of the units rely on the orientation of the popper
        var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
        var mergeWithPrevious = false;
        return op
            // This aggregates any `+` or `-` sign that aren't considered operators
            // e.g.: 10 + +5 => [10, +, +5]
            .reduce(function (a, b) {
                if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
                    a[a.length - 1] = b;
                    mergeWithPrevious = true;
                    return a;
                } else if (mergeWithPrevious) {
                    a[a.length - 1] += b;
                    mergeWithPrevious = false;
                    return a;
                } else {
                    return a.concat(b);
                }
            }, [])
            // Here we convert the string values into number values (in px)
            .map(function (str) {
                return toValue(str, measurement, popperOffsets, referenceOffsets);
            });
    });

    // Loop trough the offsets arrays and execute the operations
    ops.forEach(function (op, index) {
        op.forEach(function (frag, index2) {
            if (isNumeric(frag)) {
                offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
            }
        });
    });
    return offsets;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */
function offset(data, _ref) {
    var offset = _ref.offset;
    var placement = data.placement,
        _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;

    var basePlacement = placement.split('-')[0];

    var offsets = void 0;
    if (isNumeric(+offset)) {
        offsets = [+offset, 0];
    } else {
        offsets = parseOffset(offset, popper, reference, basePlacement);
    }

    if (basePlacement === 'left') {
        popper.top += offsets[0];
        popper.left -= offsets[1];
    } else if (basePlacement === 'right') {
        popper.top += offsets[0];
        popper.left += offsets[1];
    } else if (basePlacement === 'top') {
        popper.left += offsets[0];
        popper.top -= offsets[1];
    } else if (basePlacement === 'bottom') {
        popper.left += offsets[0];
        popper.top += offsets[1];
    }

    data.popper = popper;
    return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function preventOverflow(data, options) {
    var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

    // If offsetParent is the reference element, we really want to
    // go one step up and use the next offsetParent as reference to
    // avoid to make this modifier completely useless and look like broken
    if (data.instance.reference === boundariesElement) {
        boundariesElement = getOffsetParent(boundariesElement);
    }

    // NOTE: DOM access here
    // resets the popper's position so that the document size can be calculated excluding
    // the size of the popper element itself
    var transformProp = getSupportedPropertyName('transform');
    var popperStyles = data.instance.popper.style; // assignment to help minification
    var top = popperStyles.top,
        left = popperStyles.left,
        transform = popperStyles[transformProp];

    popperStyles.top = '';
    popperStyles.left = '';
    popperStyles[transformProp] = '';

    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

    // NOTE: DOM access here
    // restores the original style properties after the offsets have been computed
    popperStyles.top = top;
    popperStyles.left = left;
    popperStyles[transformProp] = transform;

    options.boundaries = boundaries;

    var order = options.priority;
    var popper = data.offsets.popper;

    var check = {
        primary: function primary(placement) {
            var value = popper[placement];
            if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
                value = Math.max(popper[placement], boundaries[placement]);
            }
            return defineProperty({}, placement, value);
        },
        secondary: function secondary(placement) {
            var mainSide = placement === 'right' ? 'left' : 'top';
            var value = popper[mainSide];
            if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
                value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
            }
            return defineProperty({}, mainSide, value);
        }
    };

    order.forEach(function (placement) {
        var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
        popper = _extends({}, popper, check[side](placement));
    });

    data.offsets.popper = popper;

    return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function shift(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var shiftvariation = placement.split('-')[1];

    // if shift shiftvariation is specified, run the modifier
    if (shiftvariation) {
        var _data$offsets = data.offsets,
            reference = _data$offsets.reference,
            popper = _data$offsets.popper;

        var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
        var side = isVertical ? 'left' : 'top';
        var measurement = isVertical ? 'width' : 'height';

        var shiftOffsets = {
            start: defineProperty({}, side, reference[side]),
            end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
        };

        data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
    }

    return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function hide(data) {
    if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
        return data;
    }

    var refRect = data.offsets.reference;
    var bound = find(data.instance.modifiers, function (modifier) {
        return modifier.name === 'preventOverflow';
    }).boundaries;

    if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
        // Avoid unnecessary DOM access if visibility hasn't changed
        if (data.hide === true) {
            return data;
        }

        data.hide = true;
        data.attributes['x-out-of-boundaries'] = '';
    } else {
        // Avoid unnecessary DOM access if visibility hasn't changed
        if (data.hide === false) {
            return data;
        }

        data.hide = false;
        data.attributes['x-out-of-boundaries'] = false;
    }

    return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function inner(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;

    var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

    var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

    popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

    data.placement = getOppositePlacement(placement);
    data.offsets.popper = getClientRect(popper);

    return data;
}

/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */
var modifiers = {
    /**
     * Modifier used to shift the popper on the start or end of its reference
     * element.<br />
     * It will read the variation of the `placement` property.<br />
     * It can be one either `-end` or `-start`.
     * @memberof modifiers
     * @inner
     */
    shift: {
        /** @prop {number} order=100 - Index used to define the order of execution */
        order: 100,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: shift
    },

    /**
     * The `offset` modifier can shift your popper on both its axis.
     *
     * It accepts the following units:
     * - `px` or unit-less, interpreted as pixels
     * - `%` or `%r`, percentage relative to the length of the reference element
     * - `%p`, percentage relative to the length of the popper element
     * - `vw`, CSS viewport width unit
     * - `vh`, CSS viewport height unit
     *
     * For length is intended the main axis relative to the placement of the popper.<br />
     * This means that if the placement is `top` or `bottom`, the length will be the
     * `width`. In case of `left` or `right`, it will be the `height`.
     *
     * You can provide a single value (as `Number` or `String`), or a pair of values
     * as `String` divided by a comma or one (or more) white spaces.<br />
     * The latter is a deprecated method because it leads to confusion and will be
     * removed in v2.<br />
     * Additionally, it accepts additions and subtractions between different units.
     * Note that multiplications and divisions aren't supported.
     *
     * Valid examples are:
     * ```
     * 10
     * '10%'
     * '10, 10'
     * '10%, 10'
     * '10 + 10%'
     * '10 - 5vh + 3%'
     * '-10px + 5vh, 5px - 6%'
     * ```
     * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
     * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
     * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
     *
     * @memberof modifiers
     * @inner
     */
    offset: {
        /** @prop {number} order=200 - Index used to define the order of execution */
        order: 200,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: offset,
        /** @prop {Number|String} offset=0
         * The offset value as described in the modifier description
         */
        offset: 0
    },

    /**
     * Modifier used to prevent the popper from being positioned outside the boundary.
     *
     * A scenario exists where the reference itself is not within the boundaries.<br />
     * We can say it has "escaped the boundaries"  or just "escaped".<br />
     * In this case we need to decide whether the popper should either:
     *
     * - detach from the reference and remain "trapped" in the boundaries, or
     * - if it should ignore the boundary and "escape with its reference"
     *
     * When `escapeWithReference` is set to`true` and reference is completely
     * outside its boundaries, the popper will overflow (or completely leave)
     * the boundaries in order to remain attached to the edge of the reference.
     *
     * @memberof modifiers
     * @inner
     */
    preventOverflow: {
        /** @prop {number} order=300 - Index used to define the order of execution */
        order: 300,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: preventOverflow,
        /**
         * @prop {Array} [priority=['left','right','top','bottom']]
         * Popper will try to prevent overflow following these priorities by default,
         * then, it could overflow on the left and on top of the `boundariesElement`
         */
        priority: ['left', 'right', 'top', 'bottom'],
        /**
         * @prop {number} padding=5
         * Amount of pixel used to define a minimum distance between the boundaries
         * and the popper. This makes sure the popper always has a little padding
         * between the edges of its container
         */
        padding: 5,
        /**
         * @prop {String|HTMLElement} boundariesElement='scrollParent'
         * Boundaries used by the modifier. Can be `scrollParent`, `window`,
         * `viewport` or any DOM element.
         */
        boundariesElement: 'scrollParent'
    },

    /**
     * Modifier used to make sure the reference and its popper stay near each other
     * without leaving any gap between the two. Especially useful when the arrow is
     * enabled and you want to ensure that it points to its reference element.
     * It cares only about the first axis. You can still have poppers with margin
     * between the popper and its reference element.
     * @memberof modifiers
     * @inner
     */
    keepTogether: {
        /** @prop {number} order=400 - Index used to define the order of execution */
        order: 400,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: keepTogether
    },

    /**
     * This modifier is used to move the `arrowElement` of the popper to make
     * sure it is positioned between the reference element and its popper element.
     * It will read the outer size of the `arrowElement` node to detect how many
     * pixels of conjunction are needed.
     *
     * It has no effect if no `arrowElement` is provided.
     * @memberof modifiers
     * @inner
     */
    arrow: {
        /** @prop {number} order=500 - Index used to define the order of execution */
        order: 500,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: arrow,
        /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
        element: '[x-arrow]'
    },

    /**
     * Modifier used to flip the popper's placement when it starts to overlap its
     * reference element.
     *
     * Requires the `preventOverflow` modifier before it in order to work.
     *
     * **NOTE:** this modifier will interrupt the current update cycle and will
     * restart it if it detects the need to flip the placement.
     * @memberof modifiers
     * @inner
     */
    flip: {
        /** @prop {number} order=600 - Index used to define the order of execution */
        order: 600,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: flip,
        /**
         * @prop {String|Array} behavior='flip'
         * The behavior used to change the popper's placement. It can be one of
         * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
         * placements (with optional variations)
         */
        behavior: 'flip',
        /**
         * @prop {number} padding=5
         * The popper will flip if it hits the edges of the `boundariesElement`
         */
        padding: 5,
        /**
         * @prop {String|HTMLElement} boundariesElement='viewport'
         * The element which will define the boundaries of the popper position.
         * The popper will never be placed outside of the defined boundaries
         * (except if `keepTogether` is enabled)
         */
        boundariesElement: 'viewport',
        /**
         * @prop {Boolean} flipVariations=false
         * The popper will switch placement variation between `-start` and `-end` when
         * the reference element overlaps its boundaries.
         *
         * The original placement should have a set variation.
         */
        flipVariations: false,
        /**
         * @prop {Boolean} flipVariationsByContent=false
         * The popper will switch placement variation between `-start` and `-end` when
         * the popper element overlaps its reference boundaries.
         *
         * The original placement should have a set variation.
         */
        flipVariationsByContent: false
    },

    /**
     * Modifier used to make the popper flow toward the inner of the reference element.
     * By default, when this modifier is disabled, the popper will be placed outside
     * the reference element.
     * @memberof modifiers
     * @inner
     */
    inner: {
        /** @prop {number} order=700 - Index used to define the order of execution */
        order: 700,
        /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
        enabled: false,
        /** @prop {ModifierFn} */
        fn: inner
    },

    /**
     * Modifier used to hide the popper when its reference element is outside of the
     * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
     * be used to hide with a CSS selector the popper when its reference is
     * out of boundaries.
     *
     * Requires the `preventOverflow` modifier before it in order to work.
     * @memberof modifiers
     * @inner
     */
    hide: {
        /** @prop {number} order=800 - Index used to define the order of execution */
        order: 800,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: hide
    },

    /**
     * Computes the style that will be applied to the popper element to gets
     * properly positioned.
     *
     * Note that this modifier will not touch the DOM, it just prepares the styles
     * so that `applyStyle` modifier can apply it. This separation is useful
     * in case you need to replace `applyStyle` with a custom implementation.
     *
     * This modifier has `850` as `order` value to maintain backward compatibility
     * with previous versions of Popper.js. Expect the modifiers ordering method
     * to change in future major versions of the library.
     *
     * @memberof modifiers
     * @inner
     */
    computeStyle: {
        /** @prop {number} order=850 - Index used to define the order of execution */
        order: 850,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: computeStyle,
        /**
         * @prop {Boolean} gpuAcceleration=true
         * If true, it uses the CSS 3D transformation to position the popper.
         * Otherwise, it will use the `top` and `left` properties
         */
        gpuAcceleration: true,
        /**
         * @prop {string} [x='bottom']
         * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
         * Change this if your popper should grow in a direction different from `bottom`
         */
        x: 'bottom',
        /**
         * @prop {string} [x='left']
         * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
         * Change this if your popper should grow in a direction different from `right`
         */
        y: 'right'
    },

    /**
     * Applies the computed styles to the popper element.
     *
     * All the DOM manipulations are limited to this modifier. This is useful in case
     * you want to integrate Popper.js inside a framework or view library and you
     * want to delegate all the DOM manipulations to it.
     *
     * Note that if you disable this modifier, you must make sure the popper element
     * has its position set to `absolute` before Popper.js can do its work!
     *
     * Just disable this modifier and define your own to achieve the desired effect.
     *
     * @memberof modifiers
     * @inner
     */
    applyStyle: {
        /** @prop {number} order=900 - Index used to define the order of execution */
        order: 900,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: applyStyle,
        /** @prop {Function} */
        onLoad: applyStyleOnLoad,
        /**
         * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
         * @prop {Boolean} gpuAcceleration=true
         * If true, it uses the CSS 3D transformation to position the popper.
         * Otherwise, it will use the `top` and `left` properties
         */
        gpuAcceleration: undefined
    }
};

/**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
var Defaults = {
    /**
     * Popper's placement.
     * @prop {Popper.placements} placement='bottom'
     */
    placement: 'bottom',

    /**
     * Set this to true if you want popper to position it self in 'fixed' mode
     * @prop {Boolean} positionFixed=false
     */
    positionFixed: false,

    /**
     * Whether events (resize, scroll) are initially enabled.
     * @prop {Boolean} eventsEnabled=true
     */
    eventsEnabled: true,

    /**
     * Set to true if you want to automatically remove the popper when
     * you call the `destroy` method.
     * @prop {Boolean} removeOnDestroy=false
     */
    removeOnDestroy: false,

    /**
     * Callback called when the popper is created.<br />
     * By default, it is set to no-op.<br />
     * Access Popper.js instance with `data.instance`.
     * @prop {onCreate}
     */
    onCreate: function onCreate() {},

    /**
     * Callback called when the popper is updated. This callback is not called
     * on the initialization/creation of the popper, but only on subsequent
     * updates.<br />
     * By default, it is set to no-op.<br />
     * Access Popper.js instance with `data.instance`.
     * @prop {onUpdate}
     */
    onUpdate: function onUpdate() {},

    /**
     * List of modifiers used to modify the offsets before they are applied to the popper.
     * They provide most of the functionalities of Popper.js.
     * @prop {modifiers}
     */
    modifiers: modifiers
};

/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */

// Utils
// Methods
var Popper = function () {
    /**
     * Creates a new Popper.js instance.
     * @class Popper
     * @param {Element|referenceObject} reference - The reference element used to position the popper
     * @param {Element} popper - The HTML / XML element used as the popper
     * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
     * @return {Object} instance - The generated Popper.js instance
     */
    function Popper(reference, popper) {
        var _this = this;

        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        classCallCheck(this, Popper);

        this.scheduleUpdate = function () {
            return requestAnimationFrame(_this.update);
        };

        // make update() debounced, so that it only runs at most once-per-tick
        this.update = debounce(this.update.bind(this));

        // with {} we create a new object with the options inside it
        this.options = _extends({}, Popper.Defaults, options);

        // init state
        this.state = {
            isDestroyed: false,
            isCreated: false,
            scrollParents: []
        };

        // get reference and popper elements (allow jQuery wrappers)
        this.reference = reference && reference.jquery ? reference[0] : reference;
        this.popper = popper && popper.jquery ? popper[0] : popper;

        // Deep merge modifiers options
        this.options.modifiers = {};
        Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
            _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
        });

        // Refactoring modifiers' list (Object => Array)
        this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
            return _extends({
                name: name
            }, _this.options.modifiers[name]);
        })
            // sort the modifiers by order
            .sort(function (a, b) {
                return a.order - b.order;
            });

        // modifiers have the ability to execute arbitrary code when Popper.js get inited
        // such code is executed in the same order of its modifier
        // they could add new properties to their options configuration
        // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
        this.modifiers.forEach(function (modifierOptions) {
            if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
                modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
            }
        });

        // fire the first update to position the popper in the right place
        this.update();

        var eventsEnabled = this.options.eventsEnabled;
        if (eventsEnabled) {
            // setup event listeners, they will take care of update the position in specific situations
            this.enableEventListeners();
        }

        this.state.eventsEnabled = eventsEnabled;
    }

    // We can't use class properties because they don't get listed in the
    // class prototype and break stuff like Sinon stubs


    createClass(Popper, [{
        key: 'update',
        value: function update$$1() {
            return update.call(this);
        }
    }, {
        key: 'destroy',
        value: function destroy$$1() {
            return destroy.call(this);
        }
    }, {
        key: 'enableEventListeners',
        value: function enableEventListeners$$1() {
            return enableEventListeners.call(this);
        }
    }, {
        key: 'disableEventListeners',
        value: function disableEventListeners$$1() {
            return disableEventListeners.call(this);
        }

        /**
         * Schedules an update. It will run on the next UI update available.
         * @method scheduleUpdate
         * @memberof Popper
         */


        /**
         * Collection of utilities useful when writing custom modifiers.
         * Starting from version 1.7, this method is available only if you
         * include `popper-utils.js` before `popper.js`.
         *
         * **DEPRECATION**: This way to access PopperUtils is deprecated
         * and will be removed in v2! Use the PopperUtils module directly instead.
         * Due to the high instability of the methods contained in Utils, we can't
         * guarantee them to follow semver. Use them at your own risk!
         * @static
         * @private
         * @type {Object}
         * @deprecated since version 1.8
         * @member Utils
         * @memberof Popper
         */

    }]);
    return Popper;
}();

/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */


Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;

var PLACEMENT_TOP_START = 'top-start';
var PLACEMENT_TOP_END = 'top-end';
var PLACEMENT_BOTTOM_START = 'bottom-start';
var PLACEMENT_BOTTOM_END = 'bottom-end';
var PLACEMENT_RIGHT_START = 'right-start';
var PLACEMENT_LEFT_START = 'left-start';

function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$1(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$1(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$1(Constructor.prototype, protoProps); if (staticProps) _defineProperties$1(Constructor, staticProps); return Constructor; }
var BvEvent = /*#__PURE__*/function () {
    function BvEvent(type) {
        var eventInit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck$1(this, BvEvent);

        // Start by emulating native Event constructor
        if (!type) {
            /* istanbul ignore next */
            throw new TypeError("Failed to construct '".concat(this.constructor.name, "'. 1 argument required, ").concat(arguments.length, " given."));
        } // Merge defaults first, the eventInit, and the type last
        // so it can't be overwritten


        assign(this, BvEvent.Defaults, this.constructor.Defaults, eventInit, {
            type: type
        }); // Freeze some props as readonly, but leave them enumerable

        defineProperties(this, {
            type: readonlyDescriptor(),
            cancelable: readonlyDescriptor(),
            nativeEvent: readonlyDescriptor(),
            target: readonlyDescriptor(),
            relatedTarget: readonlyDescriptor(),
            vueTarget: readonlyDescriptor(),
            componentId: readonlyDescriptor()
        }); // Create a private variable using closure scoping

        var defaultPrevented = false; // Recreate preventDefault method. One way setter

        this.preventDefault = function preventDefault() {
            if (this.cancelable) {
                defaultPrevented = true;
            }
        }; // Create `defaultPrevented` publicly accessible prop that
        // can only be altered by the preventDefault method


        defineProperty$1(this, 'defaultPrevented', {
            enumerable: true,
            get: function get() {
                return defaultPrevented;
            }
        });
    }

    _createClass$1(BvEvent, null, [{
        key: "Defaults",
        get: function get() {
            return {
                type: '',
                cancelable: true,
                nativeEvent: null,
                target: null,
                relatedTarget: null,
                vueTarget: null,
                componentId: null
            };
        }
    }]);

    return BvEvent;
}();

var clickOutMixin = Vue$1.extend({
    data: function data() {
        return {
            listenForClickOut: false
        };
    },
    watch: {
        listenForClickOut: function listenForClickOut(newValue, oldValue) {
            if (newValue !== oldValue) {
                eventOff(this.clickOutElement, this.clickOutEventName, this._clickOutHandler, EVENT_OPTIONS_NO_CAPTURE);

                if (newValue) {
                    eventOn(this.clickOutElement, this.clickOutEventName, this._clickOutHandler, EVENT_OPTIONS_NO_CAPTURE);
                }
            }
        }
    },
    beforeCreate: function beforeCreate() {
        // Declare non-reactive properties
        this.clickOutElement = null;
        this.clickOutEventName = null;
    },
    mounted: function mounted() {
        if (!this.clickOutElement) {
            this.clickOutElement = document;
        }

        if (!this.clickOutEventName) {
            this.clickOutEventName = 'click';
        }

        if (this.listenForClickOut) {
            eventOn(this.clickOutElement, this.clickOutEventName, this._clickOutHandler, EVENT_OPTIONS_NO_CAPTURE);
        }
    },
    beforeDestroy: function beforeDestroy() {
        eventOff(this.clickOutElement, this.clickOutEventName, this._clickOutHandler, EVENT_OPTIONS_NO_CAPTURE);
    },
    methods: {
        isClickOut: function isClickOut(event) {
            return !contains(this.$el, event.target);
        },
        _clickOutHandler: function _clickOutHandler(event) {
            if (this.clickOutHandler && this.isClickOut(event)) {
                this.clickOutHandler(event);
            }
        }
    }
});

var focusInMixin = Vue$1.extend({
    data: function data() {
        return {
            listenForFocusIn: false
        };
    },
    watch: {
        listenForFocusIn: function listenForFocusIn(newValue, oldValue) {
            if (newValue !== oldValue) {
                eventOff(this.focusInElement, 'focusin', this._focusInHandler, EVENT_OPTIONS_NO_CAPTURE);

                if (newValue) {
                    eventOn(this.focusInElement, 'focusin', this._focusInHandler, EVENT_OPTIONS_NO_CAPTURE);
                }
            }
        }
    },
    beforeCreate: function beforeCreate() {
        // Declare non-reactive properties
        this.focusInElement = null;
    },
    mounted: function mounted() {
        if (!this.focusInElement) {
            this.focusInElement = document;
        }

        if (this.listenForFocusIn) {
            eventOn(this.focusInElement, 'focusin', this._focusInHandler, EVENT_OPTIONS_NO_CAPTURE);
        }
    },
    beforeDestroy: function beforeDestroy() {
        eventOff(this.focusInElement, 'focusin', this._focusInHandler, EVENT_OPTIONS_NO_CAPTURE);
    },
    methods: {
        _focusInHandler: function _focusInHandler(event) {
            if (this.focusInHandler) {
                this.focusInHandler(event);
            }
        }
    }
});

function ownKeys$9(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$9(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$9(Object(source), true).forEach(function (key) { _defineProperty$c(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$9(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty$c(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ROOT_EVENT_NAME_SHOWN = getRootEventName(NAME_DROPDOWN, EVENT_NAME_SHOWN);
var ROOT_EVENT_NAME_HIDDEN = getRootEventName(NAME_DROPDOWN, EVENT_NAME_HIDDEN); // CSS selectors

var SELECTOR_FORM_CHILD = '.dropdown form';
var SELECTOR_ITEM = ['.dropdown-item', '.b-dropdown-form'].map(function (selector) {
    return "".concat(selector, ":not(.disabled):not([disabled])");
}).join(', '); // --- Helper methods ---
// Return an array of visible items

var filterVisibles = function filterVisibles(els) {
    return (els || []).filter(isVisible);
}; // --- Props ---


var props$a = makePropsConfigurable(sortKeys(_objectSpread$9(_objectSpread$9({}, props$b), {}, {
    // String: `scrollParent`, `window` or `viewport`
    // HTMLElement: HTML Element reference
    boundary: makeProp([HTMLElement, PROP_TYPE_STRING], 'scrollParent'),
    disabled: makeProp(PROP_TYPE_BOOLEAN, false),
    // Place left if possible
    dropleft: makeProp(PROP_TYPE_BOOLEAN, false),
    // Place right if possible
    dropright: makeProp(PROP_TYPE_BOOLEAN, false),
    // Place on top if possible
    dropup: makeProp(PROP_TYPE_BOOLEAN, false),
    // Disable auto-flipping of menu from bottom <=> top
    noFlip: makeProp(PROP_TYPE_BOOLEAN, false),
    // Number of pixels or a CSS unit value to offset menu
    // (i.e. `1px`, `1rem`, etc.)
    offset: makeProp(PROP_TYPE_NUMBER_STRING, 0),
    popperOpts: makeProp(PROP_TYPE_OBJECT, {}),
    // Right align menu (default is left align)
    right: makeProp(PROP_TYPE_BOOLEAN, false)
})), NAME_DROPDOWN); // --- Mixin ---
// @vue/component

var dropdownMixin = Vue$1.extend({
    mixins: [idMixin, listenOnRootMixin, clickOutMixin, focusInMixin],
    provide: function provide() {
        return {
            bvDropdown: this
        };
    },
    inject: {
        bvNavbar: {
            default: null
        }
    },
    props: props$a,
    data: function data() {
        return {
            visible: false,
            visibleChangePrevented: false
        };
    },
    computed: {
        inNavbar: function inNavbar() {
            return !isNull(this.bvNavbar);
        },
        toggler: function toggler() {
            var toggle = this.$refs.toggle;
            return toggle ? toggle.$el || toggle : null;
        },
        directionClass: function directionClass() {
            if (this.dropup) {
                return 'dropup';
            } else if (this.dropright) {
                return 'dropright';
            } else if (this.dropleft) {
                return 'dropleft';
            }

            return '';
        },
        boundaryClass: function boundaryClass() {
            // Position `static` is needed to allow menu to "breakout" of the `scrollParent`
            // boundaries when boundary is anything other than `scrollParent`
            // See: https://github.com/twbs/bootstrap/issues/24251#issuecomment-341413786
            return this.boundary !== 'scrollParent' && !this.inNavbar ? 'position-static' : '';
        }
    },
    watch: {
        visible: function visible(newValue, oldValue) {
            if (this.visibleChangePrevented) {
                this.visibleChangePrevented = false;
                return;
            }

            if (newValue !== oldValue) {
                var eventName = newValue ? EVENT_NAME_SHOW : EVENT_NAME_HIDE;
                var bvEvent = new BvEvent(eventName, {
                    cancelable: true,
                    vueTarget: this,
                    target: this.$refs.menu,
                    relatedTarget: null,
                    componentId: this.safeId ? this.safeId() : this.id || null
                });
                this.emitEvent(bvEvent);

                if (bvEvent.defaultPrevented) {
                    // Reset value and exit if canceled
                    this.visibleChangePrevented = true;
                    this.visible = oldValue; // Just in case a child element triggered `this.hide(true)`

                    this.$off(EVENT_NAME_HIDDEN, this.focusToggler);
                    return;
                }

                if (newValue) {
                    this.showMenu();
                } else {
                    this.hideMenu();
                }
            }
        },
        disabled: function disabled(newValue, oldValue) {
            if (newValue !== oldValue && newValue && this.visible) {
                // Hide dropdown if disabled changes to true
                this.visible = false;
            }
        }
    },
    created: function created() {
        // Create private non-reactive props
        this.$_popper = null;
        this.$_hideTimeout = null;
    },

    /* istanbul ignore next */
    deactivated: function deactivated() {
        // In case we are inside a `<keep-alive>`
        this.visible = false;
        this.whileOpenListen(false);
        this.destroyPopper();
    },
    beforeDestroy: function beforeDestroy() {
        this.visible = false;
        this.whileOpenListen(false);
        this.destroyPopper();
        this.clearHideTimeout();
    },
    methods: {
        // Event emitter
        emitEvent: function emitEvent(bvEvent) {
            var type = bvEvent.type;
            this.emitOnRoot(getRootEventName(NAME_DROPDOWN, type), bvEvent);
            this.$emit(type, bvEvent);
        },
        showMenu: function showMenu() {
            var _this = this;

            if (this.disabled) {
                /* istanbul ignore next */
                return;
            } // Only instantiate Popper.js when dropdown is not in `<b-navbar>`


            if (!this.inNavbar) {
                if (typeof Popper === 'undefined') {
                    /* istanbul ignore next */
                    warn('Popper.js not found. Falling back to CSS positioning', NAME_DROPDOWN);
                } else {
                    // For dropup with alignment we use the parent element as popper container
                    var el = this.dropup && this.right || this.split ? this.$el : this.$refs.toggle; // Make sure we have a reference to an element, not a component!

                    el = el.$el || el; // Instantiate Popper.js

                    this.createPopper(el);
                }
            } // Ensure other menus are closed


            this.emitOnRoot(ROOT_EVENT_NAME_SHOWN, this); // Enable listeners

            this.whileOpenListen(true); // Wrap in `$nextTick()` to ensure menu is fully rendered/shown

            this.$nextTick(function () {
                // Focus on the menu container on show
                _this.focusMenu(); // Emit the shown event


                _this.$emit(EVENT_NAME_SHOWN);
            });
        },
        hideMenu: function hideMenu() {
            this.whileOpenListen(false);
            this.emitOnRoot(ROOT_EVENT_NAME_HIDDEN, this);
            this.$emit(EVENT_NAME_HIDDEN);
            this.destroyPopper();
        },
        createPopper: function createPopper(element) {
            this.destroyPopper();
            this.$_popper = new Popper(element, this.$refs.menu, this.getPopperConfig());
        },
        // Ensure popper event listeners are removed cleanly
        destroyPopper: function destroyPopper() {
            this.$_popper && this.$_popper.destroy();
            this.$_popper = null;
        },
        // Instructs popper to re-computes the dropdown position
        // useful if the content changes size
        updatePopper: function updatePopper() {
            try {
                this.$_popper.scheduleUpdate();
            } catch (_unused) {}
        },
        clearHideTimeout: function clearHideTimeout() {
            clearTimeout(this.$_hideTimeout);
            this.$_hideTimeout = null;
        },
        getPopperConfig: function getPopperConfig() {
            var placement = PLACEMENT_BOTTOM_START;

            if (this.dropup) {
                placement = this.right ? PLACEMENT_TOP_END : PLACEMENT_TOP_START;
            } else if (this.dropright) {
                placement = PLACEMENT_RIGHT_START;
            } else if (this.dropleft) {
                placement = PLACEMENT_LEFT_START;
            } else if (this.right) {
                placement = PLACEMENT_BOTTOM_END;
            }

            var popperConfig = {
                placement: placement,
                modifiers: {
                    offset: {
                        offset: this.offset || 0
                    },
                    flip: {
                        enabled: !this.noFlip
                    }
                }
            };
            var boundariesElement = this.boundary;

            if (boundariesElement) {
                popperConfig.modifiers.preventOverflow = {
                    boundariesElement: boundariesElement
                };
            }

            return mergeDeep(popperConfig, this.popperOpts || {});
        },
        // Turn listeners on/off while open
        whileOpenListen: function whileOpenListen(isOpen) {
            // Hide the dropdown when clicked outside
            this.listenForClickOut = isOpen; // Hide the dropdown when it loses focus

            this.listenForFocusIn = isOpen; // Hide the dropdown when another dropdown is opened

            var method = isOpen ? '$on' : '$off';
            this.$root[method](ROOT_EVENT_NAME_SHOWN, this.rootCloseListener);
        },
        rootCloseListener: function rootCloseListener(vm) {
            if (vm !== this) {
                this.visible = false;
            }
        },
        // Public method to show dropdown
        show: function show() {
            var _this2 = this;

            if (this.disabled) {
                return;
            } // Wrap in a `requestAF()` to allow any previous
            // click handling to occur first


            requestAF(function () {
                _this2.visible = true;
            });
        },
        // Public method to hide dropdown
        hide: function hide() {
            var refocus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

            /* istanbul ignore next */
            if (this.disabled) {
                return;
            }

            this.visible = false;

            if (refocus) {
                // Child element is closing the dropdown on click
                this.$once(EVENT_NAME_HIDDEN, this.focusToggler);
            }
        },
        // Called only by a button that toggles the menu
        toggle: function toggle(event) {
            event = event || {}; // Early exit when not a click event or ENTER, SPACE or DOWN were pressed

            var _event = event,
                type = _event.type,
                keyCode = _event.keyCode;

            if (type !== 'click' && !(type === 'keydown' && [CODE_ENTER, CODE_SPACE, CODE_DOWN].indexOf(keyCode) !== -1)) {
                /* istanbul ignore next */
                return;
            }
            /* istanbul ignore next */


            if (this.disabled) {
                this.visible = false;
                return;
            }

            this.$emit(EVENT_NAME_TOGGLE, event);
            stopEvent(event); // Toggle visibility

            if (this.visible) {
                this.hide(true);
            } else {
                this.show();
            }
        },
        // Mousedown handler for the toggle

        /* istanbul ignore next */
        onMousedown: function onMousedown(event) {
            // We prevent the 'mousedown' event for the toggle to stop the
            // 'focusin' event from being fired
            // The event would otherwise be picked up by the global 'focusin'
            // listener and there is no cross-browser solution to detect it
            // relates to the toggle click
            // The 'click' event will still be fired and we handle closing
            // other dropdowns there too
            // See https://github.com/bootstrap-vue/bootstrap-vue/issues/4328
            stopEvent(event, {
                propagation: false
            });
        },
        // Called from dropdown menu context
        onKeydown: function onKeydown(event) {
            var keyCode = event.keyCode;

            if (keyCode === CODE_ESC) {
                // Close on ESC
                this.onEsc(event);
            } else if (keyCode === CODE_DOWN) {
                // Down Arrow
                this.focusNext(event, false);
            } else if (keyCode === CODE_UP) {
                // Up Arrow
                this.focusNext(event, true);
            }
        },
        // If user presses ESC, close the menu
        onEsc: function onEsc(event) {
            if (this.visible) {
                this.visible = false;
                stopEvent(event); // Return focus to original trigger button

                this.$once(EVENT_NAME_HIDDEN, this.focusToggler);
            }
        },
        // Called only in split button mode, for the split button
        onSplitClick: function onSplitClick(event) {
            /* istanbul ignore next */
            if (this.disabled) {
                this.visible = false;
                return;
            }

            this.$emit(EVENT_NAME_CLICK, event);
        },
        // Shared hide handler between click-out and focus-in events
        hideHandler: function hideHandler(event) {
            var _this3 = this;

            var target = event.target;

            if (this.visible && !contains(this.$refs.menu, target) && !contains(this.toggler, target)) {
                this.clearHideTimeout();
                this.$_hideTimeout = setTimeout(function () {
                    return _this3.hide();
                }, this.inNavbar ? 300 : 0);
            }
        },
        // Document click-out listener
        clickOutHandler: function clickOutHandler(event) {
            this.hideHandler(event);
        },
        // Document focus-in listener
        focusInHandler: function focusInHandler(event) {
            this.hideHandler(event);
        },
        // Keyboard nav
        focusNext: function focusNext(event, up) {
            var _this4 = this;

            // Ignore key up/down on form elements
            var target = event.target;

            if (!this.visible || event && closest(SELECTOR_FORM_CHILD, target)) {
                /* istanbul ignore next: should never happen */
                return;
            }

            stopEvent(event);
            this.$nextTick(function () {
                var items = _this4.getItems();

                if (items.length < 1) {
                    /* istanbul ignore next: should never happen */
                    return;
                }

                var index = items.indexOf(target);

                if (up && index > 0) {
                    index--;
                } else if (!up && index < items.length - 1) {
                    index++;
                }

                if (index < 0) {
                    /* istanbul ignore next: should never happen */
                    index = 0;
                }

                _this4.focusItem(index, items);
            });
        },
        focusItem: function focusItem(index, items) {
            var el = items.find(function (el, i) {
                return i === index;
            });
            attemptFocus(el);
        },
        getItems: function getItems() {
            // Get all items
            return filterVisibles(selectAll(SELECTOR_ITEM, this.$refs.menu));
        },
        focusMenu: function focusMenu() {
            attemptFocus(this.$refs.menu);
        },
        focusToggler: function focusToggler() {
            var _this5 = this;

            this.$nextTick(function () {
                attemptFocus(_this5.toggler);
            });
        }
    }
});

function ownKeys$8(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$8(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$8(Object(source), true).forEach(function (key) { _defineProperty$b(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$8(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty$b(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var props$9 = makePropsConfigurable(sortKeys(_objectSpread$8(_objectSpread$8(_objectSpread$8({}, props$b), props$a), {}, {
    block: makeProp(PROP_TYPE_BOOLEAN, false),
    html: makeProp(PROP_TYPE_STRING),
    // If `true`, only render menu contents when open
    lazy: makeProp(PROP_TYPE_BOOLEAN, false),
    menuClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    noCaret: makeProp(PROP_TYPE_BOOLEAN, false),
    role: makeProp(PROP_TYPE_STRING, 'menu'),
    size: makeProp(PROP_TYPE_STRING),
    split: makeProp(PROP_TYPE_BOOLEAN, false),
    splitButtonType: makeProp(PROP_TYPE_STRING, 'button', function (value) {
        return arrayIncludes(['button', 'submit', 'reset'], value);
    }),
    splitClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    splitHref: makeProp(PROP_TYPE_STRING),
    splitTo: makeProp(PROP_TYPE_OBJECT_STRING),
    splitVariant: makeProp(PROP_TYPE_STRING),
    text: makeProp(PROP_TYPE_STRING),
    toggleClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    toggleTag: makeProp(PROP_TYPE_STRING, 'button'),
    // TODO: This really should be `toggleLabel`
    toggleText: makeProp(PROP_TYPE_STRING, 'Toggle dropdown'),
    variant: makeProp(PROP_TYPE_STRING, 'secondary')
})), NAME_DROPDOWN); // --- Main component ---
// @vue/component

var BDropdown = /*#__PURE__*/Vue$1.extend({
    name: NAME_DROPDOWN,
    mixins: [idMixin, dropdownMixin, normalizeSlotMixin],
    props: props$9,
    computed: {
        dropdownClasses: function dropdownClasses() {
            var block = this.block,
                split = this.split;
            return [this.directionClass, this.boundaryClass, {
                show: this.visible,
                // The 'btn-group' class is required in `split` mode for button alignment
                // It needs also to be applied when `block` is disabled to allow multiple
                // dropdowns to be aligned one line
                'btn-group': split || !block,
                // When `block` is enabled and we are in `split` mode the 'd-flex' class
                // needs to be applied to allow the buttons to stretch to full width
                'd-flex': block && split
            }];
        },
        menuClasses: function menuClasses() {
            return [this.menuClass, {
                'dropdown-menu-right': this.right,
                show: this.visible
            }];
        },
        toggleClasses: function toggleClasses() {
            var split = this.split;
            return [this.toggleClass, {
                'dropdown-toggle-split': split,
                'dropdown-toggle-no-caret': this.noCaret && !split
            }];
        }
    },
    render: function render(h) {
        var visible = this.visible,
            variant = this.variant,
            size = this.size,
            block = this.block,
            disabled = this.disabled,
            split = this.split,
            role = this.role,
            hide = this.hide,
            toggle = this.toggle;
        var commonProps = {
            variant: variant,
            size: size,
            block: block,
            disabled: disabled
        };
        var $buttonChildren = this.normalizeSlot(SLOT_NAME_BUTTON_CONTENT);
        var buttonContentDomProps = this.hasNormalizedSlot(SLOT_NAME_BUTTON_CONTENT) ? {} : htmlOrText(this.html, this.text);
        var $split = h();

        if (split) {
            var splitTo = this.splitTo,
                splitHref = this.splitHref,
                splitButtonType = this.splitButtonType;

            var btnProps = _objectSpread$8(_objectSpread$8({}, commonProps), {}, {
                variant: this.splitVariant || variant
            }); // We add these as needed due to <router-link> issues with
            // defined property with `undefined`/`null` values


            if (splitTo) {
                btnProps.to = splitTo;
            } else if (splitHref) {
                btnProps.href = splitHref;
            } else if (splitButtonType) {
                btnProps.type = splitButtonType;
            }

            $split = h(BButton, {
                class: this.splitClass,
                attrs: {
                    id: this.safeId('_BV_button_')
                },
                props: btnProps,
                domProps: buttonContentDomProps,
                on: {
                    click: this.onSplitClick
                },
                ref: 'button'
            }, $buttonChildren); // Overwrite button content for the toggle when in `split` mode

            $buttonChildren = [h('span', {
                class: ['sr-only']
            }, [this.toggleText])];
            buttonContentDomProps = {};
        }

        var $toggle = h(BButton, {
            staticClass: 'dropdown-toggle',
            class: this.toggleClasses,
            attrs: {
                id: this.safeId('_BV_toggle_'),
                'aria-haspopup': 'true',
                'aria-expanded': toString(visible)
            },
            props: _objectSpread$8(_objectSpread$8({}, commonProps), {}, {
                tag: this.toggleTag,
                block: block && !split
            }),
            domProps: buttonContentDomProps,
            on: {
                mousedown: this.onMousedown,
                click: toggle,
                keydown: toggle // Handle ENTER, SPACE and DOWN

            },
            ref: 'toggle'
        }, $buttonChildren);
        var $menu = h('ul', {
            staticClass: 'dropdown-menu',
            class: this.menuClasses,
            attrs: {
                role: role,
                tabindex: '-1',
                'aria-labelledby': this.safeId(split ? '_BV_button_' : '_BV_toggle_')
            },
            on: {
                keydown: this.onKeydown // Handle UP, DOWN and ESC

            },
            ref: 'menu'
        }, [!this.lazy || visible ? this.normalizeSlot(SLOT_NAME_DEFAULT, {
            hide: hide
        }) : h()]);
        return h('div', {
            staticClass: 'dropdown b-dropdown',
            class: this.dropdownClasses,
            attrs: {
                id: this.safeId()
            }
        }, [$split, $toggle, $menu]);
    }
});

function ownKeys$7(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$7(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$7(Object(source), true).forEach(function (key) { _defineProperty$a(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$7(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty$a(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var linkProps$1 = omit(props$d, ['event', 'routerTag']);
var props$8 = makePropsConfigurable(sortKeys(_objectSpread$7(_objectSpread$7({}, linkProps$1), {}, {
    linkClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    variant: makeProp(PROP_TYPE_STRING)
})), NAME_DROPDOWN_ITEM); // --- Main component ---
// @vue/component

var BDropdownItem = /*#__PURE__*/Vue$1.extend({
    name: NAME_DROPDOWN_ITEM,
    mixins: [attrsMixin, normalizeSlotMixin],
    inject: {
        bvDropdown: {
            default: null
        }
    },
    inheritAttrs: false,
    props: props$8,
    computed: {
        computedAttrs: function computedAttrs() {
            return _objectSpread$7(_objectSpread$7({}, this.bvAttrs), {}, {
                role: 'menuitem'
            });
        }
    },
    methods: {
        closeDropdown: function closeDropdown() {
            var _this = this;

            // Close on next animation frame to allow <b-link> time to process
            requestAF(function () {
                if (_this.bvDropdown) {
                    _this.bvDropdown.hide(true);
                }
            });
        },
        onClick: function onClick(event) {
            this.$emit(EVENT_NAME_CLICK, event);
            this.closeDropdown();
        }
    },
    render: function render(h) {
        var linkClass = this.linkClass,
            variant = this.variant,
            active = this.active,
            disabled = this.disabled,
            onClick = this.onClick,
            bvAttrs = this.bvAttrs;
        return h('li', {
            class: bvAttrs.class,
            style: bvAttrs.style,
            attrs: {
                role: 'presentation'
            }
        }, [h(BLink, {
            staticClass: 'dropdown-item',
            class: [linkClass, _defineProperty$a({}, "text-".concat(variant), variant && !(active || disabled))],
            props: pluckProps(linkProps$1, this.$props),
            attrs: this.computedAttrs,
            on: {
                click: onClick
            },
            ref: 'item'
        }, this.normalizeSlot())]);
    }
});

// This method returns a component's scoped style attribute name: `data-v-xxxxxxx`
// The `_scopeId` options property is added by vue-loader when using scoped styles
// and will be `undefined` if no scoped styles are in use
var getScopeId = function getScopeId(vm) {
    var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    return vm ? vm.$options._scopeId || defaultValue : defaultValue;
};

function _defineProperty$9(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var scopedStyleMixin = Vue$1.extend({
    computed: {
        scopedStyleAttrs: function scopedStyleAttrs() {
            var scopeId = getScopeId(this.$parent);
            return scopeId ? _defineProperty$9({}, scopeId, '') : {};
        }
    }
});

function _defineProperty$8(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var computeJustifyContent = function computeJustifyContent(value) {
    value = value === 'left' ? 'start' : value === 'right' ? 'end' : value;
    return "justify-content-".concat(value);
}; // --- Props ---


var props$7 = makePropsConfigurable({
    align: makeProp(PROP_TYPE_STRING),
    // Set to `true` if placing in a card header
    cardHeader: makeProp(PROP_TYPE_BOOLEAN, false),
    fill: makeProp(PROP_TYPE_BOOLEAN, false),
    justified: makeProp(PROP_TYPE_BOOLEAN, false),
    pills: makeProp(PROP_TYPE_BOOLEAN, false),
    small: makeProp(PROP_TYPE_BOOLEAN, false),
    tabs: makeProp(PROP_TYPE_BOOLEAN, false),
    tag: makeProp(PROP_TYPE_STRING, 'ul'),
    vertical: makeProp(PROP_TYPE_BOOLEAN, false)
}, NAME_NAV); // --- Main component ---
// @vue/component

var BNav = /*#__PURE__*/Vue$1.extend({
    name: NAME_NAV,
    functional: true,
    props: props$7,
    render: function render(h, _ref) {
        var _class;

        var props = _ref.props,
            data = _ref.data,
            children = _ref.children;
        var tabs = props.tabs,
            pills = props.pills,
            vertical = props.vertical,
            align = props.align,
            cardHeader = props.cardHeader;
        return h(props.tag, a(data, {
            staticClass: 'nav',
            class: (_class = {
                'nav-tabs': tabs,
                'nav-pills': pills && !tabs,
                'card-header-tabs': !vertical && cardHeader && tabs,
                'card-header-pills': !vertical && cardHeader && pills && !tabs,
                'flex-column': vertical,
                'nav-fill': !vertical && props.fill,
                'nav-justified': !vertical && props.justified
            }, _defineProperty$8(_class, computeJustifyContent(align), !vertical && align), _defineProperty$8(_class, "small", props.small), _class)
        }), children);
    }
});

function ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$6(Object(source), true).forEach(function (key) { _defineProperty$7(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty$7(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var linkProps = omit(props$d, ['event', 'routerTag']);
var props$6 = makePropsConfigurable(sortKeys(_objectSpread$6(_objectSpread$6({}, linkProps), {}, {
    linkAttrs: makeProp(PROP_TYPE_OBJECT, {}),
    linkClasses: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING)
})), NAME_NAV_ITEM); // --- Main component ---
// @vue/component

var BNavItem = /*#__PURE__*/Vue$1.extend({
    name: NAME_NAV_ITEM,
    functional: true,
    props: props$6,
    render: function render(h, _ref) {
        var props = _ref.props,
            data = _ref.data,
            listeners = _ref.listeners,
            children = _ref.children;
        return h('li', a(omit(data, ['on']), {
            staticClass: 'nav-item'
        }), [h(BLink, {
            staticClass: 'nav-link',
            class: props.linkClasses,
            attrs: props.linkAttrs,
            props: pluckProps(linkProps, props),
            on: listeners
        }, children)]);
    }
});

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray$1(arr); }

function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$5(Object(source), true).forEach(function (key) { _defineProperty$6(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty$6(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var props$5 = makePropsConfigurable(sortKeys(_objectSpread$5(_objectSpread$5({}, props$b), pick(props$9, [].concat(_toConsumableArray(keys(props$a)), ['html', 'lazy', 'menuClass', 'noCaret', 'role', 'text', 'toggleClass'])))), NAME_NAV_ITEM_DROPDOWN); // --- Main component ---
// @vue/component

var BNavItemDropdown = /*#__PURE__*/Vue$1.extend({
    name: NAME_NAV_ITEM_DROPDOWN,
    mixins: [idMixin, dropdownMixin, normalizeSlotMixin],
    props: props$5,
    computed: {
        toggleId: function toggleId() {
            return this.safeId('_BV_toggle_');
        },
        dropdownClasses: function dropdownClasses() {
            return [this.directionClass, this.boundaryClass, {
                show: this.visible
            }];
        },
        menuClasses: function menuClasses() {
            return [this.menuClass, {
                'dropdown-menu-right': this.right,
                show: this.visible
            }];
        },
        toggleClasses: function toggleClasses() {
            return [this.toggleClass, {
                'dropdown-toggle-no-caret': this.noCaret
            }];
        }
    },
    render: function render(h) {
        var toggleId = this.toggleId,
            visible = this.visible,
            hide = this.hide;
        var $toggle = h(BLink, {
            staticClass: 'nav-link dropdown-toggle',
            class: this.toggleClasses,
            props: {
                href: "#".concat(this.id || ''),
                disabled: this.disabled
            },
            attrs: {
                id: toggleId,
                role: 'button',
                'aria-haspopup': 'true',
                'aria-expanded': visible ? 'true' : 'false'
            },
            on: {
                mousedown: this.onMousedown,
                click: this.toggle,
                keydown: this.toggle // Handle ENTER, SPACE and DOWN

            },
            ref: 'toggle'
        }, [// TODO: The `text` slot is deprecated in favor of the `button-content` slot
            this.normalizeSlot([SLOT_NAME_BUTTON_CONTENT, SLOT_NAME_TEXT]) || h('span', {
                domProps: htmlOrText(this.html, this.text)
            })]);
        var $menu = h('ul', {
            staticClass: 'dropdown-menu',
            class: this.menuClasses,
            attrs: {
                tabindex: '-1',
                'aria-labelledby': toggleId
            },
            on: {
                keydown: this.onKeydown // Handle UP, DOWN and ESC

            },
            ref: 'menu'
        }, !this.lazy || visible ? this.normalizeSlot(SLOT_NAME_DEFAULT, {
            hide: hide
        }) : [h()]);
        return h('li', {
            staticClass: 'nav-item b-nav-dropdown dropdown',
            class: this.dropdownClasses,
            attrs: {
                id: this.safeId()
            }
        }, [$toggle, $menu]);
    }
});

// Base on-demand component for tooltip / popover templates

var AttachmentMap = {
    AUTO: 'auto',
    TOP: 'top',
    RIGHT: 'right',
    BOTTOM: 'bottom',
    LEFT: 'left',
    TOPLEFT: 'top',
    TOPRIGHT: 'top',
    RIGHTTOP: 'right',
    RIGHTBOTTOM: 'right',
    BOTTOMLEFT: 'bottom',
    BOTTOMRIGHT: 'bottom',
    LEFTTOP: 'left',
    LEFTBOTTOM: 'left'
};
var OffsetMap = {
    AUTO: 0,
    TOPLEFT: -1,
    TOP: 0,
    TOPRIGHT: +1,
    RIGHTTOP: -1,
    RIGHT: 0,
    RIGHTBOTTOM: +1,
    BOTTOMLEFT: -1,
    BOTTOM: 0,
    BOTTOMRIGHT: +1,
    LEFTTOP: -1,
    LEFT: 0,
    LEFTBOTTOM: +1
}; // --- Props ---

var props$4 = {
    // The minimum distance (in `px`) from the edge of the
    // tooltip/popover that the arrow can be positioned
    arrowPadding: makeProp(PROP_TYPE_NUMBER_STRING, 6),
    // 'scrollParent', 'viewport', 'window', or `Element`
    boundary: makeProp([HTMLElement, PROP_TYPE_STRING], 'scrollParent'),
    // Tooltip/popover will try and stay away from
    // boundary edge by this many pixels
    boundaryPadding: makeProp(PROP_TYPE_NUMBER_STRING, 5),
    fallbackPlacement: makeProp(PROP_TYPE_ARRAY_STRING, 'flip'),
    offset: makeProp(PROP_TYPE_NUMBER_STRING, 0),
    placement: makeProp(PROP_TYPE_STRING, 'top'),
    // Element that the tooltip/popover is positioned relative to
    target: makeProp([HTMLElement, SVGElement])
}; // --- Main component ---
// @vue/component

var BVPopper = /*#__PURE__*/Vue$1.extend({
    name: NAME_POPPER,
    props: props$4,
    data: function data() {
        return {
            // reactive props set by parent
            noFade: false,
            // State related data
            localShow: true,
            attachment: this.getAttachment(this.placement)
        };
    },
    computed: {
        /* istanbul ignore next */
        templateType: function templateType() {
            // Overridden by template component
            return 'unknown';
        },
        popperConfig: function popperConfig() {
            var _this = this;

            var placement = this.placement;
            return {
                placement: this.getAttachment(placement),
                modifiers: {
                    offset: {
                        offset: this.getOffset(placement)
                    },
                    flip: {
                        behavior: this.fallbackPlacement
                    },
                    // `arrow.element` can also be a reference to an HTML Element
                    // maybe we should make this a `$ref` in the templates?
                    arrow: {
                        element: '.arrow'
                    },
                    preventOverflow: {
                        padding: this.boundaryPadding,
                        boundariesElement: this.boundary
                    }
                },
                onCreate: function onCreate(data) {
                    // Handle flipping arrow classes
                    if (data.originalPlacement !== data.placement) {
                        /* istanbul ignore next: can't test in JSDOM */
                        _this.popperPlacementChange(data);
                    }
                },
                onUpdate: function onUpdate(data) {
                    // Handle flipping arrow classes
                    _this.popperPlacementChange(data);
                }
            };
        }
    },
    created: function created() {
        var _this2 = this;

        // Note: We are created on-demand, and should be guaranteed that
        // DOM is rendered/ready by the time the created hook runs
        this.$_popper = null; // Ensure we show as we mount

        this.localShow = true; // Create popper instance before shown

        this.$on(EVENT_NAME_SHOW, function (el) {
            _this2.popperCreate(el);
        }); // Self destruct handler

        var handleDestroy = function handleDestroy() {
            _this2.$nextTick(function () {
                // In a `requestAF()` to release control back to application
                requestAF(function () {
                    _this2.$destroy();
                });
            });
        }; // Self destruct if parent destroyed


        this.$parent.$once(HOOK_EVENT_NAME_DESTROYED, handleDestroy); // Self destruct after hidden

        this.$once(EVENT_NAME_HIDDEN, handleDestroy);
    },
    beforeMount: function beforeMount() {
        // Ensure that the attachment position is correct before mounting
        // as our propsData is added after `new Template({...})`
        this.attachment = this.getAttachment(this.placement);
    },
    updated: function updated() {
        // Update popper if needed
        // TODO: Should this be a watcher on `this.popperConfig` instead?
        this.updatePopper();
    },
    beforeDestroy: function beforeDestroy() {
        this.destroyPopper();
    },
    destroyed: function destroyed() {
        // Make sure template is removed from DOM
        var el = this.$el;
        el && el.parentNode && el.parentNode.removeChild(el);
    },
    methods: {
        // "Public" method to trigger hide template
        hide: function hide() {
            this.localShow = false;
        },
        // Private
        getAttachment: function getAttachment(placement) {
            return AttachmentMap[String(placement).toUpperCase()] || 'auto';
        },
        getOffset: function getOffset(placement) {
            if (!this.offset) {
                // Could set a ref for the arrow element
                var arrow = this.$refs.arrow || select('.arrow', this.$el);
                var arrowOffset = toFloat(getCS(arrow).width, 0) + toFloat(this.arrowPadding, 0);

                switch (OffsetMap[String(placement).toUpperCase()] || 0) {
                    /* istanbul ignore next: can't test in JSDOM */
                    case +1:
                        /* istanbul ignore next: can't test in JSDOM */
                        return "+50%p - ".concat(arrowOffset, "px");

                    /* istanbul ignore next: can't test in JSDOM */

                    case -1:
                        /* istanbul ignore next: can't test in JSDOM */
                        return "-50%p + ".concat(arrowOffset, "px");

                    default:
                        return 0;
                }
            }
            /* istanbul ignore next */


            return this.offset;
        },
        popperCreate: function popperCreate(el) {
            this.destroyPopper(); // We use `el` rather than `this.$el` just in case the original
            // mountpoint root element type was changed by the template

            this.$_popper = new Popper(this.target, el, this.popperConfig);
        },
        destroyPopper: function destroyPopper() {
            this.$_popper && this.$_popper.destroy();
            this.$_popper = null;
        },
        updatePopper: function updatePopper() {
            this.$_popper && this.$_popper.scheduleUpdate();
        },
        popperPlacementChange: function popperPlacementChange(data) {
            // Callback used by popper to adjust the arrow placement
            this.attachment = this.getAttachment(data.placement);
        },

        /* istanbul ignore next */
        renderTemplate: function renderTemplate(h) {
            // Will be overridden by templates
            return h('div');
        }
    },
    render: function render(h) {
        var _this3 = this;

        var noFade = this.noFade; // Note: 'show' and 'fade' classes are only appled during transition

        return h(BVTransition, {
            // Transitions as soon as mounted
            props: {
                appear: true,
                noFade: noFade
            },
            on: {
                // Events used by parent component/instance
                beforeEnter: function beforeEnter(el) {
                    return _this3.$emit(EVENT_NAME_SHOW, el);
                },
                afterEnter: function afterEnter(el) {
                    return _this3.$emit(EVENT_NAME_SHOWN, el);
                },
                beforeLeave: function beforeLeave(el) {
                    return _this3.$emit(EVENT_NAME_HIDE, el);
                },
                afterLeave: function afterLeave(el) {
                    return _this3.$emit(EVENT_NAME_HIDDEN, el);
                }
            }
        }, [this.localShow ? this.renderTemplate(h) : h()]);
    }
});

function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(Object(source), true).forEach(function (key) { _defineProperty$5(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty$5(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var props$3 = {
    // Used only by the directive versions
    html: makeProp(PROP_TYPE_BOOLEAN, false),
    // Other non-reactive (while open) props are pulled in from BVPopper
    id: makeProp(PROP_TYPE_STRING)
}; // --- Main component ---
// @vue/component

var BVTooltipTemplate = /*#__PURE__*/Vue$1.extend({
    name: NAME_TOOLTIP_TEMPLATE,
    extends: BVPopper,
    mixins: [scopedStyleMixin],
    props: props$3,
    data: function data() {
        // We use data, rather than props to ensure reactivity
        // Parent component will directly set this data
        return {
            title: '',
            content: '',
            variant: null,
            customClass: null,
            interactive: true
        };
    },
    computed: {
        templateType: function templateType() {
            return 'tooltip';
        },
        templateClasses: function templateClasses() {
            var _ref;

            var variant = this.variant,
                attachment = this.attachment,
                templateType = this.templateType;
            return [(_ref = {
                // Disables pointer events to hide the tooltip when the user
                // hovers over its content
                noninteractive: !this.interactive
            }, _defineProperty$5(_ref, "b-".concat(templateType, "-").concat(variant), variant), _defineProperty$5(_ref, "bs-".concat(templateType, "-").concat(attachment), attachment), _ref), this.customClass];
        },
        templateAttributes: function templateAttributes() {
            var id = this.id;
            return _objectSpread$4(_objectSpread$4({}, this.$parent.$parent.$attrs), {}, {
                id: id,
                role: 'tooltip',
                tabindex: '-1'
            }, this.scopedStyleAttrs);
        },
        templateListeners: function templateListeners() {
            var _this = this;

            // Used for hover/focus trigger listeners
            return {
                mouseenter:
                /* istanbul ignore next */
                    function mouseenter(event) {
                        _this.$emit(EVENT_NAME_MOUSEENTER, event);
                    },
                mouseleave:
                /* istanbul ignore next */
                    function mouseleave(event) {
                        _this.$emit(EVENT_NAME_MOUSELEAVE, event);
                    },
                focusin:
                /* istanbul ignore next */
                    function focusin(event) {
                        _this.$emit(EVENT_NAME_FOCUSIN, event);
                    },
                focusout:
                /* istanbul ignore next */
                    function focusout(event) {
                        _this.$emit(EVENT_NAME_FOCUSOUT, event);
                    }
            };
        }
    },
    methods: {
        renderTemplate: function renderTemplate(h) {
            var title = this.title; // Title can be a scoped slot function

            var $title = isFunction$1(title) ? title({}) : title; // Directive versions only

            var domProps = this.html && !isFunction$1(title) ? {
                innerHTML: title
            } : {};
            return h('div', {
                staticClass: 'tooltip b-tooltip',
                class: this.templateClasses,
                attrs: this.templateAttributes,
                on: this.templateListeners
            }, [h('div', {
                staticClass: 'arrow',
                ref: 'arrow'
            }), h('div', {
                staticClass: 'tooltip-inner',
                domProps: domProps
            }, [$title])]);
        }
    }
});

function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty$4(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty$4(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// Modal container selector for appending tooltip/popover

var MODAL_SELECTOR = '.modal-content'; // Modal `$root` hidden event

var ROOT_EVENT_NAME_MODAL_HIDDEN = getRootEventName(NAME_MODAL, EVENT_NAME_HIDDEN); // Sidebar container selector for appending tooltip/popover

var SIDEBAR_SELECTOR = '.b-sidebar'; // For finding the container to append to

var CONTAINER_SELECTOR = [MODAL_SELECTOR, SIDEBAR_SELECTOR].join(', '); // For dropdown sniffing

var DROPDOWN_CLASS = 'dropdown';
var DROPDOWN_OPEN_SELECTOR = '.dropdown-menu.show'; // Data attribute to temporary store the `title` attribute's value

var DATA_TITLE_ATTR = 'data-original-title'; // Data specific to popper and template
// We don't use props, as we need reactivity (we can't pass reactive props)

var templateData = {
    // Text string or Scoped slot function
    title: '',
    // Text string or Scoped slot function
    content: '',
    // String
    variant: null,
    // String, Array, Object
    customClass: null,
    // String or array of Strings (overwritten by BVPopper)
    triggers: '',
    // String (overwritten by BVPopper)
    placement: 'auto',
    // String or array of strings
    fallbackPlacement: 'flip',
    // Element or Component reference (or function that returns element) of
    // the element that will have the trigger events bound, and is also
    // default element for positioning
    target: null,
    // HTML ID, Element or Component reference
    container: null,
    // 'body'
    // Boolean
    noFade: false,
    // 'scrollParent', 'viewport', 'window', Element, or Component reference
    boundary: 'scrollParent',
    // Tooltip/popover will try and stay away from
    // boundary edge by this many pixels (Number)
    boundaryPadding: 5,
    // Arrow offset (Number)
    offset: 0,
    // Hover/focus delay (Number or Object)
    delay: 0,
    // Arrow of Tooltip/popover will try and stay away from
    // the edge of tooltip/popover edge by this many pixels
    arrowPadding: 6,
    // Interactive state (Boolean)
    interactive: true,
    // Disabled state (Boolean)
    disabled: false,
    // ID to use for tooltip/popover
    id: null,
    // Flag used by directives only, for HTML content
    html: false
}; // --- Main component ---
// @vue/component

var BVTooltip = /*#__PURE__*/Vue$1.extend({
    name: NAME_TOOLTIP_HELPER,
    mixins: [listenOnRootMixin],
    data: function data() {
        return _objectSpread$3(_objectSpread$3({}, templateData), {}, {
            // State management data
            activeTrigger: {
                // manual: false,
                hover: false,
                click: false,
                focus: false
            },
            localShow: false
        });
    },
    computed: {
        templateType: function templateType() {
            // Overwritten by BVPopover
            return 'tooltip';
        },
        computedId: function computedId() {
            return this.id || "__bv_".concat(this.templateType, "_").concat(this[COMPONENT_UID_KEY], "__");
        },
        computedDelay: function computedDelay() {
            // Normalizes delay into object form
            var delay = {
                show: 0,
                hide: 0
            };

            if (isPlainObject(this.delay)) {
                delay.show = mathMax(toInteger(this.delay.show, 0), 0);
                delay.hide = mathMax(toInteger(this.delay.hide, 0), 0);
            } else if (isNumber(this.delay) || isString$1(this.delay)) {
                delay.show = delay.hide = mathMax(toInteger(this.delay, 0), 0);
            }

            return delay;
        },
        computedTriggers: function computedTriggers() {
            // Returns the triggers in sorted array form
            // TODO: Switch this to object form for easier lookup
            return concat(this.triggers).filter(identity).join(' ').trim().toLowerCase().split(/\s+/).sort();
        },
        isWithActiveTrigger: function isWithActiveTrigger() {
            for (var trigger in this.activeTrigger) {
                if (this.activeTrigger[trigger]) {
                    return true;
                }
            }

            return false;
        },
        computedTemplateData: function computedTemplateData() {
            var title = this.title,
                content = this.content,
                variant = this.variant,
                customClass = this.customClass,
                noFade = this.noFade,
                interactive = this.interactive;
            return {
                title: title,
                content: content,
                variant: variant,
                customClass: customClass,
                noFade: noFade,
                interactive: interactive
            };
        }
    },
    watch: {
        computedTriggers: function computedTriggers(newTriggers, oldTriggers) {
            var _this = this;

            // Triggers have changed, so re-register them

            /* istanbul ignore next */
            if (!looseEqual(newTriggers, oldTriggers)) {
                this.$nextTick(function () {
                    // Disable trigger listeners
                    _this.unListen(); // Clear any active triggers that are no longer in the list of triggers


                    oldTriggers.forEach(function (trigger) {
                        if (!arrayIncludes(newTriggers, trigger)) {
                            if (_this.activeTrigger[trigger]) {
                                _this.activeTrigger[trigger] = false;
                            }
                        }
                    }); // Re-enable the trigger listeners

                    _this.listen();
                });
            }
        },
        computedTemplateData: function computedTemplateData() {
            // If any of the while open reactive "props" change,
            // ensure that the template updates accordingly
            this.handleTemplateUpdate();
        },
        title: function title(newValue, oldValue) {
            // Make sure to hide the tooltip when the title is set empty
            if (newValue !== oldValue && !newValue) {
                this.hide();
            }
        },
        disabled: function disabled(newValue) {
            if (newValue) {
                this.disable();
            } else {
                this.enable();
            }
        }
    },
    created: function created() {
        var _this2 = this;

        // Create non-reactive properties
        this.$_tip = null;
        this.$_hoverTimeout = null;
        this.$_hoverState = '';
        this.$_visibleInterval = null;
        this.$_enabled = !this.disabled;
        this.$_noop = noop.bind(this); // Destroy ourselves when the parent is destroyed

        if (this.$parent) {
            this.$parent.$once(HOOK_EVENT_NAME_BEFORE_DESTROY, function () {
                _this2.$nextTick(function () {
                    // In a `requestAF()` to release control back to application
                    requestAF(function () {
                        _this2.$destroy();
                    });
                });
            });
        }

        this.$nextTick(function () {
            var target = _this2.getTarget();

            if (target && contains(document.body, target)) {
                // Copy the parent's scoped style attribute
                _this2.scopeId = getScopeId(_this2.$parent); // Set up all trigger handlers and listeners

                _this2.listen();
            } else {
                /* istanbul ignore next */
                warn(isString$1(_this2.target) ? "Unable to find target element by ID \"#".concat(_this2.target, "\" in document.") : 'The provided target is no valid HTML element.', _this2.templateType);
            }
        });
    },

    /* istanbul ignore next */
    updated: function updated() {
        // Usually called when the slots/data changes
        this.$nextTick(this.handleTemplateUpdate);
    },

    /* istanbul ignore next */
    deactivated: function deactivated() {
        // In a keepalive that has been deactivated, so hide
        // the tooltip/popover if it is showing
        this.forceHide();
    },
    beforeDestroy: function beforeDestroy() {
        // Remove all handler/listeners
        this.unListen();
        this.setWhileOpenListeners(false); // Clear any timeouts/intervals

        this.clearHoverTimeout();
        this.clearVisibilityInterval(); // Destroy the template

        this.destroyTemplate(); // Remove any other private properties created during create

        this.$_noop = null;
    },
    methods: {
        // --- Methods for creating and destroying the template ---
        getTemplate: function getTemplate() {
            // Overridden by BVPopover
            return BVTooltipTemplate;
        },
        updateData: function updateData() {
            var _this3 = this;

            var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            // Method for updating popper/template data
            // We only update data if it exists, and has not changed
            var titleUpdated = false;
            keys(templateData).forEach(function (prop) {
                if (!isUndefined(data[prop]) && _this3[prop] !== data[prop]) {
                    _this3[prop] = data[prop];

                    if (prop === 'title') {
                        titleUpdated = true;
                    }
                }
            }); // If the title has updated, we may need to handle the `title`
            // attribute on the trigger target
            // We only do this while the template is open

            if (titleUpdated && this.localShow) {
                this.fixTitle();
            }
        },
        createTemplateAndShow: function createTemplateAndShow() {
            // Creates the template instance and show it
            var container = this.getContainer();
            var Template = this.getTemplate();
            var $tip = this.$_tip = new Template({
                parent: this,
                // The following is not reactive to changes in the props data
                propsData: {
                    // These values cannot be changed while template is showing
                    id: this.computedId,
                    html: this.html,
                    placement: this.placement,
                    fallbackPlacement: this.fallbackPlacement,
                    target: this.getPlacementTarget(),
                    boundary: this.getBoundary(),
                    // Ensure the following are integers
                    offset: toInteger(this.offset, 0),
                    arrowPadding: toInteger(this.arrowPadding, 0),
                    boundaryPadding: toInteger(this.boundaryPadding, 0)
                }
            }); // We set the initial reactive data (values that can be changed while open)

            this.handleTemplateUpdate(); // Template transition phase events (handled once only)
            // When the template has mounted, but not visibly shown yet

            $tip.$once(EVENT_NAME_SHOW, this.onTemplateShow); // When the template has completed showing

            $tip.$once(EVENT_NAME_SHOWN, this.onTemplateShown); // When the template has started to hide

            $tip.$once(EVENT_NAME_HIDE, this.onTemplateHide); // When the template has completed hiding

            $tip.$once(EVENT_NAME_HIDDEN, this.onTemplateHidden); // When the template gets destroyed for any reason

            $tip.$once(HOOK_EVENT_NAME_DESTROYED, this.destroyTemplate); // Convenience events from template
            // To save us from manually adding/removing DOM
            // listeners to tip element when it is open

            $tip.$on(EVENT_NAME_FOCUSIN, this.handleEvent);
            $tip.$on(EVENT_NAME_FOCUSOUT, this.handleEvent);
            $tip.$on(EVENT_NAME_MOUSEENTER, this.handleEvent);
            $tip.$on(EVENT_NAME_MOUSELEAVE, this.handleEvent); // Mount (which triggers the `show`)

            $tip.$mount(container.appendChild(document.createElement('div'))); // Template will automatically remove its markup from DOM when hidden
        },
        hideTemplate: function hideTemplate() {
            // Trigger the template to start hiding
            // The template will emit the `hide` event after this and
            // then emit the `hidden` event once it is fully hidden
            // The `hook:destroyed` will also be called (safety measure)
            this.$_tip && this.$_tip.hide(); // Clear out any stragging active triggers

            this.clearActiveTriggers(); // Reset the hover state

            this.$_hoverState = '';
        },
        // Destroy the template instance and reset state
        destroyTemplate: function destroyTemplate() {
            this.setWhileOpenListeners(false);
            this.clearHoverTimeout();
            this.$_hoverState = '';
            this.clearActiveTriggers();
            this.localPlacementTarget = null;

            try {
                this.$_tip.$destroy();
            } catch (_unused) {}

            this.$_tip = null;
            this.removeAriaDescribedby();
            this.restoreTitle();
            this.localShow = false;
        },
        getTemplateElement: function getTemplateElement() {
            return this.$_tip ? this.$_tip.$el : null;
        },
        handleTemplateUpdate: function handleTemplateUpdate() {
            var _this4 = this;

            // Update our template title/content "props"
            // So that the template updates accordingly
            var $tip = this.$_tip;

            if ($tip) {
                var props = ['title', 'content', 'variant', 'customClass', 'noFade', 'interactive']; // Only update the values if they have changed

                props.forEach(function (prop) {
                    if ($tip[prop] !== _this4[prop]) {
                        $tip[prop] = _this4[prop];
                    }
                });
            }
        },
        // --- Show/Hide handlers ---
        // Show the tooltip
        show: function show() {
            var target = this.getTarget();

            if (!target || !contains(document.body, target) || !isVisible(target) || this.dropdownOpen() || (isUndefinedOrNull(this.title) || this.title === '') && (isUndefinedOrNull(this.content) || this.content === '')) {
                // If trigger element isn't in the DOM or is not visible, or
                // is on an open dropdown toggle, or has no content, then
                // we exit without showing
                return;
            } // If tip already exists, exit early


            if (this.$_tip || this.localShow) {
                /* istanbul ignore next */
                return;
            } // In the process of showing


            this.localShow = true; // Create a cancelable BvEvent

            var showEvt = this.buildEvent(EVENT_NAME_SHOW, {
                cancelable: true
            });
            this.emitEvent(showEvt); // Don't show if event cancelled

            /* istanbul ignore if */

            if (showEvt.defaultPrevented) {
                // Destroy the template (if for some reason it was created)
                this.destroyTemplate();
                return;
            } // Fix the title attribute on target


            this.fixTitle(); // Set aria-describedby on target

            this.addAriaDescribedby(); // Create and show the tooltip

            this.createTemplateAndShow();
        },
        hide: function hide() {
            var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            // Hide the tooltip
            var tip = this.getTemplateElement();
            /* istanbul ignore if */

            if (!tip || !this.localShow) {
                this.restoreTitle();
                return;
            } // Emit cancelable BvEvent 'hide'
            // We disable cancelling if `force` is true


            var hideEvt = this.buildEvent(EVENT_NAME_HIDE, {
                cancelable: !force
            });
            this.emitEvent(hideEvt);
            /* istanbul ignore if: ignore for now */

            if (hideEvt.defaultPrevented) {
                // Don't hide if event cancelled
                return;
            } // Tell the template to hide


            this.hideTemplate();
        },
        forceHide: function forceHide() {
            // Forcefully hides/destroys the template, regardless of any active triggers
            var tip = this.getTemplateElement();

            if (!tip || !this.localShow) {
                /* istanbul ignore next */
                return;
            } // Disable while open listeners/watchers
            // This is also done in the template `hide` event handler


            this.setWhileOpenListeners(false); // Clear any hover enter/leave event

            this.clearHoverTimeout();
            this.$_hoverState = '';
            this.clearActiveTriggers(); // Disable the fade animation on the template

            if (this.$_tip) {
                this.$_tip.noFade = true;
            } // Hide the tip (with force = true)


            this.hide(true);
        },
        enable: function enable() {
            this.$_enabled = true; // Create a non-cancelable BvEvent

            this.emitEvent(this.buildEvent(EVENT_NAME_ENABLED));
        },
        disable: function disable() {
            this.$_enabled = false; // Create a non-cancelable BvEvent

            this.emitEvent(this.buildEvent(EVENT_NAME_DISABLED));
        },
        // --- Handlers for template events ---
        // When template is inserted into DOM, but not yet shown
        onTemplateShow: function onTemplateShow() {
            // Enable while open listeners/watchers
            this.setWhileOpenListeners(true);
        },
        // When template show transition completes
        onTemplateShown: function onTemplateShown() {
            var prevHoverState = this.$_hoverState;
            this.$_hoverState = '';
            /* istanbul ignore next: occasional Node 10 coverage error */

            if (prevHoverState === 'out') {
                this.leave(null);
            } // Emit a non-cancelable BvEvent 'shown'


            this.emitEvent(this.buildEvent(EVENT_NAME_SHOWN));
        },
        // When template is starting to hide
        onTemplateHide: function onTemplateHide() {
            // Disable while open listeners/watchers
            this.setWhileOpenListeners(false);
        },
        // When template has completed closing (just before it self destructs)
        onTemplateHidden: function onTemplateHidden() {
            // Destroy the template
            this.destroyTemplate(); // Emit a non-cancelable BvEvent 'shown'

            this.emitEvent(this.buildEvent(EVENT_NAME_HIDDEN));
        },
        // --- Helper methods ---
        getTarget: function getTarget() {
            var target = this.target;

            if (isString$1(target)) {
                target = getById(target.replace(/^#/, ''));
            } else if (isFunction$1(target)) {
                target = target();
            } else if (target) {
                target = target.$el || target;
            }

            return isElement(target) ? target : null;
        },
        getPlacementTarget: function getPlacementTarget() {
            // This is the target that the tooltip will be placed on, which may not
            // necessarily be the same element that has the trigger event listeners
            // For now, this is the same as target
            // TODO:
            //   Add in child selector support
            //   Add in visibility checks for this element
            //   Fallback to target if not found
            return this.getTarget();
        },
        getTargetId: function getTargetId() {
            // Returns the ID of the trigger element
            var target = this.getTarget();
            return target && target.id ? target.id : null;
        },
        getContainer: function getContainer() {
            // Handle case where container may be a component ref
            var container = this.container ? this.container.$el || this.container : false;
            var body = document.body;
            var target = this.getTarget(); // If we are in a modal, we append to the modal, If we
            // are in a sidebar, we append to the sidebar, else append
            // to body, unless a container is specified
            // TODO:
            //   Template should periodically check to see if it is in dom
            //   And if not, self destruct (if container got v-if'ed out of DOM)
            //   Or this could possibly be part of the visibility check

            return container === false ? closest(CONTAINER_SELECTOR, target) || body :
                /*istanbul ignore next */
                isString$1(container) ?
                    /*istanbul ignore next */
                    getById(container.replace(/^#/, '')) || body :
                    /*istanbul ignore next */
                    body;
        },
        getBoundary: function getBoundary() {
            return this.boundary ? this.boundary.$el || this.boundary : 'scrollParent';
        },
        isInModal: function isInModal() {
            var target = this.getTarget();
            return target && closest(MODAL_SELECTOR, target);
        },
        isDropdown: function isDropdown() {
            // Returns true if trigger is a dropdown
            var target = this.getTarget();
            return target && hasClass(target, DROPDOWN_CLASS);
        },
        dropdownOpen: function dropdownOpen() {
            // Returns true if trigger is a dropdown and the dropdown menu is open
            var target = this.getTarget();
            return this.isDropdown() && target && select(DROPDOWN_OPEN_SELECTOR, target);
        },
        clearHoverTimeout: function clearHoverTimeout() {
            clearTimeout(this.$_hoverTimeout);
            this.$_hoverTimeout = null;
        },
        clearVisibilityInterval: function clearVisibilityInterval() {
            clearInterval(this.$_visibleInterval);
            this.$_visibleInterval = null;
        },
        clearActiveTriggers: function clearActiveTriggers() {
            for (var trigger in this.activeTrigger) {
                this.activeTrigger[trigger] = false;
            }
        },
        addAriaDescribedby: function addAriaDescribedby() {
            // Add aria-describedby on trigger element, without removing any other IDs
            var target = this.getTarget();
            var desc = getAttr(target, 'aria-describedby') || '';
            desc = desc.split(/\s+/).concat(this.computedId).join(' ').trim(); // Update/add aria-described by

            setAttr(target, 'aria-describedby', desc);
        },
        removeAriaDescribedby: function removeAriaDescribedby() {
            var _this5 = this;

            // Remove aria-describedby on trigger element, without removing any other IDs
            var target = this.getTarget();
            var desc = getAttr(target, 'aria-describedby') || '';
            desc = desc.split(/\s+/).filter(function (d) {
                return d !== _this5.computedId;
            }).join(' ').trim(); // Update or remove aria-describedby

            if (desc) {
                /* istanbul ignore next */
                setAttr(target, 'aria-describedby', desc);
            } else {
                removeAttr(target, 'aria-describedby');
            }
        },
        fixTitle: function fixTitle() {
            // If the target has a `title` attribute,
            // remove it and store it on a data attribute
            var target = this.getTarget();

            if (hasAttr(target, 'title')) {
                // Get `title` attribute value and remove it from target
                var title = getAttr(target, 'title');
                setAttr(target, 'title', ''); // Only set the data attribute when the value is truthy

                if (title) {
                    setAttr(target, DATA_TITLE_ATTR, title);
                }
            }
        },
        restoreTitle: function restoreTitle() {
            // If the target had a `title` attribute,
            // restore it and remove the data attribute
            var target = this.getTarget();

            if (hasAttr(target, DATA_TITLE_ATTR)) {
                // Get data attribute value and remove it from target
                var title = getAttr(target, DATA_TITLE_ATTR);
                removeAttr(target, DATA_TITLE_ATTR); // Only restore the `title` attribute when the value is truthy

                if (title) {
                    setAttr(target, 'title', title);
                }
            }
        },
        // --- BvEvent helpers ---
        buildEvent: function buildEvent(type) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            // Defaults to a non-cancellable event
            return new BvEvent(type, _objectSpread$3({
                cancelable: false,
                target: this.getTarget(),
                relatedTarget: this.getTemplateElement() || null,
                componentId: this.computedId,
                vueTarget: this
            }, options));
        },
        emitEvent: function emitEvent(bvEvent) {
            var type = bvEvent.type;
            this.emitOnRoot(getRootEventName(this.templateType, type), bvEvent);
            this.$emit(type, bvEvent);
        },
        // --- Event handler setup methods ---
        listen: function listen() {
            var _this6 = this;

            // Enable trigger event handlers
            var el = this.getTarget();

            if (!el) {
                /* istanbul ignore next */
                return;
            } // Listen for global show/hide events


            this.setRootListener(true); // Set up our listeners on the target trigger element

            this.computedTriggers.forEach(function (trigger) {
                if (trigger === 'click') {
                    eventOn(el, 'click', _this6.handleEvent, EVENT_OPTIONS_NO_CAPTURE);
                } else if (trigger === 'focus') {
                    eventOn(el, 'focusin', _this6.handleEvent, EVENT_OPTIONS_NO_CAPTURE);
                    eventOn(el, 'focusout', _this6.handleEvent, EVENT_OPTIONS_NO_CAPTURE);
                } else if (trigger === 'blur') {
                    // Used to close $tip when element looses focus

                    /* istanbul ignore next */
                    eventOn(el, 'focusout', _this6.handleEvent, EVENT_OPTIONS_NO_CAPTURE);
                } else if (trigger === 'hover') {
                    eventOn(el, 'mouseenter', _this6.handleEvent, EVENT_OPTIONS_NO_CAPTURE);
                    eventOn(el, 'mouseleave', _this6.handleEvent, EVENT_OPTIONS_NO_CAPTURE);
                }
            }, this);
        },

        /* istanbul ignore next */
        unListen: function unListen() {
            var _this7 = this;

            // Remove trigger event handlers
            var events = ['click', 'focusin', 'focusout', 'mouseenter', 'mouseleave'];
            var target = this.getTarget(); // Stop listening for global show/hide/enable/disable events

            this.setRootListener(false); // Clear out any active target listeners

            events.forEach(function (event) {
                target && eventOff(target, event, _this7.handleEvent, EVENT_OPTIONS_NO_CAPTURE);
            }, this);
        },
        setRootListener: function setRootListener(on) {
            // Listen for global `bv::{hide|show}::{tooltip|popover}` hide request event
            var $root = this.$root;

            if ($root) {
                var method = on ? '$on' : '$off';
                var type = this.templateType;
                $root[method](getRootActionEventName(type, EVENT_NAME_HIDE), this.doHide);
                $root[method](getRootActionEventName(type, EVENT_NAME_SHOW), this.doShow);
                $root[method](getRootActionEventName(type, EVENT_NAME_DISABLE), this.doDisable);
                $root[method](getRootActionEventName(type, EVENT_NAME_ENABLE), this.doEnable);
            }
        },
        setWhileOpenListeners: function setWhileOpenListeners(on) {
            // Events that are only registered when the template is showing
            // Modal close events
            this.setModalListener(on); // Dropdown open events (if we are attached to a dropdown)

            this.setDropdownListener(on); // Periodic $element visibility check
            // For handling when tip target is in <keepalive>, tabs, carousel, etc

            this.visibleCheck(on); // On-touch start listeners

            this.setOnTouchStartListener(on);
        },
        // Handler for periodic visibility check
        visibleCheck: function visibleCheck(on) {
            var _this8 = this;

            this.clearVisibilityInterval();
            var target = this.getTarget();
            var tip = this.getTemplateElement();

            if (on) {
                this.$_visibleInterval = setInterval(function () {
                    if (tip && _this8.localShow && (!target.parentNode || !isVisible(target))) {
                        // Target element is no longer visible or not in DOM, so force-hide the tooltip
                        _this8.forceHide();
                    }
                }, 100);
            }
        },
        setModalListener: function setModalListener(on) {
            // Handle case where tooltip/target is in a modal
            if (this.isInModal()) {
                // We can listen for modal hidden events on `$root`
                this.$root[on ? '$on' : '$off'](ROOT_EVENT_NAME_MODAL_HIDDEN, this.forceHide);
            }
        },

        /* istanbul ignore next: JSDOM doesn't support `ontouchstart` */
        setOnTouchStartListener: function setOnTouchStartListener(on) {
            var _this9 = this;

            // If this is a touch-enabled device we add extra empty
            // `mouseover` listeners to the body's immediate children
            // Only needed because of broken event delegation on iOS
            // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
            if ('ontouchstart' in document.documentElement) {
                from(document.body.children).forEach(function (el) {
                    eventOnOff(on, el, 'mouseover', _this9.$_noop);
                });
            }
        },
        setDropdownListener: function setDropdownListener(on) {
            var target = this.getTarget();

            if (!target || !this.$root || !this.isDropdown) {
                return;
            } // We can listen for dropdown shown events on its instance
            // TODO:
            //   We could grab the ID from the dropdown, and listen for
            //   $root events for that particular dropdown id
            //   Dropdown shown and hidden events will need to emit
            //   Note: Dropdown auto-ID happens in a `$nextTick()` after mount
            //         So the ID lookup would need to be done in a `$nextTick()`


            if (target.__vue__) {
                target.__vue__[on ? '$on' : '$off'](EVENT_NAME_SHOWN, this.forceHide);
            }
        },
        // --- Event handlers ---
        handleEvent: function handleEvent(event) {
            // General trigger event handler
            // target is the trigger element
            var target = this.getTarget();

            if (!target || isDisabled(target) || !this.$_enabled || this.dropdownOpen()) {
                // If disabled or not enabled, or if a dropdown that is open, don't do anything
                // If tip is shown before element gets disabled, then tip will not
                // close until no longer disabled or forcefully closed
                return;
            }

            var type = event.type;
            var triggers = this.computedTriggers;

            if (type === 'click' && arrayIncludes(triggers, 'click')) {
                this.click(event);
            } else if (type === 'mouseenter' && arrayIncludes(triggers, 'hover')) {
                // `mouseenter` is a non-bubbling event
                this.enter(event);
            } else if (type === 'focusin' && arrayIncludes(triggers, 'focus')) {
                // `focusin` is a bubbling event
                // `event` includes `relatedTarget` (element losing focus)
                this.enter(event);
            } else if (type === 'focusout' && (arrayIncludes(triggers, 'focus') || arrayIncludes(triggers, 'blur')) || type === 'mouseleave' && arrayIncludes(triggers, 'hover')) {
                // `focusout` is a bubbling event
                // `mouseleave` is a non-bubbling event
                // `tip` is the template (will be null if not open)
                var tip = this.getTemplateElement(); // `eventTarget` is the element which is losing focus/hover and

                var eventTarget = event.target; // `relatedTarget` is the element gaining focus/hover

                var relatedTarget = event.relatedTarget;
                /* istanbul ignore next */

                if ( // From tip to target
                    tip && contains(tip, eventTarget) && contains(target, relatedTarget) || // From target to tip
                    tip && contains(target, eventTarget) && contains(tip, relatedTarget) || // Within tip
                    tip && contains(tip, eventTarget) && contains(tip, relatedTarget) || // Within target
                    contains(target, eventTarget) && contains(target, relatedTarget)) {
                    // If focus/hover moves within `tip` and `target`, don't trigger a leave
                    return;
                } // Otherwise trigger a leave


                this.leave(event);
            }
        },
        doHide: function doHide(id) {
            // Programmatically hide tooltip or popover
            if (!id || this.getTargetId() === id || this.computedId === id) {
                // Close all tooltips or popovers, or this specific tip (with ID)
                this.forceHide();
            }
        },
        doShow: function doShow(id) {
            // Programmatically show tooltip or popover
            if (!id || this.getTargetId() === id || this.computedId === id) {
                // Open all tooltips or popovers, or this specific tip (with ID)
                this.show();
            }
        },

        /*istanbul ignore next: ignore for now */
        doDisable: function doDisable(id)
            /*istanbul ignore next: ignore for now */
        {
            // Programmatically disable tooltip or popover
            if (!id || this.getTargetId() === id || this.computedId === id) {
                // Disable all tooltips or popovers (no ID), or this specific tip (with ID)
                this.disable();
            }
        },

        /*istanbul ignore next: ignore for now */
        doEnable: function doEnable(id)
            /*istanbul ignore next: ignore for now */
        {
            // Programmatically enable tooltip or popover
            if (!id || this.getTargetId() === id || this.computedId === id) {
                // Enable all tooltips or popovers (no ID), or this specific tip (with ID)
                this.enable();
            }
        },
        click: function click(event) {
            if (!this.$_enabled || this.dropdownOpen()) {
                /* istanbul ignore next */
                return;
            } // Get around a WebKit bug where `click` does not trigger focus events
            // On most browsers, `click` triggers a `focusin`/`focus` event first
            // Needed so that trigger 'click blur' works on iOS
            // https://github.com/bootstrap-vue/bootstrap-vue/issues/5099
            // We use `currentTarget` rather than `target` to trigger on the
            // element, not the inner content


            attemptFocus(event.currentTarget);
            this.activeTrigger.click = !this.activeTrigger.click;

            if (this.isWithActiveTrigger) {
                this.enter(null);
            } else {
                /* istanbul ignore next */
                this.leave(null);
            }
        },

        /* istanbul ignore next */
        toggle: function toggle() {
            // Manual toggle handler
            if (!this.$_enabled || this.dropdownOpen()) {
                /* istanbul ignore next */
                return;
            } // Should we register as an active trigger?
            // this.activeTrigger.manual = !this.activeTrigger.manual


            if (this.localShow) {
                this.leave(null);
            } else {
                this.enter(null);
            }
        },
        enter: function enter() {
            var _this10 = this;

            var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

            // Opening trigger handler
            // Note: Click events are sent with event === null
            if (event) {
                this.activeTrigger[event.type === 'focusin' ? 'focus' : 'hover'] = true;
            }
            /* istanbul ignore next */


            if (this.localShow || this.$_hoverState === 'in') {
                this.$_hoverState = 'in';
                return;
            }

            this.clearHoverTimeout();
            this.$_hoverState = 'in';

            if (!this.computedDelay.show) {
                this.show();
            } else {
                // Hide any title attribute while enter delay is active
                this.fixTitle();
                this.$_hoverTimeout = setTimeout(function () {
                    /* istanbul ignore else */
                    if (_this10.$_hoverState === 'in') {
                        _this10.show();
                    } else if (!_this10.localShow) {
                        _this10.restoreTitle();
                    }
                }, this.computedDelay.show);
            }
        },
        leave: function leave() {
            var _this11 = this;

            var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

            // Closing trigger handler
            // Note: Click events are sent with event === null
            if (event) {
                this.activeTrigger[event.type === 'focusout' ? 'focus' : 'hover'] = false;
                /* istanbul ignore next */

                if (event.type === 'focusout' && arrayIncludes(this.computedTriggers, 'blur')) {
                    // Special case for `blur`: we clear out the other triggers
                    this.activeTrigger.click = false;
                    this.activeTrigger.hover = false;
                }
            }
            /* istanbul ignore next: ignore for now */


            if (this.isWithActiveTrigger) {
                return;
            }

            this.clearHoverTimeout();
            this.$_hoverState = 'out';

            if (!this.computedDelay.hide) {
                this.hide();
            } else {
                this.$_hoverTimeout = setTimeout(function () {
                    if (_this11.$_hoverState === 'out') {
                        _this11.hide();
                    }
                }, this.computedDelay.hide);
            }
        }
    }
});

var _makePropsConfigurabl, _watch$2;

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty$3(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty$3(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var MODEL_PROP_NAME_ENABLED = 'disabled';
var MODEL_EVENT_NAME_ENABLED = MODEL_EVENT_NAME_PREFIX + MODEL_PROP_NAME_ENABLED;
var MODEL_PROP_NAME_SHOW = 'show';
var MODEL_EVENT_NAME_SHOW = MODEL_EVENT_NAME_PREFIX + MODEL_PROP_NAME_SHOW; // --- Props ---

var props$2 = makePropsConfigurable((_makePropsConfigurabl = {
    // String: scrollParent, window, or viewport
    // Element: element reference
    // Object: Vue component
    boundary: makeProp([HTMLElement, PROP_TYPE_OBJECT, PROP_TYPE_STRING], 'scrollParent'),
    boundaryPadding: makeProp(PROP_TYPE_NUMBER_STRING, 50),
    // String: HTML ID of container, if null body is used (default)
    // HTMLElement: element reference reference
    // Object: Vue Component
    container: makeProp([HTMLElement, PROP_TYPE_OBJECT, PROP_TYPE_STRING]),
    customClass: makeProp(PROP_TYPE_STRING),
    delay: makeProp(PROP_TYPE_NUMBER_OBJECT_STRING, 50)
}, _defineProperty$3(_makePropsConfigurabl, MODEL_PROP_NAME_ENABLED, makeProp(PROP_TYPE_BOOLEAN, false)), _defineProperty$3(_makePropsConfigurabl, "fallbackPlacement", makeProp(PROP_TYPE_ARRAY_STRING, 'flip')), _defineProperty$3(_makePropsConfigurabl, "id", makeProp(PROP_TYPE_STRING)), _defineProperty$3(_makePropsConfigurabl, "noFade", makeProp(PROP_TYPE_BOOLEAN, false)), _defineProperty$3(_makePropsConfigurabl, "noninteractive", makeProp(PROP_TYPE_BOOLEAN, false)), _defineProperty$3(_makePropsConfigurabl, "offset", makeProp(PROP_TYPE_NUMBER_STRING, 0)), _defineProperty$3(_makePropsConfigurabl, "placement", makeProp(PROP_TYPE_STRING, 'top')), _defineProperty$3(_makePropsConfigurabl, MODEL_PROP_NAME_SHOW, makeProp(PROP_TYPE_BOOLEAN, false)), _defineProperty$3(_makePropsConfigurabl, "target", makeProp([HTMLElement, SVGElement, PROP_TYPE_FUNCTION, PROP_TYPE_OBJECT, PROP_TYPE_STRING], undefined, true)), _defineProperty$3(_makePropsConfigurabl, "title", makeProp(PROP_TYPE_STRING)), _defineProperty$3(_makePropsConfigurabl, "triggers", makeProp(PROP_TYPE_ARRAY_STRING, 'hover focus')), _defineProperty$3(_makePropsConfigurabl, "variant", makeProp(PROP_TYPE_STRING)), _makePropsConfigurabl), NAME_TOOLTIP); // --- Main component ---
// @vue/component

var BTooltip = /*#__PURE__*/Vue$1.extend({
    name: NAME_TOOLTIP,
    mixins: [normalizeSlotMixin],
    inheritAttrs: false,
    props: props$2,
    data: function data() {
        return {
            localShow: this[MODEL_PROP_NAME_SHOW],
            localTitle: '',
            localContent: ''
        };
    },
    computed: {
        // Data that will be passed to the template and popper
        templateData: function templateData() {
            return _objectSpread$2({
                title: this.localTitle,
                content: this.localContent,
                interactive: !this.noninteractive
            }, pick(this.$props, ['boundary', 'boundaryPadding', 'container', 'customClass', 'delay', 'fallbackPlacement', 'id', 'noFade', 'offset', 'placement', 'target', 'target', 'triggers', 'variant', MODEL_PROP_NAME_ENABLED]));
        },
        // Used to watch for changes to the title and content props
        templateTitleContent: function templateTitleContent() {
            var title = this.title,
                content = this.content;
            return {
                title: title,
                content: content
            };
        }
    },
    watch: (_watch$2 = {}, _defineProperty$3(_watch$2, MODEL_PROP_NAME_SHOW, function (newValue, oldValue) {
        if (newValue !== oldValue && newValue !== this.localShow && this.$_toolpop) {
            if (newValue) {
                this.$_toolpop.show();
            } else {
                // We use `forceHide()` to override any active triggers
                this.$_toolpop.forceHide();
            }
        }
    }), _defineProperty$3(_watch$2, MODEL_PROP_NAME_ENABLED, function (newValue) {
        if (newValue) {
            this.doDisable();
        } else {
            this.doEnable();
        }
    }), _defineProperty$3(_watch$2, "localShow", function localShow(newValue) {
        // TODO: May need to be done in a `$nextTick()`
        this.$emit(MODEL_EVENT_NAME_SHOW, newValue);
    }), _defineProperty$3(_watch$2, "templateData", function templateData() {
        var _this = this;

        this.$nextTick(function () {
            if (_this.$_toolpop) {
                _this.$_toolpop.updateData(_this.templateData);
            }
        });
    }), _defineProperty$3(_watch$2, "templateTitleContent", function templateTitleContent() {
        this.$nextTick(this.updateContent);
    }), _watch$2),
    created: function created() {
        // Create private non-reactive props
        this.$_toolpop = null;
    },
    updated: function updated() {
        // Update the `propData` object
        // Done in a `$nextTick()` to ensure slot(s) have updated
        this.$nextTick(this.updateContent);
    },
    beforeDestroy: function beforeDestroy() {
        // Shutdown our local event listeners
        this.$off(EVENT_NAME_OPEN, this.doOpen);
        this.$off(EVENT_NAME_CLOSE, this.doClose);
        this.$off(EVENT_NAME_DISABLE, this.doDisable);
        this.$off(EVENT_NAME_ENABLE, this.doEnable); // Destroy the tip instance

        if (this.$_toolpop) {
            this.$_toolpop.$destroy();
            this.$_toolpop = null;
        }
    },
    mounted: function mounted() {
        var _this2 = this;

        // Instantiate a new BVTooltip instance
        // Done in a `$nextTick()` to ensure DOM has completed rendering
        // so that target can be found
        this.$nextTick(function () {
            // Load the on demand child instance
            var Component = _this2.getComponent(); // Ensure we have initial content


            _this2.updateContent(); // Pass down the scoped style attribute if available


            var scopeId = getScopeId(_this2) || getScopeId(_this2.$parent); // Create the instance

            var $toolpop = _this2.$_toolpop = new Component({
                parent: _this2,
                // Pass down the scoped style ID
                _scopeId: scopeId || undefined
            }); // Set the initial data

            $toolpop.updateData(_this2.templateData); // Set listeners

            $toolpop.$on(EVENT_NAME_SHOW, _this2.onShow);
            $toolpop.$on(EVENT_NAME_SHOWN, _this2.onShown);
            $toolpop.$on(EVENT_NAME_HIDE, _this2.onHide);
            $toolpop.$on(EVENT_NAME_HIDDEN, _this2.onHidden);
            $toolpop.$on(EVENT_NAME_DISABLED, _this2.onDisabled);
            $toolpop.$on(EVENT_NAME_ENABLED, _this2.onEnabled); // Initially disabled?

            if (_this2[MODEL_PROP_NAME_ENABLED]) {
                // Initially disabled
                _this2.doDisable();
            } // Listen to open signals from others


            _this2.$on(EVENT_NAME_OPEN, _this2.doOpen); // Listen to close signals from others


            _this2.$on(EVENT_NAME_CLOSE, _this2.doClose); // Listen to disable signals from others


            _this2.$on(EVENT_NAME_DISABLE, _this2.doDisable); // Listen to enable signals from others


            _this2.$on(EVENT_NAME_ENABLE, _this2.doEnable); // Initially show tooltip?


            if (_this2.localShow) {
                $toolpop.show();
            }
        });
    },
    methods: {
        getComponent: function getComponent() {
            // Overridden by BPopover
            return BVTooltip;
        },
        updateContent: function updateContent() {
            // Overridden by BPopover
            // Tooltip: Default slot is `title`
            // Popover: Default slot is `content`, `title` slot is title
            // We pass a scoped slot function reference by default (Vue v2.6x)
            // And pass the title prop as a fallback
            this.setTitle(this.normalizeSlot() || this.title);
        },
        // Helper methods for `updateContent()`
        setTitle: function setTitle(value) {
            value = isUndefinedOrNull(value) ? '' : value; // We only update the value if it has changed

            if (this.localTitle !== value) {
                this.localTitle = value;
            }
        },
        setContent: function setContent(value) {
            value = isUndefinedOrNull(value) ? '' : value; // We only update the value if it has changed

            if (this.localContent !== value) {
                this.localContent = value;
            }
        },
        // --- Template event handlers ---
        onShow: function onShow(bvEvent) {
            // Placeholder
            this.$emit(EVENT_NAME_SHOW, bvEvent);

            if (bvEvent) {
                this.localShow = !bvEvent.defaultPrevented;
            }
        },
        onShown: function onShown(bvEvent) {
            // Tip is now showing
            this.localShow = true;
            this.$emit(EVENT_NAME_SHOWN, bvEvent);
        },
        onHide: function onHide(bvEvent) {
            this.$emit(EVENT_NAME_HIDE, bvEvent);
        },
        onHidden: function onHidden(bvEvent) {
            // Tip is no longer showing
            this.$emit(EVENT_NAME_HIDDEN, bvEvent);
            this.localShow = false;
        },
        onDisabled: function onDisabled(bvEvent) {
            // Prevent possible endless loop if user mistakenly
            // fires `disabled` instead of `disable`
            if (bvEvent && bvEvent.type === EVENT_NAME_DISABLED) {
                this.$emit(MODEL_EVENT_NAME_ENABLED, true);
                this.$emit(EVENT_NAME_DISABLED, bvEvent);
            }
        },
        onEnabled: function onEnabled(bvEvent) {
            // Prevent possible endless loop if user mistakenly
            // fires `enabled` instead of `enable`
            if (bvEvent && bvEvent.type === EVENT_NAME_ENABLED) {
                this.$emit(MODEL_EVENT_NAME_ENABLED, false);
                this.$emit(EVENT_NAME_ENABLED, bvEvent);
            }
        },
        // --- Local event listeners ---
        doOpen: function doOpen() {
            !this.localShow && this.$_toolpop && this.$_toolpop.show();
        },
        doClose: function doClose() {
            this.localShow && this.$_toolpop && this.$_toolpop.hide();
        },
        doDisable: function doDisable() {
            this.$_toolpop && this.$_toolpop.disable();
        },
        doEnable: function doEnable() {
            this.$_toolpop && this.$_toolpop.enable();
        }
    },
    render: function render(h) {
        // Always renders a comment node
        // TODO:
        //   Future: Possibly render a target slot (single root element)
        //   which we can apply the listeners to (pass `this.$el` to BVTooltip)
        return h();
    }
});

/*
 * Consistent and stable sort function across JavaScript platforms
 *
 * Inconsistent sorts can cause SSR problems between client and server
 * such as in <b-table> if sortBy is applied to the data on server side render.
 * Chrome and V8 native sorts are inconsistent/unstable
 *
 * This function uses native sort with fallback to index compare when the a and b
 * compare returns 0
 *
 * Algorithm based on:
 * https://stackoverflow.com/questions/1427608/fast-stable-sorting-algorithm-implementation-in-javascript/45422645#45422645
 *
 * @param {array} array to sort
 * @param {function} sort compare function
 * @return {array}
 */
var stableSort = function stableSort(array, compareFn) {
    // Using `.bind(compareFn)` on the wrapped anonymous function improves
    // performance by avoiding the function call setup. We don't use an arrow
    // function here as it binds `this` to the `stableSort` context rather than
    // the `compareFn` context, which wouldn't give us the performance increase.
    return array.map(function (a, index) {
        return [index, a];
    }).sort(function (a, b) {
        return this(a[1], b[1]) || a[0] - b[0];
    }.bind(compareFn)).map(function (e) {
        return e[1];
    });
};

var _watch$1;

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty$2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _makeModelMixin = makeModelMixin('value', {
        type: PROP_TYPE_NUMBER
    }),
    modelMixin = _makeModelMixin.mixin,
    modelProps = _makeModelMixin.props,
    MODEL_PROP_NAME = _makeModelMixin.prop,
    MODEL_EVENT_NAME = _makeModelMixin.event; // --- Helper methods ---
// Filter function to filter out disabled tabs


var notDisabled = function notDisabled(tab) {
    return !tab.disabled;
}; // --- Helper components ---
// @vue/component


var BVTabButton = /*#__PURE__*/Vue$1.extend({
    name: NAME_TAB_BUTTON_HELPER,
    inject: {
        bvTabs: {
            default:
            /* istanbul ignore next */
                function _default() {
                    return {};
                }
        }
    },
    props: {
        controls: makeProp(PROP_TYPE_STRING),
        id: makeProp(PROP_TYPE_STRING),
        noKeyNav: makeProp(PROP_TYPE_BOOLEAN, false),
        posInSet: makeProp(PROP_TYPE_NUMBER),
        setSize: makeProp(PROP_TYPE_NUMBER),
        // Reference to the child <b-tab> instance
        tab: makeProp(),
        tabIndex: makeProp(PROP_TYPE_NUMBER)
    },
    methods: {
        focus: function focus() {
            attemptFocus(this.$refs.link);
        },
        handleEvt: function handleEvt(event) {
            /* istanbul ignore next */
            if (this.tab.disabled) {
                return;
            }

            var type = event.type,
                keyCode = event.keyCode,
                shiftKey = event.shiftKey;

            if (type === 'click') {
                stopEvent(event);
                this.$emit(EVENT_NAME_CLICK, event);
            } else if (type === 'keydown' && keyCode === CODE_SPACE) {
                // For ARIA tabs the SPACE key will also trigger a click/select
                // Even with keyboard navigation disabled, SPACE should "click" the button
                // See: https://github.com/bootstrap-vue/bootstrap-vue/issues/4323
                stopEvent(event);
                this.$emit(EVENT_NAME_CLICK, event);
            } else if (type === 'keydown' && !this.noKeyNav) {
                // For keyboard navigation
                if ([CODE_UP, CODE_LEFT, CODE_HOME].indexOf(keyCode) !== -1) {
                    stopEvent(event);

                    if (shiftKey || keyCode === CODE_HOME) {
                        this.$emit(EVENT_NAME_FIRST, event);
                    } else {
                        this.$emit(EVENT_NAME_PREV, event);
                    }
                } else if ([CODE_DOWN, CODE_RIGHT, CODE_END].indexOf(keyCode) !== -1) {
                    stopEvent(event);

                    if (shiftKey || keyCode === CODE_END) {
                        this.$emit(EVENT_NAME_LAST, event);
                    } else {
                        this.$emit(EVENT_NAME_NEXT, event);
                    }
                }
            }
        }
    },
    render: function render(h) {
        var id = this.id,
            tabIndex = this.tabIndex,
            setSize = this.setSize,
            posInSet = this.posInSet,
            controls = this.controls,
            handleEvt = this.handleEvt;
        var _this$tab = this.tab,
            title = _this$tab.title,
            localActive = _this$tab.localActive,
            disabled = _this$tab.disabled,
            titleItemClass = _this$tab.titleItemClass,
            titleLinkClass = _this$tab.titleLinkClass,
            titleLinkAttributes = _this$tab.titleLinkAttributes;
        var $link = h(BLink, {
            staticClass: 'nav-link',
            class: [{
                active: localActive && !disabled,
                disabled: disabled
            }, titleLinkClass, // Apply <b-tabs> `activeNavItemClass` styles when the tab is active
                localActive ? this.bvTabs.activeNavItemClass : null],
            props: {
                disabled: disabled
            },
            attrs: _objectSpread$1(_objectSpread$1({}, titleLinkAttributes), {}, {
                id: id,
                role: 'tab',
                // Roving tab index when keynav enabled
                tabindex: tabIndex,
                'aria-selected': localActive && !disabled ? 'true' : 'false',
                'aria-setsize': setSize,
                'aria-posinset': posInSet,
                'aria-controls': controls
            }),
            on: {
                click: handleEvt,
                keydown: handleEvt
            },
            ref: 'link'
        }, [this.tab.normalizeSlot(SLOT_NAME_TITLE) || title]);
        return h('li', {
            staticClass: 'nav-item',
            class: [titleItemClass],
            attrs: {
                role: 'presentation'
            }
        }, [$link]);
    }
}); // --- Props ---

var navProps = omit(props$7, ['tabs', 'isNavBar', 'cardHeader']);
var props$1 = makePropsConfigurable(sortKeys(_objectSpread$1(_objectSpread$1(_objectSpread$1(_objectSpread$1({}, props$b), modelProps), navProps), {}, {
    // Only applied to the currently active `<b-nav-item>`
    activeNavItemClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    // Only applied to the currently active `<b-tab>`
    // This prop is sniffed by the `<b-tab>` child
    activeTabClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    card: makeProp(PROP_TYPE_BOOLEAN, false),
    contentClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    // Synonym for 'bottom'
    end: makeProp(PROP_TYPE_BOOLEAN, false),
    // This prop is sniffed by the `<b-tab>` child
    lazy: makeProp(PROP_TYPE_BOOLEAN, false),
    navClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    navWrapperClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    noFade: makeProp(PROP_TYPE_BOOLEAN, false),
    noKeyNav: makeProp(PROP_TYPE_BOOLEAN, false),
    noNavStyle: makeProp(PROP_TYPE_BOOLEAN, false),
    tag: makeProp(PROP_TYPE_STRING, 'div')
})), NAME_TABS); // --- Main component ---
// @vue/component

var BTabs = /*#__PURE__*/Vue$1.extend({
    name: NAME_TABS,
    mixins: [idMixin, modelMixin, normalizeSlotMixin],
    provide: function provide() {
        return {
            bvTabs: this
        };
    },
    props: props$1,
    data: function data() {
        return {
            // Index of current tab
            currentTab: toInteger(this[MODEL_PROP_NAME], -1),
            // Array of direct child `<b-tab>` instances, in DOM order
            tabs: [],
            // Array of child instances registered (for triggering reactive updates)
            registeredTabs: []
        };
    },
    computed: {
        fade: function fade() {
            // This computed prop is sniffed by the tab child
            return !this.noFade;
        },
        localNavClass: function localNavClass() {
            var classes = [];

            if (this.card && this.vertical) {
                classes.push('card-header', 'h-100', 'border-bottom-0', 'rounded-0');
            }

            return [].concat(classes, [this.navClass]);
        }
    },
    watch: (_watch$1 = {}, _defineProperty$2(_watch$1, MODEL_PROP_NAME, function (newValue, oldValue) {
        if (newValue !== oldValue) {
            newValue = toInteger(newValue, -1);
            oldValue = toInteger(oldValue, 0);
            var $tab = this.tabs[newValue];

            if ($tab && !$tab.disabled) {
                this.activateTab($tab);
            } else {
                // Try next or prev tabs
                if (newValue < oldValue) {
                    this.previousTab();
                } else {
                    this.nextTab();
                }
            }
        }
    }), _defineProperty$2(_watch$1, "currentTab", function currentTab(newValue) {
        var index = -1; // Ensure only one tab is active at most

        this.tabs.forEach(function ($tab, i) {
            if (i === newValue && !$tab.disabled) {
                $tab.localActive = true;
                index = i;
            } else {
                $tab.localActive = false;
            }
        }); // Update the v-model

        this.$emit(MODEL_EVENT_NAME, index);
    }), _defineProperty$2(_watch$1, "tabs", function tabs(newValue, oldValue) {
        var _this = this;

        // We use `_uid` instead of `safeId()`, as the later is changed in a `$nextTick()`
        // if no explicit ID is provided, causing duplicate emits
        if (!looseEqual(newValue.map(function ($tab) {
            return $tab[COMPONENT_UID_KEY];
        }), oldValue.map(function ($tab) {
            return $tab[COMPONENT_UID_KEY];
        }))) {
            // In a `$nextTick()` to ensure `currentTab` has been set first
            this.$nextTick(function () {
                // We emit shallow copies of the new and old arrays of tabs,
                // to prevent users from potentially mutating the internal arrays
                _this.$emit(EVENT_NAME_CHANGED, newValue.slice(), oldValue.slice());
            });
        }
    }), _defineProperty$2(_watch$1, "registeredTabs", function registeredTabs() {
        this.updateTabs();
    }), _watch$1),
    created: function created() {
        // Create private non-reactive props
        this.$_observer = null;
    },
    mounted: function mounted() {
        this.setObserver(true);
    },
    beforeDestroy: function beforeDestroy() {
        this.setObserver(false); // Ensure no references to child instances exist

        this.tabs = [];
    },
    methods: {
        registerTab: function registerTab($tab) {
            if (!arrayIncludes(this.registeredTabs, $tab)) {
                this.registeredTabs.push($tab);
            }
        },
        unregisterTab: function unregisterTab($tab) {
            this.registeredTabs = this.registeredTabs.slice().filter(function ($t) {
                return $t !== $tab;
            });
        },
        // DOM observer is needed to detect changes in order of tabs
        setObserver: function setObserver() {
            var _this2 = this;

            var on = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            this.$_observer && this.$_observer.disconnect();
            this.$_observer = null;

            if (on) {
                /* istanbul ignore next: difficult to test mutation observer in JSDOM */
                var handler = function handler() {
                    _this2.$nextTick(function () {
                        requestAF(function () {
                            _this2.updateTabs();
                        });
                    });
                }; // Watch for changes to `<b-tab>` sub components


                this.$_observer = observeDom(this.$refs.content, handler, {
                    childList: true,
                    subtree: false,
                    attributes: true,
                    attributeFilter: ['id']
                });
            }
        },
        getTabs: function getTabs() {
            var $tabs = this.registeredTabs.filter(function ($tab) {
                return $tab.$children.filter(function ($t) {
                    return $t._isTab;
                }).length === 0;
            }); // DOM Order of Tabs

            var order = [];
            /* istanbul ignore next: too difficult to test */

            if (IS_BROWSER && $tabs.length > 0) {
                // We rely on the DOM when mounted to get the "true" order of the `<b-tab>` children
                // `querySelectorAll()` always returns elements in document order, regardless of
                // order specified in the selector
                var selector = $tabs.map(function ($tab) {
                    return "#".concat($tab.safeId());
                }).join(', ');
                order = selectAll(selector, this.$el).map(function ($el) {
                    return $el.id;
                }).filter(identity);
            } // Stable sort keeps the original order if not found in the `order` array,
            // which will be an empty array before mount


            return stableSort($tabs, function (a, b) {
                return order.indexOf(a.safeId()) - order.indexOf(b.safeId());
            });
        },
        updateTabs: function updateTabs() {
            var $tabs = this.getTabs(); // Find last active non-disabled tab in current tabs
            // We trust tab state over `currentTab`, in case tabs were added/removed/re-ordered

            var tabIndex = $tabs.indexOf($tabs.slice().reverse().find(function ($tab) {
                return $tab.localActive && !$tab.disabled;
            })); // Else try setting to `currentTab`

            if (tabIndex < 0) {
                var currentTab = this.currentTab;

                if (currentTab >= $tabs.length) {
                    // Handle last tab being removed, so find the last non-disabled tab
                    tabIndex = $tabs.indexOf($tabs.slice().reverse().find(notDisabled));
                } else if ($tabs[currentTab] && !$tabs[currentTab].disabled) {
                    // Current tab is not disabled
                    tabIndex = currentTab;
                }
            } // Else find first non-disabled tab in current tabs


            if (tabIndex < 0) {
                tabIndex = $tabs.indexOf($tabs.find(notDisabled));
            } // Ensure only one tab is active at a time


            $tabs.forEach(function ($tab, index) {
                $tab.localActive = index === tabIndex;
            });
            this.tabs = $tabs;
            this.currentTab = tabIndex;
        },
        // Find a button that controls a tab, given the tab reference
        // Returns the button vm instance
        getButtonForTab: function getButtonForTab($tab) {
            return (this.$refs.buttons || []).find(function ($btn) {
                return $btn.tab === $tab;
            });
        },
        // Force a button to re-render its content, given a `<b-tab>` instance
        // Called by `<b-tab>` on `update()`
        updateButton: function updateButton($tab) {
            var $button = this.getButtonForTab($tab);

            if ($button && $button.$forceUpdate) {
                $button.$forceUpdate();
            }
        },
        // Activate a tab given a `<b-tab>` instance
        // Also accessed by `<b-tab>`
        activateTab: function activateTab($tab) {
            var currentTab = this.currentTab,
                $tabs = this.tabs;
            var result = false;

            if ($tab) {
                var index = $tabs.indexOf($tab);

                if (index !== currentTab && index > -1 && !$tab.disabled) {
                    var tabEvent = new BvEvent(EVENT_NAME_ACTIVATE_TAB, {
                        cancelable: true,
                        vueTarget: this,
                        componentId: this.safeId()
                    });
                    this.$emit(tabEvent.type, index, currentTab, tabEvent);

                    if (!tabEvent.defaultPrevented) {
                        this.currentTab = index;
                        result = true;
                    }
                }
            } // Couldn't set tab, so ensure v-model is up to date

            /* istanbul ignore next: should rarely happen */


            if (!result && this[MODEL_PROP_NAME] !== currentTab) {
                this.$emit(MODEL_EVENT_NAME, currentTab);
            }

            return result;
        },
        // Deactivate a tab given a `<b-tab>` instance
        // Accessed by `<b-tab>`
        deactivateTab: function deactivateTab($tab) {
            if ($tab) {
                // Find first non-disabled tab that isn't the one being deactivated
                // If no tabs are available, then don't deactivate current tab
                return this.activateTab(this.tabs.filter(function ($t) {
                    return $t !== $tab;
                }).find(notDisabled));
            }
            /* istanbul ignore next: should never/rarely happen */


            return false;
        },
        // Focus a tab button given its `<b-tab>` instance
        focusButton: function focusButton($tab) {
            var _this3 = this;

            // Wrap in `$nextTick()` to ensure DOM has completed rendering
            this.$nextTick(function () {
                attemptFocus(_this3.getButtonForTab($tab));
            });
        },
        // Emit a click event on a specified `<b-tab>` component instance
        emitTabClick: function emitTabClick(tab, event) {
            if (isEvent(event) && tab && tab.$emit && !tab.disabled) {
                tab.$emit(EVENT_NAME_CLICK, event);
            }
        },
        // Click handler
        clickTab: function clickTab($tab, event) {
            this.activateTab($tab);
            this.emitTabClick($tab, event);
        },
        // Move to first non-disabled tab
        firstTab: function firstTab(focus) {
            var $tab = this.tabs.find(notDisabled);

            if (this.activateTab($tab) && focus) {
                this.focusButton($tab);
                this.emitTabClick($tab, focus);
            }
        },
        // Move to previous non-disabled tab
        previousTab: function previousTab(focus) {
            var currentIndex = mathMax(this.currentTab, 0);
            var $tab = this.tabs.slice(0, currentIndex).reverse().find(notDisabled);

            if (this.activateTab($tab) && focus) {
                this.focusButton($tab);
                this.emitTabClick($tab, focus);
            }
        },
        // Move to next non-disabled tab
        nextTab: function nextTab(focus) {
            var currentIndex = mathMax(this.currentTab, -1);
            var $tab = this.tabs.slice(currentIndex + 1).find(notDisabled);

            if (this.activateTab($tab) && focus) {
                this.focusButton($tab);
                this.emitTabClick($tab, focus);
            }
        },
        // Move to last non-disabled tab
        lastTab: function lastTab(focus) {
            var $tab = this.tabs.slice().reverse().find(notDisabled);

            if (this.activateTab($tab) && focus) {
                this.focusButton($tab);
                this.emitTabClick($tab, focus);
            }
        }
    },
    render: function render(h) {
        var _this4 = this;

        var align = this.align,
            card = this.card,
            end = this.end,
            fill = this.fill,
            firstTab = this.firstTab,
            justified = this.justified,
            lastTab = this.lastTab,
            nextTab = this.nextTab,
            noKeyNav = this.noKeyNav,
            noNavStyle = this.noNavStyle,
            pills = this.pills,
            previousTab = this.previousTab,
            small = this.small,
            $tabs = this.tabs,
            vertical = this.vertical; // Currently active tab

        var $activeTab = $tabs.find(function ($tab) {
            return $tab.localActive && !$tab.disabled;
        }); // Tab button to allow focusing when no active tab found (keynav only)

        var $fallbackTab = $tabs.find(function ($tab) {
            return !$tab.disabled;
        }); // For each `<b-tab>` found create the tab buttons

        var $buttons = $tabs.map(function ($tab, index) {
            var _on;

            var safeId = $tab.safeId; // Ensure at least one tab button is focusable when keynav enabled (if possible)

            var tabIndex = null;

            if (!noKeyNav) {
                // Buttons are not in tab index unless active, or a fallback tab
                tabIndex = -1;

                if ($tab === $activeTab || !$activeTab && $tab === $fallbackTab) {
                    // Place tab button in tab sequence
                    tabIndex = null;
                }
            }

            return h(BVTabButton, {
                props: {
                    controls: safeId ? safeId() : null,
                    id: $tab.controlledBy || (safeId ? safeId("_BV_tab_button_") : null),
                    noKeyNav: noKeyNav,
                    posInSet: index + 1,
                    setSize: $tabs.length,
                    tab: $tab,
                    tabIndex: tabIndex
                },
                on: (_on = {}, _defineProperty$2(_on, EVENT_NAME_CLICK, function (event) {
                    _this4.clickTab($tab, event);
                }), _defineProperty$2(_on, EVENT_NAME_FIRST, firstTab), _defineProperty$2(_on, EVENT_NAME_PREV, previousTab), _defineProperty$2(_on, EVENT_NAME_NEXT, nextTab), _defineProperty$2(_on, EVENT_NAME_LAST, lastTab), _on),
                key: $tab[COMPONENT_UID_KEY] || index,
                ref: 'buttons',
                // Needed to make `this.$refs.buttons` an array
                refInFor: true
            });
        });
        var $nav = h(BNav, {
            class: this.localNavClass,
            attrs: {
                role: 'tablist',
                id: this.safeId('_BV_tab_controls_')
            },
            props: {
                fill: fill,
                justified: justified,
                align: align,
                tabs: !noNavStyle && !pills,
                pills: !noNavStyle && pills,
                vertical: vertical,
                small: small,
                cardHeader: card && !vertical
            },
            ref: 'nav'
        }, [this.normalizeSlot(SLOT_NAME_TABS_START) || h(), $buttons, this.normalizeSlot(SLOT_NAME_TABS_END) || h()]);
        $nav = h('div', {
            class: [{
                'card-header': card && !vertical && !end,
                'card-footer': card && !vertical && end,
                'col-auto': vertical
            }, this.navWrapperClass],
            key: 'bv-tabs-nav'
        }, [$nav]);
        var $children = this.normalizeSlot() || [];
        var $empty = h();

        if ($children.length === 0) {
            $empty = h('div', {
                class: ['tab-pane', 'active', {
                    'card-body': card
                }],
                key: 'bv-empty-tab'
            }, this.normalizeSlot(SLOT_NAME_EMPTY));
        }

        var $content = h('div', {
            staticClass: 'tab-content',
            class: [{
                col: vertical
            }, this.contentClass],
            attrs: {
                id: this.safeId('_BV_tab_container_')
            },
            key: 'bv-content',
            ref: 'content'
        }, [$children, $empty]); // Render final output

        return h(this.tag, {
            staticClass: 'tabs',
            class: {
                row: vertical,
                'no-gutters': vertical && card
            },
            attrs: {
                id: this.safeId()
            }
        }, [end ? $content : h(), $nav, end ? h() : $content]);
    }
});

var _objectSpread2, _watch;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var MODEL_PROP_NAME_ACTIVE = 'active';
var MODEL_EVENT_NAME_ACTIVE = MODEL_EVENT_NAME_PREFIX + MODEL_PROP_NAME_ACTIVE; // --- Props ---

var props = makePropsConfigurable(sortKeys(_objectSpread(_objectSpread({}, props$b), {}, (_objectSpread2 = {}, _defineProperty$1(_objectSpread2, MODEL_PROP_NAME_ACTIVE, makeProp(PROP_TYPE_BOOLEAN, false)), _defineProperty$1(_objectSpread2, "buttonId", makeProp(PROP_TYPE_STRING)), _defineProperty$1(_objectSpread2, "disabled", makeProp(PROP_TYPE_BOOLEAN, false)), _defineProperty$1(_objectSpread2, "lazy", makeProp(PROP_TYPE_BOOLEAN, false)), _defineProperty$1(_objectSpread2, "noBody", makeProp(PROP_TYPE_BOOLEAN, false)), _defineProperty$1(_objectSpread2, "tag", makeProp(PROP_TYPE_STRING, 'div')), _defineProperty$1(_objectSpread2, "title", makeProp(PROP_TYPE_STRING)), _defineProperty$1(_objectSpread2, "titleItemClass", makeProp(PROP_TYPE_ARRAY_OBJECT_STRING)), _defineProperty$1(_objectSpread2, "titleLinkAttributes", makeProp(PROP_TYPE_OBJECT)), _defineProperty$1(_objectSpread2, "titleLinkClass", makeProp(PROP_TYPE_ARRAY_OBJECT_STRING)), _objectSpread2))), NAME_TAB); // --- Main component ---
// @vue/component

var BTab = /*#__PURE__*/Vue$1.extend({
    name: NAME_TAB,
    mixins: [idMixin, normalizeSlotMixin],
    inject: {
        bvTabs: {
            default: function _default() {
                return {};
            }
        }
    },
    props: props,
    data: function data() {
        return {
            localActive: this[MODEL_PROP_NAME_ACTIVE] && !this.disabled
        };
    },
    computed: {
        // For parent sniffing of child
        _isTab: function _isTab() {
            return true;
        },
        tabClasses: function tabClasses() {
            var active = this.localActive,
                disabled = this.disabled;
            return [{
                active: active,
                disabled: disabled,
                'card-body': this.bvTabs.card && !this.noBody
            }, // Apply <b-tabs> `activeTabClass` styles when this tab is active
                active ? this.bvTabs.activeTabClass : null];
        },
        controlledBy: function controlledBy() {
            return this.buttonId || this.safeId('__BV_tab_button__');
        },
        computedNoFade: function computedNoFade() {
            return !(this.bvTabs.fade || false);
        },
        computedLazy: function computedLazy() {
            return this.bvTabs.lazy || this.lazy;
        }
    },
    watch: (_watch = {}, _defineProperty$1(_watch, MODEL_PROP_NAME_ACTIVE, function (newValue, oldValue) {
        if (newValue !== oldValue) {
            if (newValue) {
                // If activated post mount
                this.activate();
            } else {
                /* istanbul ignore next */
                if (!this.deactivate()) {
                    // Tab couldn't be deactivated, so we reset the synced active prop
                    // Deactivation will fail if no other tabs to activate
                    this.$emit(MODEL_EVENT_NAME_ACTIVE, this.localActive);
                }
            }
        }
    }), _defineProperty$1(_watch, "disabled", function disabled(newValue, oldValue) {
        if (newValue !== oldValue) {
            var firstTab = this.bvTabs.firstTab;

            if (newValue && this.localActive && firstTab) {
                this.localActive = false;
                firstTab();
            }
        }
    }), _defineProperty$1(_watch, "localActive", function localActive(newValue) {
        // Make `active` prop work with `.sync` modifier
        this.$emit(MODEL_EVENT_NAME_ACTIVE, newValue);
    }), _watch),
    mounted: function mounted() {
        // Inform `<b-tabs>` of our presence
        this.registerTab();
    },
    updated: function updated() {
        // Force the tab button content to update (since slots are not reactive)
        // Only done if we have a title slot, as the title prop is reactive
        var updateButton = this.bvTabs.updateButton;

        if (updateButton && this.hasNormalizedSlot(SLOT_NAME_TITLE)) {
            updateButton(this);
        }
    },
    beforeDestroy: function beforeDestroy() {
        // Inform `<b-tabs>` of our departure
        this.unregisterTab();
    },
    methods: {
        // Private methods
        registerTab: function registerTab() {
            // Inform `<b-tabs>` of our presence
            var registerTab = this.bvTabs.registerTab;

            if (registerTab) {
                registerTab(this);
            }
        },
        unregisterTab: function unregisterTab() {
            // Inform `<b-tabs>` of our departure
            var unregisterTab = this.bvTabs.unregisterTab;

            if (unregisterTab) {
                unregisterTab(this);
            }
        },
        // Public methods
        activate: function activate() {
            // Not inside a `<b-tabs>` component or tab is disabled
            var activateTab = this.bvTabs.activateTab;
            return activateTab && !this.disabled ? activateTab(this) : false;
        },
        deactivate: function deactivate() {
            // Not inside a `<b-tabs>` component or not active to begin with
            var deactivateTab = this.bvTabs.deactivateTab;
            return deactivateTab && this.localActive ? deactivateTab(this) : false;
        }
    },
    render: function render(h) {
        var localActive = this.localActive;
        var $content = h(this.tag, {
                staticClass: 'tab-pane',
                class: this.tabClasses,
                directives: [{
                    name: 'show',
                    value: localActive
                }],
                attrs: {
                    role: 'tabpanel',
                    id: this.safeId(),
                    'aria-hidden': localActive ? 'false' : 'true',
                    'aria-labelledby': this.controlledBy || null
                },
                ref: 'panel'
            }, // Render content lazily if requested
            [localActive || !this.computedLazy ? this.normalizeSlot() : h()]);
        return h(BVTransition, {
            props: {
                mode: 'out-in',
                noFade: this.computedNoFade
            }
        }, [$content]);
    }
});

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function commonjsRequire () {
    throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
}

function unwrapExports (x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
    return module = { exports: {} }, fn(module, module.exports), module.exports;
}

//

var script$7 = {
    components: {
        Dropzone, Player, UploadProgress,
        BTabs, BTab, BDropdown, BDropdownItem,
        BNav, BNavItem, BNavItemDropdown
    },
    mounted() {

    },
    data() {
        return {
            videoInterval: null,
            videoUploadSpeed: null,
            tabIndex: 0,
        }
    },

    computed: {
        extraTabHeader() {
            if (this.extraVideoType === 'sequel') {
                return t("")
            } else if (this.extraVideoType === 'rear') {
                return t(" ")
            } else if (this.extraVideoType === 'remake') {
                return t("    ")
            }
        },
        ...mapState({
            videoUrl: s => s.video.url,
            videoDownloadUrl: s => s.video.downloadUrl,
            videoType: s => s.video.type,
            videoError: s => s.video.error,
            videoStatus: s => s.video.status,
            videoFileType: s => s.video.filetype,
            videoFilesize: s => s.video.filesize,
            videoErrorCount: s => s.video.errorCount,
            videoUploadProgress: s => s.video.uploadProgress,
        }),

        ...mapGetters({
            videoErrorCount: 'video/errorCount',
            extraVideoErrorCount: 'extraVideo/errorCount'
        }),

        ...mapState({
            extraVideoUrl: s => s.extraVideo.url,
            extraVideoDownloadUrl: s => s.extraVideo.downloadUrl,
            withExtraVideo: s => s.withExtraVideo,
            extraVideoType: s => s.extraVideo.type,
            extraVideoError: s => s.extraVideo.error,
            extraVideoStatus: s => s.extraVideo.status,
            extraVideoFileType: s => s.extraVideo.filetype,
            extraVideoFilesize: s => s.extraVideo.filesize,
            extraVideoUploadProgress: s => s.extraVideo.uploadProgress,
        }),
    },

    watch: {
        extraVideoError(error) {
            if (!this.videoError && error && this.tabIndex !== 1) {
                this.tabIndex=1;
            }
        },

        videoError(error) {
            if (!this.extraVideoError && error &&  this.tabIndex !== 0) {
                this.tabIndex=0;
            }
        },

        tabIndex(index) {
            if (index === 1) {
                this.updateWithExtraVideo(true);
            }
        }
    },

    methods: {
        ...mapMutations({
            updateVideo: "video/updateVideo",
            resetVideo: "video/reset",

            updateExtraVideo: "extraVideo/updateVideo",
            resetExtraVideo: "extraVideo/reset",
            updateWithExtraVideo: 'updateWithExtraVideo',
            updateExtraVideoType: "extraVideo/updateType",
        }),

        ...mapActions({
            uploadVideo: "video/uploadVideo",
            uploadExtraVideo: "extraVideo/uploadVideo",
        }),

        handleCloseExtraTab() {
            this.tabIndex = 0;
            this.updateWithExtraVideo(false);
            this.resetExtraVideo();
        },
    }
};

/* script */
const __vue_script__$7 = script$7;

/* template */
var __vue_render__$7 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('BNav',{staticClass:"mb-0 border-bottom-0",attrs:{"tabs":""}},[_c('BNavItem',{attrs:{"active":_vm.tabIndex===0},on:{"click":function($event){_vm.tabIndex=0;}}},[(_vm.videoErrorCount!==0)?_c('i',{staticClass:"fa fa-exclamation-triangle mr-0 ml-0",staticStyle:{"color":"#fd397a"}}):_vm._e(),_vm._v(" "),(_vm.videoStatus==='uploading')?_c('i',{staticClass:"pr-2 kt-spinner kt-spinner--v2 kt-spinner--sm kt-spinner--brand"}):_vm._e(),_vm._v("\n      "+_vm._s(_vm._f("t")(""))+" 1\n      "),(_vm.videoStatus!=='initial')?_c('a',{attrs:{"href":"#"},on:{"click":function($event){$event.stopPropagation();return _vm.resetVideo($event)}}},[_c('i',{staticClass:"la la-close mx-0"})]):_vm._e()]),_vm._v(" "),(!_vm.withExtraVideo)?_c('BNavItemDropdown',[_c('template',{slot:"button-content"},[_c('span',{staticClass:"kt-label-font-color-2 mr-2"},[_vm._v(_vm._s(_vm._f("t")(""))+" 2")]),_vm._v(" "),_c('i',{staticClass:"flaticon2-plus mx-0 kt-label-font-color-2"})]),_vm._v(" "),_c('BDropdownItem',{on:{"click":function($event){_vm.updateExtraVideoType('sequel');_vm.tabIndex=1;}}},[_vm._v(_vm._s(_vm._f("t")("")))]),_vm._v(" "),_c('BDropdownItem',{on:{"click":function($event){_vm.updateExtraVideoType('rear');_vm.tabIndex=1;}}},[_vm._v(_vm._s(_vm._f("t")(" ")))]),_vm._v(" "),_c('BDropdownItem',{on:{"click":function($event){_vm.updateExtraVideoType('remake');_vm.tabIndex=1;}}},[_vm._v(_vm._s(_vm._f("t")("    ")))])],2):_c('BNavItem',{attrs:{"active":_vm.tabIndex===1},on:{"click":function($event){_vm.tabIndex=1;}}},[(_vm.extraVideoErrorCount!==0)?_c('i',{staticClass:"fa fa-exclamation-triangle mr-0 ml-0",staticStyle:{"color":"#fd397a"}}):_vm._e(),_vm._v(" "),(_vm.extraVideoStatus==='uploading')?_c('i',{staticClass:"px-1 kt-spinner kt-spinner--v2 kt-spinner--sm kt-spinner--brand"}):_vm._e(),_vm._v("\n      "+_vm._s(_vm.extraTabHeader)+"\n      "),_c('a',{attrs:{"href":"#"},on:{"click":function($event){$event.stopPropagation();return _vm.handleCloseExtraTab($event)}}},[_c('i',{staticClass:"la la-close mx-0"})])])],1),_vm._v(" "),_c('BTabs',{attrs:{"content-class":['p-3','bg-white', 'border', 'kt-portlet', {'lt-border-0':_vm.tabIndex===0}],"nav-class":"mb-0 border-bottom-0","nav-wrapper-class":"d-none"},model:{value:(_vm.tabIndex),callback:function ($$v) {_vm.tabIndex=$$v;},expression:"tabIndex"}},[_c('BTab',{attrs:{"active":""}},[(_vm.videoStatus==='initial')?_c('Dropzone',{attrs:{"error":_vm.videoError,"message":_vm.t('!       ')},on:{"change":_vm.uploadVideo}}):(_vm.videoStatus==='uploading')?_c('UploadProgress',{staticClass:"mx-auto my-auto w-50",attrs:{"filesize":_vm.videoFilesize,"uploaded":_vm.videoUploadProgress}}):(_vm.videoStatus==='uploaded')?_c('Player',{attrs:{"content-type":_vm.videoFileType,"url":_vm.videoUrl,"download-url":_vm.videoDownloadUrl},on:{"videoChange":_vm.updateVideo}}):_vm._e()],1),_vm._v(" "),_c('BTab',{attrs:{"title-link-class":"transition-none"}},[(_vm.extraVideoStatus==='initial')?_c('Dropzone',{attrs:{"error":_vm.extraVideoError,"message":_vm.t('!       ')},on:{"change":_vm.uploadExtraVideo}}):(_vm.extraVideoStatus==='uploading')?_c('UploadProgress',{staticClass:"mx-auto my-auto w-50",attrs:{"filesize":_vm.extraVideoFilesize,"uploaded":_vm.extraVideoUploadProgress}}):(_vm.extraVideoStatus==='uploaded')?_c('Player',{attrs:{"content-type":_vm.extraVideoFileType,"url":_vm.extraVideoUrl,"download-url":_vm.extraVideoDownloadUrl},on:{"videoChange":_vm.updateExtraVideo}}):_vm._e()],1)],1)],1)};
var __vue_staticRenderFns__$7 = [];

/* style */
const __vue_inject_styles__$7 = function (inject) {
    if (!inject) return
    inject("data-v-a628ea72_0", { source: ".flaticon2-plus{font-size:13px!important}.nav-link{padding-top:.5rem!important}.lt-border-0{border-top-left-radius:0}.tab-pane.active{display:flex!important;min-height:50vh}@media (max-width:768px){.tab-pane.active{display:flex!important;min-height:30vh}}.dropdown-tab{padding:0 0!important}.dropdown-tab .nav-link{padding:0 0!important}.nav-link .nav-link,.nav-link .nav-link:hover{border-color:transparent}.tab-pane>*{width:100%}.nav-link.dropdown-toggle:after{display:none!important}.la-close{font-size:11pt!important}.transition-none{transition:none!important}", map: undefined, media: undefined });

};
/* scoped */
const __vue_scope_id__$7 = undefined;
/* module identifier */
const __vue_module_identifier__$2 = undefined;
/* functional template */
const __vue_is_functional_template__$7 = false;
/* component normalizer */
function __vue_normalize__$7(
    template, style, script,
    scope, functional, moduleIdentifier,
    createInjector, createInjectorSSR
) {
    const component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "Index.vue";

    if (!component.render) {
        component.render = template.render;
        component.staticRenderFns = template.staticRenderFns;
        component._compiled = true;

        if (functional) component.functional = true;
    }

    component._scopeId = scope;

    {
        let hook;
        if (style) {
            hook = function(context) {
                style.call(this, createInjector(context));
            };
        }

        if (hook !== undefined) {
            if (component.functional) {
                // register for functional component in vue file
                const originalRender = component.render;
                component.render = function renderWithStyleInjection(h, context) {
                    hook.call(context);
                    return originalRender(h, context)
                };
            } else {
                // inject component registration as beforeCreate hook
                const existing = component.beforeCreate;
                component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
            }
        }
    }

    return component
}
/* style inject */
function __vue_create_injector__$2() {
    const head = document.head || document.getElementsByTagName('head')[0];
    const styles = __vue_create_injector__$2.styles || (__vue_create_injector__$2.styles = {});
    const isOldIE =
        typeof navigator !== 'undefined' &&
        /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
        if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return // SSR styles are present.

        const group = isOldIE ? css.media || 'default' : id;
        const style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

        if (!style.ids.includes(id)) {
            let code = css.source;
            let index = style.ids.length;

            style.ids.push(id);

            if (css.map) {
                // https://developer.chrome.com/devtools/docs/javascript-debugging
                // this makes source maps inside style tags work properly in Chrome
                code += '\n/*# sourceURL=' + css.map.sources[0] + ' */';
                // http://stackoverflow.com/a/26603875
                code +=
                    '\n/*# sourceMappingURL=data:application/json;base64,' +
                    btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) +
                    ' */';
            }

            if (isOldIE) {
                style.element = style.element || document.querySelector('style[data-group=' + group + ']');
            }

            if (!style.element) {
                const el = style.element = document.createElement('style');
                el.type = 'text/css';

                if (css.media) el.setAttribute('media', css.media);
                if (isOldIE) {
                    el.setAttribute('data-group', group);
                    el.setAttribute('data-next-index', '0');
                }

                head.appendChild(el);
            }

            if (isOldIE) {
                index = parseInt(style.element.getAttribute('data-next-index'));
                style.element.setAttribute('data-next-index', index + 1);
            }

            if (style.element.styleSheet) {
                style.parts.push(code);
                style.element.styleSheet.cssText = style.parts
                    .filter(Boolean)
                    .join('\n');
            } else {
                const textNode = document.createTextNode(code);
                const nodes = style.element.childNodes;
                if (nodes[index]) style.element.removeChild(nodes[index]);
                if (nodes.length) style.element.insertBefore(textNode, nodes[index]);
                else style.element.appendChild(textNode);
            }
        }
    }
}
/* style inject SSR */



var VideoUploadForm = __vue_normalize__$7(
    { render: __vue_render__$7, staticRenderFns: __vue_staticRenderFns__$7 },
    __vue_inject_styles__$7,
    __vue_script__$7,
    __vue_scope_id__$7,
    __vue_is_functional_template__$7,
    __vue_module_identifier__$2,
    __vue_create_injector__$2);

function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function (obj) {
            return typeof obj;
        };
    } else {
        _typeof = function (obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }

    return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}

function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}

function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }

    return obj;
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };

    return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
    } catch (e) {
        return false;
    }
}

function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }

    return target;
}

function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

        for (i = 0; i < sourceSymbolKeys.length; i++) {
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }

    return target;
}

function _assertThisInitialized(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
}

function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
    }

    return _assertThisInitialized(self);
}

function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived),
            result;

        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;

            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }

        return _possibleConstructorReturn(this, result);
    };
}

function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null) break;
    }

    return object;
}

function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
    } else {
        _get = function _get(target, property, receiver) {
            var base = _superPropBase(target, property);

            if (!base) return;
            var desc = Object.getOwnPropertyDescriptor(base, property);

            if (desc.get) {
                return desc.get.call(receiver);
            }

            return desc.value;
        };
    }

    return _get(target, property, receiver || target);
}

function set(target, property, value, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.set) {
        set = Reflect.set;
    } else {
        set = function set(target, property, value, receiver) {
            var base = _superPropBase(target, property);

            var desc;

            if (base) {
                desc = Object.getOwnPropertyDescriptor(base, property);

                if (desc.set) {
                    desc.set.call(receiver, value);
                    return true;
                } else if (!desc.writable) {
                    return false;
                }
            }

            desc = Object.getOwnPropertyDescriptor(receiver, property);

            if (desc) {
                if (!desc.writable) {
                    return false;
                }

                desc.value = value;
                Object.defineProperty(receiver, property, desc);
            } else {
                _defineProperty(receiver, property, value);
            }

            return true;
        };
    }

    return set(target, property, value, receiver);
}

function _set(target, property, value, receiver, isStrict) {
    var s = set(target, property, value, receiver || target);

    if (!s && isStrict) {
        throw new Error('failed to set property');
    }

    return value;
}

function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);

            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally {
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally {
            if (_d) throw _e;
        }
    }

    return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
}

function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/** Checks if value is string */
function isString(str) {
    return typeof str === 'string' || str instanceof String;
}
/**
 Direction
 @prop {string} NONE
 @prop {string} LEFT
 @prop {string} FORCE_LEFT
 @prop {string} RIGHT
 @prop {string} FORCE_RIGHT
 */

var DIRECTION = {
    NONE: 'NONE',
    LEFT: 'LEFT',
    FORCE_LEFT: 'FORCE_LEFT',
    RIGHT: 'RIGHT',
    FORCE_RIGHT: 'FORCE_RIGHT'
};
/** */

function forceDirection(direction) {
    switch (direction) {
        case DIRECTION.LEFT:
            return DIRECTION.FORCE_LEFT;

        case DIRECTION.RIGHT:
            return DIRECTION.FORCE_RIGHT;

        default:
            return direction;
    }
}
/** Escapes regular expression control chars */

function escapeRegExp(str) {
    return str.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
} // cloned from https://github.com/epoberezkin/fast-deep-equal with small changes

function objectIncludes(b, a) {
    if (a === b) return true;
    var arrA = Array.isArray(a),
        arrB = Array.isArray(b),
        i;

    if (arrA && arrB) {
        if (a.length != b.length) return false;

        for (i = 0; i < a.length; i++) {
            if (!objectIncludes(a[i], b[i])) return false;
        }

        return true;
    }

    if (arrA != arrB) return false;

    if (a && b && _typeof(a) === 'object' && _typeof(b) === 'object') {
        var dateA = a instanceof Date,
            dateB = b instanceof Date;
        if (dateA && dateB) return a.getTime() == b.getTime();
        if (dateA != dateB) return false;
        var regexpA = a instanceof RegExp,
            regexpB = b instanceof RegExp;
        if (regexpA && regexpB) return a.toString() == b.toString();
        if (regexpA != regexpB) return false;
        var keys = Object.keys(a); // if (keys.length !== Object.keys(b).length) return false;

        for (i = 0; i < keys.length; i++) {
            if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        }

        for (i = 0; i < keys.length; i++) {
            if (!objectIncludes(b[keys[i]], a[keys[i]])) return false;
        }

        return true;
    } else if (a && b && typeof a === 'function' && typeof b === 'function') {
        return a.toString() === b.toString();
    }

    return false;
}

/** Provides details of changing input */

var ActionDetails = /*#__PURE__*/function () {
    /** Current input value */

    /** Current cursor position */

    /** Old input value */

    /** Old selection */
    function ActionDetails(value, cursorPos, oldValue, oldSelection) {
        _classCallCheck(this, ActionDetails);

        this.value = value;
        this.cursorPos = cursorPos;
        this.oldValue = oldValue;
        this.oldSelection = oldSelection; // double check if left part was changed (autofilling, other non-standard input triggers)

        while (this.value.slice(0, this.startChangePos) !== this.oldValue.slice(0, this.startChangePos)) {
            --this.oldSelection.start;
        }
    }
    /**
     Start changing position
     @readonly
     */


    _createClass(ActionDetails, [{
        key: "startChangePos",
        get: function get() {
            return Math.min(this.cursorPos, this.oldSelection.start);
        }
        /**
         Inserted symbols count
         @readonly
         */

    }, {
        key: "insertedCount",
        get: function get() {
            return this.cursorPos - this.startChangePos;
        }
        /**
         Inserted symbols
         @readonly
         */

    }, {
        key: "inserted",
        get: function get() {
            return this.value.substr(this.startChangePos, this.insertedCount);
        }
        /**
         Removed symbols count
         @readonly
         */

    }, {
        key: "removedCount",
        get: function get() {
            // Math.max for opposite operation
            return Math.max(this.oldSelection.end - this.startChangePos || // for Delete
                this.oldValue.length - this.value.length, 0);
        }
        /**
         Removed symbols
         @readonly
         */

    }, {
        key: "removed",
        get: function get() {
            return this.oldValue.substr(this.startChangePos, this.removedCount);
        }
        /**
         Unchanged head symbols
         @readonly
         */

    }, {
        key: "head",
        get: function get() {
            return this.value.substring(0, this.startChangePos);
        }
        /**
         Unchanged tail symbols
         @readonly
         */

    }, {
        key: "tail",
        get: function get() {
            return this.value.substring(this.startChangePos + this.insertedCount);
        }
        /**
         Remove direction
         @readonly
         */

    }, {
        key: "removeDirection",
        get: function get() {
            if (!this.removedCount || this.insertedCount) return DIRECTION.NONE; // align right if delete at right or if range removed (event with backspace)

            return this.oldSelection.end === this.cursorPos || this.oldSelection.start === this.cursorPos ? DIRECTION.RIGHT : DIRECTION.LEFT;
        }
    }]);

    return ActionDetails;
}();

/**
 Provides details of changing model value
 @param {Object} [details]
 @param {string} [details.inserted] - Inserted symbols
 @param {boolean} [details.skip] - Can skip chars
 @param {number} [details.removeCount] - Removed symbols count
 @param {number} [details.tailShift] - Additional offset if any changes occurred before tail
 */
var ChangeDetails = /*#__PURE__*/function () {
    /** Inserted symbols */

    /** Can skip chars */

    /** Additional offset if any changes occurred before tail */

    /** Raw inserted is used by dynamic mask */
    function ChangeDetails(details) {
        _classCallCheck(this, ChangeDetails);

        Object.assign(this, {
            inserted: '',
            rawInserted: '',
            skip: false,
            tailShift: 0
        }, details);
    }
    /**
     Aggregate changes
     @returns {ChangeDetails} `this`
     */


    _createClass(ChangeDetails, [{
        key: "aggregate",
        value: function aggregate(details) {
            this.rawInserted += details.rawInserted;
            this.skip = this.skip || details.skip;
            this.inserted += details.inserted;
            this.tailShift += details.tailShift;
            return this;
        }
        /** Total offset considering all changes */

    }, {
        key: "offset",
        get: function get() {
            return this.tailShift + this.inserted.length;
        }
    }]);

    return ChangeDetails;
}();

/** Provides details of continuous extracted tail */
var ContinuousTailDetails = /*#__PURE__*/function () {
    /** Tail value as string */

    /** Tail start position */

    /** Start position */
    function ContinuousTailDetails() {
        var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var stop = arguments.length > 2 ? arguments[2] : undefined;

        _classCallCheck(this, ContinuousTailDetails);

        this.value = value;
        this.from = from;
        this.stop = stop;
    }

    _createClass(ContinuousTailDetails, [{
        key: "toString",
        value: function toString() {
            return this.value;
        }
    }, {
        key: "extend",
        value: function extend(tail) {
            this.value += String(tail);
        }
    }, {
        key: "appendTo",
        value: function appendTo(masked) {
            return masked.append(this.toString(), {
                tail: true
            }).aggregate(masked._appendPlaceholder());
        }
    }, {
        key: "state",
        get: function get() {
            return {
                value: this.value,
                from: this.from,
                stop: this.stop
            };
        },
        set: function set(state) {
            Object.assign(this, state);
        }
    }, {
        key: "shiftBefore",
        value: function shiftBefore(pos) {
            if (this.from >= pos || !this.value.length) return '';
            var shiftChar = this.value[0];
            this.value = this.value.slice(1);
            return shiftChar;
        }
    }]);

    return ContinuousTailDetails;
}();

/**
 * Applies mask on element.
 * @constructor
 * @param {HTMLInputElement|HTMLTextAreaElement|MaskElement} el - Element to apply mask
 * @param {Object} opts - Custom mask options
 * @return {InputMask}
 */
function IMask(el) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    // currently available only for input-like elements
    return new IMask.InputMask(el, opts);
}

/** Supported mask type */

/** Provides common masking stuff */
var Masked = /*#__PURE__*/function () {
    // $Shape<MaskedOptions>; TODO after fix https://github.com/facebook/flow/issues/4773

    /** @type {Mask} */

    /** */
    // $FlowFixMe no ideas

    /** Transforms value before mask processing */

    /** Validates if value is acceptable */

    /** Does additional processing in the end of editing */

    /** Format typed value to string */

    /** Parse strgin to get typed value */

    /** Enable characters overwriting */

    /** */
    function Masked(opts) {
        _classCallCheck(this, Masked);

        this._value = '';

        this._update(Object.assign({}, Masked.DEFAULTS, opts));

        this.isInitialized = true;
    }
    /** Sets and applies new options */


    _createClass(Masked, [{
        key: "updateOptions",
        value: function updateOptions(opts) {
            if (!Object.keys(opts).length) return;
            this.withValueRefresh(this._update.bind(this, opts));
        }
        /**
         Sets new options
         @protected
         */

    }, {
        key: "_update",
        value: function _update(opts) {
            Object.assign(this, opts);
        }
        /** Mask state */

    }, {
        key: "state",
        get: function get() {
            return {
                _value: this.value
            };
        },
        set: function set(state) {
            this._value = state._value;
        }
        /** Resets value */

    }, {
        key: "reset",
        value: function reset() {
            this._value = '';
        }
        /** */

    }, {
        key: "value",
        get: function get() {
            return this._value;
        },
        set: function set(value) {
            this.resolve(value);
        }
        /** Resolve new value */

    }, {
        key: "resolve",
        value: function resolve(value) {
            this.reset();
            this.append(value, {
                input: true
            }, '');
            this.doCommit();
            return this.value;
        }
        /** */

    }, {
        key: "unmaskedValue",
        get: function get() {
            return this.value;
        },
        set: function set(value) {
            this.reset();
            this.append(value, {}, '');
            this.doCommit();
        }
        /** */

    }, {
        key: "typedValue",
        get: function get() {
            return this.doParse(this.value);
        },
        set: function set(value) {
            this.value = this.doFormat(value);
        }
        /** Value that includes raw user input */

    }, {
        key: "rawInputValue",
        get: function get() {
            return this.extractInput(0, this.value.length, {
                raw: true
            });
        },
        set: function set(value) {
            this.reset();
            this.append(value, {
                raw: true
            }, '');
            this.doCommit();
        }
        /** */

    }, {
        key: "isComplete",
        get: function get() {
            return true;
        }
        /** Finds nearest input position in direction */

    }, {
        key: "nearestInputPos",
        value: function nearestInputPos(cursorPos, direction) {
            return cursorPos;
        }
        /** Extracts value in range considering flags */

    }, {
        key: "extractInput",
        value: function extractInput() {
            var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;
            return this.value.slice(fromPos, toPos);
        }
        /** Extracts tail in range */

    }, {
        key: "extractTail",
        value: function extractTail() {
            var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;
            return new ContinuousTailDetails(this.extractInput(fromPos, toPos), fromPos);
        }
        /** Appends tail */
        // $FlowFixMe no ideas

    }, {
        key: "appendTail",
        value: function appendTail(tail) {
            if (isString(tail)) tail = new ContinuousTailDetails(String(tail));
            return tail.appendTo(this);
        }
        /** Appends char */

    }, {
        key: "_appendCharRaw",
        value: function _appendCharRaw(ch) {
            if (!ch) return new ChangeDetails();
            this._value += ch;
            return new ChangeDetails({
                inserted: ch,
                rawInserted: ch
            });
        }
        /** Appends char */

    }, {
        key: "_appendChar",
        value: function _appendChar(ch) {
            var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var checkTail = arguments.length > 2 ? arguments[2] : undefined;
            var consistentState = this.state;

            var details = this._appendCharRaw(this.doPrepare(ch, flags), flags);

            if (details.inserted) {
                var consistentTail;
                var appended = this.doValidate(flags) !== false;

                if (appended && checkTail != null) {
                    // validation ok, check tail
                    var beforeTailState = this.state;

                    if (this.overwrite) {
                        consistentTail = checkTail.state;
                        checkTail.shiftBefore(this.value.length);
                    }

                    var tailDetails = this.appendTail(checkTail);
                    appended = tailDetails.rawInserted === checkTail.toString(); // if ok, rollback state after tail

                    if (appended && tailDetails.inserted) this.state = beforeTailState;
                } // revert all if something went wrong


                if (!appended) {
                    details = new ChangeDetails();
                    this.state = consistentState;
                    if (checkTail && consistentTail) checkTail.state = consistentTail;
                }
            }

            return details;
        }
        /** Appends optional placeholder at end */

    }, {
        key: "_appendPlaceholder",
        value: function _appendPlaceholder() {
            return new ChangeDetails();
        }
        /** Appends symbols considering flags */
        // $FlowFixMe no ideas

    }, {
        key: "append",
        value: function append(str, flags, tail) {
            if (!isString(str)) throw new Error('value should be string');
            var details = new ChangeDetails();
            var checkTail = isString(tail) ? new ContinuousTailDetails(String(tail)) : tail;
            if (flags && flags.tail) flags._beforeTailState = this.state;

            for (var ci = 0; ci < str.length; ++ci) {
                details.aggregate(this._appendChar(str[ci], flags, checkTail));
            } // append tail but aggregate only tailShift


            if (checkTail != null) {
                details.tailShift += this.appendTail(checkTail).tailShift; // TODO it's a good idea to clear state after appending ends
                // but it causes bugs when one append calls another (when dynamic dispatch set rawInputValue)
                // this._resetBeforeTailState();
            }

            return details;
        }
        /** */

    }, {
        key: "remove",
        value: function remove() {
            var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;
            this._value = this.value.slice(0, fromPos) + this.value.slice(toPos);
            return new ChangeDetails();
        }
        /** Calls function and reapplies current value */

    }, {
        key: "withValueRefresh",
        value: function withValueRefresh(fn) {
            if (this._refreshing || !this.isInitialized) return fn();
            this._refreshing = true;
            var rawInput = this.rawInputValue;
            var value = this.value;
            var ret = fn();
            this.rawInputValue = rawInput; // append lost trailing chars at end

            if (this.value && this.value !== value && value.indexOf(this.value) === 0) {
                this.append(value.slice(this.value.length), {}, '');
            }

            delete this._refreshing;
            return ret;
        }
        /** */

    }, {
        key: "runIsolated",
        value: function runIsolated(fn) {
            if (this._isolated || !this.isInitialized) return fn(this);
            this._isolated = true;
            var state = this.state;
            var ret = fn(this);
            this.state = state;
            delete this._isolated;
            return ret;
        }
        /**
         Prepares string before mask processing
         @protected
         */

    }, {
        key: "doPrepare",
        value: function doPrepare(str) {
            var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            return this.prepare ? this.prepare(str, this, flags) : str;
        }
        /**
         Validates if value is acceptable
         @protected
         */

    }, {
        key: "doValidate",
        value: function doValidate(flags) {
            return (!this.validate || this.validate(this.value, this, flags)) && (!this.parent || this.parent.doValidate(flags));
        }
        /**
         Does additional processing in the end of editing
         @protected
         */

    }, {
        key: "doCommit",
        value: function doCommit() {
            if (this.commit) this.commit(this.value, this);
        }
        /** */

    }, {
        key: "doFormat",
        value: function doFormat(value) {
            return this.format ? this.format(value, this) : value;
        }
        /** */

    }, {
        key: "doParse",
        value: function doParse(str) {
            return this.parse ? this.parse(str, this) : str;
        }
        /** */

    }, {
        key: "splice",
        value: function splice(start, deleteCount, inserted, removeDirection) {
            var tailPos = start + deleteCount;
            var tail = this.extractTail(tailPos);
            var startChangePos = this.nearestInputPos(start, removeDirection);
            var changeDetails = new ChangeDetails({
                tailShift: startChangePos - start // adjust tailShift if start was aligned

            }).aggregate(this.remove(startChangePos)).aggregate(this.append(inserted, {
                input: true
            }, tail));
            return changeDetails;
        }
    }]);

    return Masked;
}();
Masked.DEFAULTS = {
    format: function format(v) {
        return v;
    },
    parse: function parse(v) {
        return v;
    }
};
IMask.Masked = Masked;

/** Get Masked class by mask type */

function maskedClass(mask) {
    if (mask == null) {
        throw new Error('mask property should be defined');
    } // $FlowFixMe


    if (mask instanceof RegExp) return IMask.MaskedRegExp; // $FlowFixMe

    if (isString(mask)) return IMask.MaskedPattern; // $FlowFixMe

    if (mask instanceof Date || mask === Date) return IMask.MaskedDate; // $FlowFixMe

    if (mask instanceof Number || typeof mask === 'number' || mask === Number) return IMask.MaskedNumber; // $FlowFixMe

    if (Array.isArray(mask) || mask === Array) return IMask.MaskedDynamic; // $FlowFixMe

    if (IMask.Masked && mask.prototype instanceof IMask.Masked) return mask; // $FlowFixMe

    if (mask instanceof Function) return IMask.MaskedFunction; // $FlowFixMe

    if (mask instanceof IMask.Masked) return mask.constructor;
    console.warn('Mask not found for mask', mask); // eslint-disable-line no-console
    // $FlowFixMe

    return IMask.Masked;
}
/** Creates new {@link Masked} depending on mask type */

function createMask(opts) {
    // $FlowFixMe
    if (IMask.Masked && opts instanceof IMask.Masked) return opts;
    opts = Object.assign({}, opts);
    var mask = opts.mask; // $FlowFixMe

    if (IMask.Masked && mask instanceof IMask.Masked) return mask;
    var MaskedClass = maskedClass(mask);
    if (!MaskedClass) throw new Error('Masked class is not found for provided mask, appropriate module needs to be import manually before creating mask.');
    return new MaskedClass(opts);
}
IMask.createMask = createMask;

var DEFAULT_INPUT_DEFINITIONS = {
    '0': /\d/,
    'a': /[\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
    // http://stackoverflow.com/a/22075070
    '*': /./
};
/** */

var PatternInputDefinition = /*#__PURE__*/function () {
    /** */

    /** */

    /** */

    /** */

    /** */

    /** */
    function PatternInputDefinition(opts) {
        _classCallCheck(this, PatternInputDefinition);

        var mask = opts.mask,
            blockOpts = _objectWithoutProperties(opts, ["mask"]);

        this.masked = createMask({
            mask: mask
        });
        Object.assign(this, blockOpts);
    }

    _createClass(PatternInputDefinition, [{
        key: "reset",
        value: function reset() {
            this._isFilled = false;
            this.masked.reset();
        }
    }, {
        key: "remove",
        value: function remove() {
            var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;

            if (fromPos === 0 && toPos >= 1) {
                this._isFilled = false;
                return this.masked.remove(fromPos, toPos);
            }

            return new ChangeDetails();
        }
    }, {
        key: "value",
        get: function get() {
            return this.masked.value || (this._isFilled && !this.isOptional ? this.placeholderChar : '');
        }
    }, {
        key: "unmaskedValue",
        get: function get() {
            return this.masked.unmaskedValue;
        }
    }, {
        key: "isComplete",
        get: function get() {
            return Boolean(this.masked.value) || this.isOptional;
        }
    }, {
        key: "_appendChar",
        value: function _appendChar(str) {
            var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            if (this._isFilled) return new ChangeDetails();
            var state = this.masked.state; // simulate input

            var details = this.masked._appendChar(str, flags);

            if (details.inserted && this.doValidate(flags) === false) {
                details.inserted = details.rawInserted = '';
                this.masked.state = state;
            }

            if (!details.inserted && !this.isOptional && !this.lazy && !flags.input) {
                details.inserted = this.placeholderChar;
            }

            details.skip = !details.inserted && !this.isOptional;
            this._isFilled = Boolean(details.inserted);
            return details;
        }
    }, {
        key: "append",
        value: function append() {
            var _this$masked;

            return (_this$masked = this.masked).append.apply(_this$masked, arguments);
        }
    }, {
        key: "_appendPlaceholder",
        value: function _appendPlaceholder() {
            var details = new ChangeDetails();
            if (this._isFilled || this.isOptional) return details;
            this._isFilled = true;
            details.inserted = this.placeholderChar;
            return details;
        }
    }, {
        key: "extractTail",
        value: function extractTail() {
            var _this$masked2;

            return (_this$masked2 = this.masked).extractTail.apply(_this$masked2, arguments);
        }
    }, {
        key: "appendTail",
        value: function appendTail() {
            var _this$masked3;

            return (_this$masked3 = this.masked).appendTail.apply(_this$masked3, arguments);
        }
    }, {
        key: "extractInput",
        value: function extractInput() {
            var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;
            var flags = arguments.length > 2 ? arguments[2] : undefined;
            return this.masked.extractInput(fromPos, toPos, flags);
        }
    }, {
        key: "nearestInputPos",
        value: function nearestInputPos(cursorPos) {
            var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE;
            var minPos = 0;
            var maxPos = this.value.length;
            var boundPos = Math.min(Math.max(cursorPos, minPos), maxPos);

            switch (direction) {
                case DIRECTION.LEFT:
                case DIRECTION.FORCE_LEFT:
                    return this.isComplete ? boundPos : minPos;

                case DIRECTION.RIGHT:
                case DIRECTION.FORCE_RIGHT:
                    return this.isComplete ? boundPos : maxPos;

                case DIRECTION.NONE:
                default:
                    return boundPos;
            }
        }
    }, {
        key: "doValidate",
        value: function doValidate() {
            var _this$masked4, _this$parent;

            return (_this$masked4 = this.masked).doValidate.apply(_this$masked4, arguments) && (!this.parent || (_this$parent = this.parent).doValidate.apply(_this$parent, arguments));
        }
    }, {
        key: "doCommit",
        value: function doCommit() {
            this.masked.doCommit();
        }
    }, {
        key: "state",
        get: function get() {
            return {
                masked: this.masked.state,
                _isFilled: this._isFilled
            };
        },
        set: function set(state) {
            this.masked.state = state.masked;
            this._isFilled = state._isFilled;
        }
    }]);

    return PatternInputDefinition;
}();

var PatternFixedDefinition = /*#__PURE__*/function () {
    /** */

    /** */

    /** */

    /** */
    function PatternFixedDefinition(opts) {
        _classCallCheck(this, PatternFixedDefinition);

        Object.assign(this, opts);
        this._value = '';
    }

    _createClass(PatternFixedDefinition, [{
        key: "value",
        get: function get() {
            return this._value;
        }
    }, {
        key: "unmaskedValue",
        get: function get() {
            return this.isUnmasking ? this.value : '';
        }
    }, {
        key: "reset",
        value: function reset() {
            this._isRawInput = false;
            this._value = '';
        }
    }, {
        key: "remove",
        value: function remove() {
            var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._value.length;
            this._value = this._value.slice(0, fromPos) + this._value.slice(toPos);
            if (!this._value) this._isRawInput = false;
            return new ChangeDetails();
        }
    }, {
        key: "nearestInputPos",
        value: function nearestInputPos(cursorPos) {
            var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE;
            var minPos = 0;
            var maxPos = this._value.length;

            switch (direction) {
                case DIRECTION.LEFT:
                case DIRECTION.FORCE_LEFT:
                    return minPos;

                case DIRECTION.NONE:
                case DIRECTION.RIGHT:
                case DIRECTION.FORCE_RIGHT:
                default:
                    return maxPos;
            }
        }
    }, {
        key: "extractInput",
        value: function extractInput() {
            var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._value.length;
            var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            return flags.raw && this._isRawInput && this._value.slice(fromPos, toPos) || '';
        }
    }, {
        key: "isComplete",
        get: function get() {
            return true;
        }
    }, {
        key: "_appendChar",
        value: function _appendChar(str) {
            var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var details = new ChangeDetails();
            if (this._value) return details;
            var appended = this.char === str[0];
            var isResolved = appended && (this.isUnmasking || flags.input || flags.raw) && !flags.tail;
            if (isResolved) details.rawInserted = this.char;
            this._value = details.inserted = this.char;
            this._isRawInput = isResolved && (flags.raw || flags.input);
            return details;
        }
    }, {
        key: "_appendPlaceholder",
        value: function _appendPlaceholder() {
            var details = new ChangeDetails();
            if (this._value) return details;
            this._value = details.inserted = this.char;
            return details;
        }
    }, {
        key: "extractTail",
        value: function extractTail() {
            arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;
            return new ContinuousTailDetails('');
        } // $FlowFixMe no ideas

    }, {
        key: "appendTail",
        value: function appendTail(tail) {
            if (isString(tail)) tail = new ContinuousTailDetails(String(tail));
            return tail.appendTo(this);
        }
    }, {
        key: "append",
        value: function append(str, flags, tail) {
            var details = this._appendChar(str, flags);

            if (tail != null) {
                details.tailShift += this.appendTail(tail).tailShift;
            }

            return details;
        }
    }, {
        key: "doCommit",
        value: function doCommit() {}
    }, {
        key: "state",
        get: function get() {
            return {
                _value: this._value,
                _isRawInput: this._isRawInput
            };
        },
        set: function set(state) {
            Object.assign(this, state);
        }
    }]);

    return PatternFixedDefinition;
}();

var ChunksTailDetails = /*#__PURE__*/function () {
    /** */
    function ChunksTailDetails() {
        var chunks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        _classCallCheck(this, ChunksTailDetails);

        this.chunks = chunks;
        this.from = from;
    }

    _createClass(ChunksTailDetails, [{
        key: "toString",
        value: function toString() {
            return this.chunks.map(String).join('');
        } // $FlowFixMe no ideas

    }, {
        key: "extend",
        value: function extend(tailChunk) {
            if (!String(tailChunk)) return;
            if (isString(tailChunk)) tailChunk = new ContinuousTailDetails(String(tailChunk));
            var lastChunk = this.chunks[this.chunks.length - 1];
            var extendLast = lastChunk && ( // if stops are same or tail has no stop
                    lastChunk.stop === tailChunk.stop || tailChunk.stop == null) && // if tail chunk goes just after last chunk
                tailChunk.from === lastChunk.from + lastChunk.toString().length;

            if (tailChunk instanceof ContinuousTailDetails) {
                // check the ability to extend previous chunk
                if (extendLast) {
                    // extend previous chunk
                    lastChunk.extend(tailChunk.toString());
                } else {
                    // append new chunk
                    this.chunks.push(tailChunk);
                }
            } else if (tailChunk instanceof ChunksTailDetails) {
                if (tailChunk.stop == null) {
                    // unwrap floating chunks to parent, keeping `from` pos
                    var firstTailChunk;

                    while (tailChunk.chunks.length && tailChunk.chunks[0].stop == null) {
                        firstTailChunk = tailChunk.chunks.shift();
                        firstTailChunk.from += tailChunk.from;
                        this.extend(firstTailChunk);
                    }
                } // if tail chunk still has value


                if (tailChunk.toString()) {
                    // if chunks contains stops, then popup stop to container
                    tailChunk.stop = tailChunk.blockIndex;
                    this.chunks.push(tailChunk);
                }
            }
        }
    }, {
        key: "appendTo",
        value: function appendTo(masked) {
            // $FlowFixMe
            if (!(masked instanceof IMask.MaskedPattern)) {
                var tail = new ContinuousTailDetails(this.toString());
                return tail.appendTo(masked);
            }

            var details = new ChangeDetails();

            for (var ci = 0; ci < this.chunks.length && !details.skip; ++ci) {
                var chunk = this.chunks[ci];

                var lastBlockIter = masked._mapPosToBlock(masked.value.length);

                var stop = chunk.stop;
                var chunkBlock = void 0;

                if (stop != null && ( // if block not found or stop is behind lastBlock
                    !lastBlockIter || lastBlockIter.index <= stop)) {
                    if (chunk instanceof ChunksTailDetails || // for continuous block also check if stop is exist
                        masked._stops.indexOf(stop) >= 0) {
                        details.aggregate(masked._appendPlaceholder(stop));
                    }

                    chunkBlock = chunk instanceof ChunksTailDetails && masked._blocks[stop];
                }

                if (chunkBlock) {
                    var tailDetails = chunkBlock.appendTail(chunk);
                    tailDetails.skip = false; // always ignore skip, it will be set on last

                    details.aggregate(tailDetails);
                    masked._value += tailDetails.inserted; // get not inserted chars

                    var remainChars = chunk.toString().slice(tailDetails.rawInserted.length);
                    if (remainChars) details.aggregate(masked.append(remainChars, {
                        tail: true
                    }));
                } else {
                    details.aggregate(masked.append(chunk.toString(), {
                        tail: true
                    }));
                }
            }
            return details;
        }
    }, {
        key: "state",
        get: function get() {
            return {
                chunks: this.chunks.map(function (c) {
                    return c.state;
                }),
                from: this.from,
                stop: this.stop,
                blockIndex: this.blockIndex
            };
        },
        set: function set(state) {
            var chunks = state.chunks,
                props = _objectWithoutProperties(state, ["chunks"]);

            Object.assign(this, props);
            this.chunks = chunks.map(function (cstate) {
                var chunk = "chunks" in cstate ? new ChunksTailDetails() : new ContinuousTailDetails(); // $FlowFixMe already checked above

                chunk.state = cstate;
                return chunk;
            });
        }
    }, {
        key: "shiftBefore",
        value: function shiftBefore(pos) {
            if (this.from >= pos || !this.chunks.length) return '';
            var chunkShiftPos = pos - this.from;
            var ci = 0;

            while (ci < this.chunks.length) {
                var chunk = this.chunks[ci];
                var shiftChar = chunk.shiftBefore(chunkShiftPos);

                if (chunk.toString()) {
                    // chunk still contains value
                    // but not shifted - means no more available chars to shift
                    if (!shiftChar) break;
                    ++ci;
                } else {
                    // clean if chunk has no value
                    this.chunks.splice(ci, 1);
                }

                if (shiftChar) return shiftChar;
            }

            return '';
        }
    }]);

    return ChunksTailDetails;
}();

/** Masking by RegExp */

var MaskedRegExp = /*#__PURE__*/function (_Masked) {
    _inherits(MaskedRegExp, _Masked);

    var _super = _createSuper(MaskedRegExp);

    function MaskedRegExp() {
        _classCallCheck(this, MaskedRegExp);

        return _super.apply(this, arguments);
    }

    _createClass(MaskedRegExp, [{
        key: "_update",
        value:
            /**
             @override
             @param {Object} opts
             */
            function _update(opts) {
                if (opts.mask) opts.validate = function (value) {
                    return value.search(opts.mask) >= 0;
                };

                _get(_getPrototypeOf(MaskedRegExp.prototype), "_update", this).call(this, opts);
            }
    }]);

    return MaskedRegExp;
}(Masked);
IMask.MaskedRegExp = MaskedRegExp;

/**
 Pattern mask
 @param {Object} opts
 @param {Object} opts.blocks
 @param {Object} opts.definitions
 @param {string} opts.placeholderChar
 @param {boolean} opts.lazy
 */
var MaskedPattern = /*#__PURE__*/function (_Masked) {
    _inherits(MaskedPattern, _Masked);

    var _super = _createSuper(MaskedPattern);

    /** */

    /** */

    /** Single char for empty input */

    /** Show placeholder only when needed */
    function MaskedPattern() {
        var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, MaskedPattern);

        // TODO type $Shape<MaskedPatternOptions>={} does not work
        opts.definitions = Object.assign({}, DEFAULT_INPUT_DEFINITIONS, opts.definitions);
        return _super.call(this, Object.assign({}, MaskedPattern.DEFAULTS, opts));
    }
    /**
     @override
     @param {Object} opts
     */


    _createClass(MaskedPattern, [{
        key: "_update",
        value: function _update() {
            var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            opts.definitions = Object.assign({}, this.definitions, opts.definitions);

            _get(_getPrototypeOf(MaskedPattern.prototype), "_update", this).call(this, opts);

            this._rebuildMask();
        }
        /** */

    }, {
        key: "_rebuildMask",
        value: function _rebuildMask() {
            var _this = this;

            var defs = this.definitions;
            this._blocks = [];
            this._stops = [];
            this._maskedBlocks = {};
            var pattern = this.mask;
            if (!pattern || !defs) return;
            var unmaskingBlock = false;
            var optionalBlock = false;

            for (var i = 0; i < pattern.length; ++i) {
                if (this.blocks) {
                    var _ret = function () {
                        var p = pattern.slice(i);
                        var bNames = Object.keys(_this.blocks).filter(function (bName) {
                            return p.indexOf(bName) === 0;
                        }); // order by key length

                        bNames.sort(function (a, b) {
                            return b.length - a.length;
                        }); // use block name with max length

                        var bName = bNames[0];

                        if (bName) {
                            // $FlowFixMe no ideas
                            var maskedBlock = createMask(Object.assign({
                                parent: _this,
                                lazy: _this.lazy,
                                placeholderChar: _this.placeholderChar,
                                overwrite: _this.overwrite
                            }, _this.blocks[bName]));

                            if (maskedBlock) {
                                _this._blocks.push(maskedBlock); // store block index


                                if (!_this._maskedBlocks[bName]) _this._maskedBlocks[bName] = [];

                                _this._maskedBlocks[bName].push(_this._blocks.length - 1);
                            }

                            i += bName.length - 1;
                            return "continue";
                        }
                    }();

                    if (_ret === "continue") continue;
                }

                var char = pattern[i];

                var _isInput = (char in defs);

                if (char === MaskedPattern.STOP_CHAR) {
                    this._stops.push(this._blocks.length);

                    continue;
                }

                if (char === '{' || char === '}') {
                    unmaskingBlock = !unmaskingBlock;
                    continue;
                }

                if (char === '[' || char === ']') {
                    optionalBlock = !optionalBlock;
                    continue;
                }

                if (char === MaskedPattern.ESCAPE_CHAR) {
                    ++i;
                    char = pattern[i];
                    if (!char) break;
                    _isInput = false;
                }

                var def = _isInput ? new PatternInputDefinition({
                    parent: this,
                    lazy: this.lazy,
                    placeholderChar: this.placeholderChar,
                    mask: defs[char],
                    isOptional: optionalBlock
                }) : new PatternFixedDefinition({
                    char: char,
                    isUnmasking: unmaskingBlock
                });

                this._blocks.push(def);
            }
        }
        /**
         @override
         */

    }, {
        key: "state",
        get: function get() {
            return Object.assign({}, _get(_getPrototypeOf(MaskedPattern.prototype), "state", this), {
                _blocks: this._blocks.map(function (b) {
                    return b.state;
                })
            });
        },
        set: function set(state) {
            var _blocks = state._blocks,
                maskedState = _objectWithoutProperties(state, ["_blocks"]);

            this._blocks.forEach(function (b, bi) {
                return b.state = _blocks[bi];
            });

            _set(_getPrototypeOf(MaskedPattern.prototype), "state", maskedState, this, true);
        }
        /**
         @override
         */

    }, {
        key: "reset",
        value: function reset() {
            _get(_getPrototypeOf(MaskedPattern.prototype), "reset", this).call(this);

            this._blocks.forEach(function (b) {
                return b.reset();
            });
        }
        /**
         @override
         */

    }, {
        key: "isComplete",
        get: function get() {
            return this._blocks.every(function (b) {
                return b.isComplete;
            });
        }
        /**
         @override
         */

    }, {
        key: "doCommit",
        value: function doCommit() {
            this._blocks.forEach(function (b) {
                return b.doCommit();
            });

            _get(_getPrototypeOf(MaskedPattern.prototype), "doCommit", this).call(this);
        }
        /**
         @override
         */

    }, {
        key: "unmaskedValue",
        get: function get() {
            return this._blocks.reduce(function (str, b) {
                return str += b.unmaskedValue;
            }, '');
        },
        set: function set(unmaskedValue) {
            _set(_getPrototypeOf(MaskedPattern.prototype), "unmaskedValue", unmaskedValue, this, true);
        }
        /**
         @override
         */

    }, {
        key: "value",
        get: function get() {
            // TODO return _value when not in change?
            return this._blocks.reduce(function (str, b) {
                return str += b.value;
            }, '');
        },
        set: function set(value) {
            _set(_getPrototypeOf(MaskedPattern.prototype), "value", value, this, true);
        }
        /**
         @override
         */

    }, {
        key: "appendTail",
        value: function appendTail(tail) {
            return _get(_getPrototypeOf(MaskedPattern.prototype), "appendTail", this).call(this, tail).aggregate(this._appendPlaceholder());
        }
        /**
         @override
         */

    }, {
        key: "_appendCharRaw",
        value: function _appendCharRaw(ch) {
            var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            var blockIter = this._mapPosToBlock(this.value.length);

            var details = new ChangeDetails();
            if (!blockIter) return details;

            for (var bi = blockIter.index;; ++bi) {
                var _block = this._blocks[bi];
                if (!_block) break;

                var blockDetails = _block._appendChar(ch, flags);

                var skip = blockDetails.skip;
                details.aggregate(blockDetails);
                if (skip || blockDetails.rawInserted) break; // go next char
            }

            return details;
        }
        /**
         @override
         */

    }, {
        key: "extractTail",
        value: function extractTail() {
            var _this2 = this;

            var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;
            var chunkTail = new ChunksTailDetails();
            if (fromPos === toPos) return chunkTail;

            this._forEachBlocksInRange(fromPos, toPos, function (b, bi, bFromPos, bToPos) {
                var blockChunk = b.extractTail(bFromPos, bToPos);
                blockChunk.stop = _this2._findStopBefore(bi);
                blockChunk.from = _this2._blockStartPos(bi);
                if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;
                chunkTail.extend(blockChunk);
            });

            return chunkTail;
        }
        /**
         @override
         */

    }, {
        key: "extractInput",
        value: function extractInput() {
            var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;
            var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            if (fromPos === toPos) return '';
            var input = '';

            this._forEachBlocksInRange(fromPos, toPos, function (b, _, fromPos, toPos) {
                input += b.extractInput(fromPos, toPos, flags);
            });

            return input;
        }
    }, {
        key: "_findStopBefore",
        value: function _findStopBefore(blockIndex) {
            var stopBefore;

            for (var si = 0; si < this._stops.length; ++si) {
                var stop = this._stops[si];
                if (stop <= blockIndex) stopBefore = stop;else break;
            }

            return stopBefore;
        }
        /** Appends placeholder depending on laziness */

    }, {
        key: "_appendPlaceholder",
        value: function _appendPlaceholder(toBlockIndex) {
            var _this3 = this;

            var details = new ChangeDetails();
            if (this.lazy && toBlockIndex == null) return details;

            var startBlockIter = this._mapPosToBlock(this.value.length);

            if (!startBlockIter) return details;
            var startBlockIndex = startBlockIter.index;
            var endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;

            this._blocks.slice(startBlockIndex, endBlockIndex).forEach(function (b) {
                if (!b.lazy || toBlockIndex != null) {
                    // $FlowFixMe `_blocks` may not be present
                    var args = b._blocks != null ? [b._blocks.length] : [];

                    var bDetails = b._appendPlaceholder.apply(b, args);

                    _this3._value += bDetails.inserted;
                    details.aggregate(bDetails);
                }
            });

            return details;
        }
        /** Finds block in pos */

    }, {
        key: "_mapPosToBlock",
        value: function _mapPosToBlock(pos) {
            var accVal = '';

            for (var bi = 0; bi < this._blocks.length; ++bi) {
                var _block2 = this._blocks[bi];
                var blockStartPos = accVal.length;
                accVal += _block2.value;

                if (pos <= accVal.length) {
                    return {
                        index: bi,
                        offset: pos - blockStartPos
                    };
                }
            }
        }
        /** */

    }, {
        key: "_blockStartPos",
        value: function _blockStartPos(blockIndex) {
            return this._blocks.slice(0, blockIndex).reduce(function (pos, b) {
                return pos += b.value.length;
            }, 0);
        }
        /** */

    }, {
        key: "_forEachBlocksInRange",
        value: function _forEachBlocksInRange(fromPos) {
            var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;
            var fn = arguments.length > 2 ? arguments[2] : undefined;

            var fromBlockIter = this._mapPosToBlock(fromPos);

            if (fromBlockIter) {
                var toBlockIter = this._mapPosToBlock(toPos); // process first block


                var isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;
                var fromBlockStartPos = fromBlockIter.offset;
                var fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].value.length;
                fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);

                if (toBlockIter && !isSameBlock) {
                    // process intermediate blocks
                    for (var bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {
                        fn(this._blocks[bi], bi, 0, this._blocks[bi].value.length);
                    } // process last block


                    fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);
                }
            }
        }
        /**
         @override
         */

    }, {
        key: "remove",
        value: function remove() {
            var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;

            var removeDetails = _get(_getPrototypeOf(MaskedPattern.prototype), "remove", this).call(this, fromPos, toPos);

            this._forEachBlocksInRange(fromPos, toPos, function (b, _, bFromPos, bToPos) {
                removeDetails.aggregate(b.remove(bFromPos, bToPos));
            });

            return removeDetails;
        }
        /**
         @override
         */

    }, {
        key: "nearestInputPos",
        value: function nearestInputPos(cursorPos) {
            var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE;
            // TODO refactor - extract alignblock
            var beginBlockData = this._mapPosToBlock(cursorPos) || {
                index: 0,
                offset: 0
            };
            var beginBlockOffset = beginBlockData.offset,
                beginBlockIndex = beginBlockData.index;
            var beginBlock = this._blocks[beginBlockIndex];
            if (!beginBlock) return cursorPos;
            var beginBlockCursorPos = beginBlockOffset; // if position inside block - try to adjust it

            if (beginBlockCursorPos !== 0 && beginBlockCursorPos < beginBlock.value.length) {
                beginBlockCursorPos = beginBlock.nearestInputPos(beginBlockOffset, forceDirection(direction));
            }

            var cursorAtRight = beginBlockCursorPos === beginBlock.value.length;
            var cursorAtLeft = beginBlockCursorPos === 0; //  cursor is INSIDE first block (not at bounds)

            if (!cursorAtLeft && !cursorAtRight) return this._blockStartPos(beginBlockIndex) + beginBlockCursorPos;
            var searchBlockIndex = cursorAtRight ? beginBlockIndex + 1 : beginBlockIndex;

            if (direction === DIRECTION.NONE) {
                // NONE direction used to calculate start input position if no chars were removed
                // FOR NONE:
                // -
                // input|any
                // ->
                //  any|input
                // <-
                //  filled-input|any
                // check if first block at left is input
                if (searchBlockIndex > 0) {
                    var blockIndexAtLeft = searchBlockIndex - 1;
                    var blockAtLeft = this._blocks[blockIndexAtLeft];
                    var blockInputPos = blockAtLeft.nearestInputPos(0, DIRECTION.NONE); // is input

                    if (!blockAtLeft.value.length || blockInputPos !== blockAtLeft.value.length) {
                        return this._blockStartPos(searchBlockIndex);
                    }
                } // ->


                var firstInputAtRight = searchBlockIndex;

                for (var bi = firstInputAtRight; bi < this._blocks.length; ++bi) {
                    var blockAtRight = this._blocks[bi];

                    var _blockInputPos = blockAtRight.nearestInputPos(0, DIRECTION.NONE);

                    if (!blockAtRight.value.length || _blockInputPos !== blockAtRight.value.length) {
                        return this._blockStartPos(bi) + _blockInputPos;
                    }
                } // <-
                // find first non-fixed symbol


                for (var _bi = searchBlockIndex - 1; _bi >= 0; --_bi) {
                    var _block3 = this._blocks[_bi];

                    var _blockInputPos2 = _block3.nearestInputPos(0, DIRECTION.NONE); // is input


                    if (!_block3.value.length || _blockInputPos2 !== _block3.value.length) {
                        return this._blockStartPos(_bi) + _block3.value.length;
                    }
                }

                return cursorPos;
            }

            if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {
                // -
                //  any|filled-input
                // <-
                //  any|first not empty is not-len-aligned
                //  not-0-aligned|any
                // ->
                //  any|not-len-aligned or end
                // check if first block at right is filled input
                var firstFilledBlockIndexAtRight;

                for (var _bi2 = searchBlockIndex; _bi2 < this._blocks.length; ++_bi2) {
                    if (this._blocks[_bi2].value) {
                        firstFilledBlockIndexAtRight = _bi2;
                        break;
                    }
                }

                if (firstFilledBlockIndexAtRight != null) {
                    var filledBlock = this._blocks[firstFilledBlockIndexAtRight];

                    var _blockInputPos3 = filledBlock.nearestInputPos(0, DIRECTION.RIGHT);

                    if (_blockInputPos3 === 0 && filledBlock.unmaskedValue.length) {
                        // filled block is input
                        return this._blockStartPos(firstFilledBlockIndexAtRight) + _blockInputPos3;
                    }
                } // <-
                // find this vars


                var firstFilledInputBlockIndex = -1;
                var firstEmptyInputBlockIndex; // TODO consider nested empty inputs

                for (var _bi3 = searchBlockIndex - 1; _bi3 >= 0; --_bi3) {
                    var _block4 = this._blocks[_bi3];

                    var _blockInputPos4 = _block4.nearestInputPos(_block4.value.length, DIRECTION.FORCE_LEFT);

                    if (!_block4.value || _blockInputPos4 !== 0) firstEmptyInputBlockIndex = _bi3;

                    if (_blockInputPos4 !== 0) {
                        if (_blockInputPos4 !== _block4.value.length) {
                            // aligned inside block - return immediately
                            return this._blockStartPos(_bi3) + _blockInputPos4;
                        } else {
                            // found filled
                            firstFilledInputBlockIndex = _bi3;
                            break;
                        }
                    }
                }

                if (direction === DIRECTION.LEFT) {
                    // try find first empty input before start searching position only when not forced
                    for (var _bi4 = firstFilledInputBlockIndex + 1; _bi4 <= Math.min(searchBlockIndex, this._blocks.length - 1); ++_bi4) {
                        var _block5 = this._blocks[_bi4];

                        var _blockInputPos5 = _block5.nearestInputPos(0, DIRECTION.NONE);

                        var blockAlignedPos = this._blockStartPos(_bi4) + _blockInputPos5;

                        if (blockAlignedPos > cursorPos) break; // if block is not lazy input

                        if (_blockInputPos5 !== _block5.value.length) return blockAlignedPos;
                    }
                } // process overflow


                if (firstFilledInputBlockIndex >= 0) {
                    return this._blockStartPos(firstFilledInputBlockIndex) + this._blocks[firstFilledInputBlockIndex].value.length;
                } // for lazy if has aligned left inside fixed and has came to the start - use start position


                if (direction === DIRECTION.FORCE_LEFT || this.lazy && !this.extractInput() && !isInput(this._blocks[searchBlockIndex])) {
                    return 0;
                }

                if (firstEmptyInputBlockIndex != null) {
                    return this._blockStartPos(firstEmptyInputBlockIndex);
                } // find first input


                for (var _bi5 = searchBlockIndex; _bi5 < this._blocks.length; ++_bi5) {
                    var _block6 = this._blocks[_bi5];

                    var _blockInputPos6 = _block6.nearestInputPos(0, DIRECTION.NONE); // is input


                    if (!_block6.value.length || _blockInputPos6 !== _block6.value.length) {
                        return this._blockStartPos(_bi5) + _blockInputPos6;
                    }
                }

                return 0;
            }

            if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {
                // ->
                //  any|not-len-aligned and filled
                //  any|not-len-aligned
                // <-
                //  not-0-aligned or start|any
                var firstInputBlockAlignedIndex;
                var firstInputBlockAlignedPos;

                for (var _bi6 = searchBlockIndex; _bi6 < this._blocks.length; ++_bi6) {
                    var _block7 = this._blocks[_bi6];

                    var _blockInputPos7 = _block7.nearestInputPos(0, DIRECTION.NONE);

                    if (_blockInputPos7 !== _block7.value.length) {
                        firstInputBlockAlignedPos = this._blockStartPos(_bi6) + _blockInputPos7;
                        firstInputBlockAlignedIndex = _bi6;
                        break;
                    }
                }

                if (firstInputBlockAlignedIndex != null && firstInputBlockAlignedPos != null) {
                    for (var _bi7 = firstInputBlockAlignedIndex; _bi7 < this._blocks.length; ++_bi7) {
                        var _block8 = this._blocks[_bi7];

                        var _blockInputPos8 = _block8.nearestInputPos(0, DIRECTION.FORCE_RIGHT);

                        if (_blockInputPos8 !== _block8.value.length) {
                            return this._blockStartPos(_bi7) + _blockInputPos8;
                        }
                    }

                    return direction === DIRECTION.FORCE_RIGHT ? this.value.length : firstInputBlockAlignedPos;
                }

                for (var _bi8 = Math.min(searchBlockIndex, this._blocks.length - 1); _bi8 >= 0; --_bi8) {
                    var _block9 = this._blocks[_bi8];

                    var _blockInputPos9 = _block9.nearestInputPos(_block9.value.length, DIRECTION.LEFT);

                    if (_blockInputPos9 !== 0) {
                        var alignedPos = this._blockStartPos(_bi8) + _blockInputPos9;

                        if (alignedPos >= cursorPos) return alignedPos;
                        break;
                    }
                }
            }

            return cursorPos;
        }
        /** Get block by name */

    }, {
        key: "maskedBlock",
        value: function maskedBlock(name) {
            return this.maskedBlocks(name)[0];
        }
        /** Get all blocks by name */

    }, {
        key: "maskedBlocks",
        value: function maskedBlocks(name) {
            var _this4 = this;

            var indices = this._maskedBlocks[name];
            if (!indices) return [];
            return indices.map(function (gi) {
                return _this4._blocks[gi];
            });
        }
    }]);

    return MaskedPattern;
}(Masked);
MaskedPattern.DEFAULTS = {
    lazy: true,
    placeholderChar: '_'
};
MaskedPattern.STOP_CHAR = '`';
MaskedPattern.ESCAPE_CHAR = '\\';
MaskedPattern.InputDefinition = PatternInputDefinition;
MaskedPattern.FixedDefinition = PatternFixedDefinition;

function isInput(block) {
    if (!block) return false;
    var value = block.value;
    return !value || block.nearestInputPos(0, DIRECTION.NONE) !== value.length;
}

IMask.MaskedPattern = MaskedPattern;

/** Pattern which accepts ranges */

var MaskedRange = /*#__PURE__*/function (_MaskedPattern) {
    _inherits(MaskedRange, _MaskedPattern);

    var _super = _createSuper(MaskedRange);

    function MaskedRange() {
        _classCallCheck(this, MaskedRange);

        return _super.apply(this, arguments);
    }

    _createClass(MaskedRange, [{
        key: "_matchFrom",
        get:
        /**
         Optionally sets max length of pattern.
         Used when pattern length is longer then `to` param length. Pads zeros at start in this case.
         */

        /** Min bound */

        /** Max bound */

            /** */
            function get() {
                return this.maxLength - String(this.from).length;
            }
        /**
         @override
         */

    }, {
        key: "_update",
        value: function _update(opts) {
            // TODO type
            opts = Object.assign({
                to: this.to || 0,
                from: this.from || 0
            }, opts);
            var maxLength = String(opts.to).length;
            if (opts.maxLength != null) maxLength = Math.max(maxLength, opts.maxLength);
            opts.maxLength = maxLength;
            var fromStr = String(opts.from).padStart(maxLength, '0');
            var toStr = String(opts.to).padStart(maxLength, '0');
            var sameCharsCount = 0;

            while (sameCharsCount < toStr.length && toStr[sameCharsCount] === fromStr[sameCharsCount]) {
                ++sameCharsCount;
            }

            opts.mask = toStr.slice(0, sameCharsCount).replace(/0/g, '\\0') + '0'.repeat(maxLength - sameCharsCount);

            _get(_getPrototypeOf(MaskedRange.prototype), "_update", this).call(this, opts);
        }
        /**
         @override
         */

    }, {
        key: "isComplete",
        get: function get() {
            return _get(_getPrototypeOf(MaskedRange.prototype), "isComplete", this) && Boolean(this.value);
        }
    }, {
        key: "boundaries",
        value: function boundaries(str) {
            var minstr = '';
            var maxstr = '';

            var _ref = str.match(/^(\D*)(\d*)(\D*)/) || [],
                _ref2 = _slicedToArray(_ref, 3),
                placeholder = _ref2[1],
                num = _ref2[2];

            if (num) {
                minstr = '0'.repeat(placeholder.length) + num;
                maxstr = '9'.repeat(placeholder.length) + num;
            }

            minstr = minstr.padEnd(this.maxLength, '0');
            maxstr = maxstr.padEnd(this.maxLength, '9');
            return [minstr, maxstr];
        }
        /**
         @override
         */

    }, {
        key: "doPrepare",
        value: function doPrepare(str) {
            var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            str = _get(_getPrototypeOf(MaskedRange.prototype), "doPrepare", this).call(this, str, flags).replace(/\D/g, '');
            if (!this.autofix) return str;
            var fromStr = String(this.from).padStart(this.maxLength, '0');
            var toStr = String(this.to).padStart(this.maxLength, '0');
            var val = this.value;
            var prepStr = '';

            for (var ci = 0; ci < str.length; ++ci) {
                var nextVal = val + prepStr + str[ci];

                var _this$boundaries = this.boundaries(nextVal),
                    _this$boundaries2 = _slicedToArray(_this$boundaries, 2),
                    minstr = _this$boundaries2[0],
                    maxstr = _this$boundaries2[1];

                if (Number(maxstr) < this.from) prepStr += fromStr[nextVal.length - 1];else if (Number(minstr) > this.to) prepStr += toStr[nextVal.length - 1];else prepStr += str[ci];
            }

            return prepStr;
        }
        /**
         @override
         */

    }, {
        key: "doValidate",
        value: function doValidate() {
            var _get2;

            var str = this.value;
            var firstNonZero = str.search(/[^0]/);
            if (firstNonZero === -1 && str.length <= this._matchFrom) return true;

            var _this$boundaries3 = this.boundaries(str),
                _this$boundaries4 = _slicedToArray(_this$boundaries3, 2),
                minstr = _this$boundaries4[0],
                maxstr = _this$boundaries4[1];

            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            return this.from <= Number(maxstr) && Number(minstr) <= this.to && (_get2 = _get(_getPrototypeOf(MaskedRange.prototype), "doValidate", this)).call.apply(_get2, [this].concat(args));
        }
    }]);

    return MaskedRange;
}(MaskedPattern);
IMask.MaskedRange = MaskedRange;

/** Date mask */

var MaskedDate = /*#__PURE__*/function (_MaskedPattern) {
    _inherits(MaskedDate, _MaskedPattern);

    var _super = _createSuper(MaskedDate);

    /** Pattern mask for date according to {@link MaskedDate#format} */

    /** Start date */

    /** End date */

    /** */

    /**
     @param {Object} opts
     */
    function MaskedDate(opts) {
        _classCallCheck(this, MaskedDate);

        return _super.call(this, Object.assign({}, MaskedDate.DEFAULTS, opts));
    }
    /**
     @override
     */


    _createClass(MaskedDate, [{
        key: "_update",
        value: function _update(opts) {
            if (opts.mask === Date) delete opts.mask;
            if (opts.pattern) opts.mask = opts.pattern;
            var blocks = opts.blocks;
            opts.blocks = Object.assign({}, MaskedDate.GET_DEFAULT_BLOCKS()); // adjust year block

            if (opts.min) opts.blocks.Y.from = opts.min.getFullYear();
            if (opts.max) opts.blocks.Y.to = opts.max.getFullYear();

            if (opts.min && opts.max && opts.blocks.Y.from === opts.blocks.Y.to) {
                opts.blocks.m.from = opts.min.getMonth() + 1;
                opts.blocks.m.to = opts.max.getMonth() + 1;

                if (opts.blocks.m.from === opts.blocks.m.to) {
                    opts.blocks.d.from = opts.min.getDate();
                    opts.blocks.d.to = opts.max.getDate();
                }
            }

            Object.assign(opts.blocks, blocks); // add autofix

            Object.keys(opts.blocks).forEach(function (bk) {
                var b = opts.blocks[bk];
                if (!('autofix' in b)) b.autofix = opts.autofix;
            });

            _get(_getPrototypeOf(MaskedDate.prototype), "_update", this).call(this, opts);
        }
        /**
         @override
         */

    }, {
        key: "doValidate",
        value: function doValidate() {
            var _get2;

            var date = this.date;

            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            return (_get2 = _get(_getPrototypeOf(MaskedDate.prototype), "doValidate", this)).call.apply(_get2, [this].concat(args)) && (!this.isComplete || this.isDateExist(this.value) && date != null && (this.min == null || this.min <= date) && (this.max == null || date <= this.max));
        }
        /** Checks if date is exists */

    }, {
        key: "isDateExist",
        value: function isDateExist(str) {
            return this.format(this.parse(str, this), this).indexOf(str) >= 0;
        }
        /** Parsed Date */

    }, {
        key: "date",
        get: function get() {
            return this.typedValue;
        },
        set: function set(date) {
            this.typedValue = date;
        }
        /**
         @override
         */

    }, {
        key: "typedValue",
        get: function get() {
            return this.isComplete ? _get(_getPrototypeOf(MaskedDate.prototype), "typedValue", this) : null;
        },
        set: function set(value) {
            _set(_getPrototypeOf(MaskedDate.prototype), "typedValue", value, this, true);
        }
    }]);

    return MaskedDate;
}(MaskedPattern);
MaskedDate.DEFAULTS = {
    pattern: 'd{.}`m{.}`Y',
    format: function format(date) {
        var day = String(date.getDate()).padStart(2, '0');
        var month = String(date.getMonth() + 1).padStart(2, '0');
        var year = date.getFullYear();
        return [day, month, year].join('.');
    },
    parse: function parse(str) {
        var _str$split = str.split('.'),
            _str$split2 = _slicedToArray(_str$split, 3),
            day = _str$split2[0],
            month = _str$split2[1],
            year = _str$split2[2];

        return new Date(year, month - 1, day);
    }
};

MaskedDate.GET_DEFAULT_BLOCKS = function () {
    return {
        d: {
            mask: MaskedRange,
            from: 1,
            to: 31,
            maxLength: 2
        },
        m: {
            mask: MaskedRange,
            from: 1,
            to: 12,
            maxLength: 2
        },
        Y: {
            mask: MaskedRange,
            from: 1900,
            to: 9999
        }
    };
};

IMask.MaskedDate = MaskedDate;

/**
 Generic element API to use with mask
 @interface
 */
var MaskElement = /*#__PURE__*/function () {
    function MaskElement() {
        _classCallCheck(this, MaskElement);
    }

    _createClass(MaskElement, [{
        key: "selectionStart",
        get:
        /** */

        /** */

        /** */

            /** Safely returns selection start */
            function get() {
                var start;

                try {
                    start = this._unsafeSelectionStart;
                } catch (e) {}

                return start != null ? start : this.value.length;
            }
        /** Safely returns selection end */

    }, {
        key: "selectionEnd",
        get: function get() {
            var end;

            try {
                end = this._unsafeSelectionEnd;
            } catch (e) {}

            return end != null ? end : this.value.length;
        }
        /** Safely sets element selection */

    }, {
        key: "select",
        value: function select(start, end) {
            if (start == null || end == null || start === this.selectionStart && end === this.selectionEnd) return;

            try {
                this._unsafeSelect(start, end);
            } catch (e) {}
        }
        /** Should be overriden in subclasses */

    }, {
        key: "_unsafeSelect",
        value: function _unsafeSelect(start, end) {}
        /** Should be overriden in subclasses */

    }, {
        key: "isActive",
        get: function get() {
            return false;
        }
        /** Should be overriden in subclasses */

    }, {
        key: "bindEvents",
        value: function bindEvents(handlers) {}
        /** Should be overriden in subclasses */

    }, {
        key: "unbindEvents",
        value: function unbindEvents() {}
    }]);

    return MaskElement;
}();
IMask.MaskElement = MaskElement;

/** Bridge between HTMLElement and {@link Masked} */

var HTMLMaskElement = /*#__PURE__*/function (_MaskElement) {
    _inherits(HTMLMaskElement, _MaskElement);

    var _super = _createSuper(HTMLMaskElement);

    /** Mapping between HTMLElement events and mask internal events */

    /** HTMLElement to use mask on */

    /**
     @param {HTMLInputElement|HTMLTextAreaElement} input
     */
    function HTMLMaskElement(input) {
        var _this;

        _classCallCheck(this, HTMLMaskElement);

        _this = _super.call(this);
        _this.input = input;
        _this._handlers = {};
        return _this;
    }
    /** */
    // $FlowFixMe https://github.com/facebook/flow/issues/2839


    _createClass(HTMLMaskElement, [{
        key: "rootElement",
        get: function get() {
            return this.input.getRootNode ? this.input.getRootNode() : document;
        }
        /**
         Is element in focus
         @readonly
         */

    }, {
        key: "isActive",
        get: function get() {
            //$FlowFixMe
            return this.input === this.rootElement.activeElement;
        }
        /**
         Returns HTMLElement selection start
         @override
         */

    }, {
        key: "_unsafeSelectionStart",
        get: function get() {
            return this.input.selectionStart;
        }
        /**
         Returns HTMLElement selection end
         @override
         */

    }, {
        key: "_unsafeSelectionEnd",
        get: function get() {
            return this.input.selectionEnd;
        }
        /**
         Sets HTMLElement selection
         @override
         */

    }, {
        key: "_unsafeSelect",
        value: function _unsafeSelect(start, end) {
            this.input.setSelectionRange(start, end);
        }
        /**
         HTMLElement value
         @override
         */

    }, {
        key: "value",
        get: function get() {
            return this.input.value;
        },
        set: function set(value) {
            this.input.value = value;
        }
        /**
         Binds HTMLElement events to mask internal events
         @override
         */

    }, {
        key: "bindEvents",
        value: function bindEvents(handlers) {
            var _this2 = this;

            Object.keys(handlers).forEach(function (event) {
                return _this2._toggleEventHandler(HTMLMaskElement.EVENTS_MAP[event], handlers[event]);
            });
        }
        /**
         Unbinds HTMLElement events to mask internal events
         @override
         */

    }, {
        key: "unbindEvents",
        value: function unbindEvents() {
            var _this3 = this;

            Object.keys(this._handlers).forEach(function (event) {
                return _this3._toggleEventHandler(event);
            });
        }
        /** */

    }, {
        key: "_toggleEventHandler",
        value: function _toggleEventHandler(event, handler) {
            if (this._handlers[event]) {
                this.input.removeEventListener(event, this._handlers[event]);
                delete this._handlers[event];
            }

            if (handler) {
                this.input.addEventListener(event, handler);
                this._handlers[event] = handler;
            }
        }
    }]);

    return HTMLMaskElement;
}(MaskElement);
HTMLMaskElement.EVENTS_MAP = {
    selectionChange: 'keydown',
    input: 'input',
    drop: 'drop',
    click: 'click',
    focus: 'focus',
    commit: 'blur'
};
IMask.HTMLMaskElement = HTMLMaskElement;

var HTMLContenteditableMaskElement = /*#__PURE__*/function (_HTMLMaskElement) {
    _inherits(HTMLContenteditableMaskElement, _HTMLMaskElement);

    var _super = _createSuper(HTMLContenteditableMaskElement);

    function HTMLContenteditableMaskElement() {
        _classCallCheck(this, HTMLContenteditableMaskElement);

        return _super.apply(this, arguments);
    }

    _createClass(HTMLContenteditableMaskElement, [{
        key: "_unsafeSelectionStart",
        get:
            /**
             Returns HTMLElement selection start
             @override
             */
            function get() {
                var root = this.rootElement;
                var selection = root.getSelection && root.getSelection();
                return selection && selection.anchorOffset;
            }
        /**
         Returns HTMLElement selection end
         @override
         */

    }, {
        key: "_unsafeSelectionEnd",
        get: function get() {
            var root = this.rootElement;
            var selection = root.getSelection && root.getSelection();
            return selection && this._unsafeSelectionStart + String(selection).length;
        }
        /**
         Sets HTMLElement selection
         @override
         */

    }, {
        key: "_unsafeSelect",
        value: function _unsafeSelect(start, end) {
            if (!this.rootElement.createRange) return;
            var range = this.rootElement.createRange();
            range.setStart(this.input.firstChild || this.input, start);
            range.setEnd(this.input.lastChild || this.input, end);
            var root = this.rootElement;
            var selection = root.getSelection && root.getSelection();

            if (selection) {
                selection.removeAllRanges();
                selection.addRange(range);
            }
        }
        /**
         HTMLElement value
         @override
         */

    }, {
        key: "value",
        get: function get() {
            // $FlowFixMe
            return this.input.textContent;
        },
        set: function set(value) {
            this.input.textContent = value;
        }
    }]);

    return HTMLContenteditableMaskElement;
}(HTMLMaskElement);
IMask.HTMLContenteditableMaskElement = HTMLContenteditableMaskElement;

/** Listens to element events and controls changes between element and {@link Masked} */

var InputMask = /*#__PURE__*/function () {
    /**
     View element
     @readonly
     */

    /**
     Internal {@link Masked} model
     @readonly
     */

    /**
     @param {MaskElement|HTMLInputElement|HTMLTextAreaElement} el
     @param {Object} opts
     */
    function InputMask(el, opts) {
        _classCallCheck(this, InputMask);

        this.el = el instanceof MaskElement ? el : el.isContentEditable && el.tagName !== 'INPUT' && el.tagName !== 'TEXTAREA' ? new HTMLContenteditableMaskElement(el) : new HTMLMaskElement(el);
        this.masked = createMask(opts);
        this._listeners = {};
        this._value = '';
        this._unmaskedValue = '';
        this._saveSelection = this._saveSelection.bind(this);
        this._onInput = this._onInput.bind(this);
        this._onChange = this._onChange.bind(this);
        this._onDrop = this._onDrop.bind(this);
        this._onFocus = this._onFocus.bind(this);
        this._onClick = this._onClick.bind(this);
        this.alignCursor = this.alignCursor.bind(this);
        this.alignCursorFriendly = this.alignCursorFriendly.bind(this);

        this._bindEvents(); // refresh


        this.updateValue();

        this._onChange();
    }
    /** Read or update mask */


    _createClass(InputMask, [{
        key: "mask",
        get: function get() {
            return this.masked.mask;
        },
        set: function set(mask) {
            if (this.maskEquals(mask)) return;

            if (!(mask instanceof IMask.Masked) && this.masked.constructor === maskedClass(mask)) {
                this.masked.updateOptions({
                    mask: mask
                });
                return;
            }

            var masked = createMask({
                mask: mask
            });
            masked.unmaskedValue = this.masked.unmaskedValue;
            this.masked = masked;
        }
        /** Raw value */

    }, {
        key: "maskEquals",
        value: function maskEquals(mask) {
            return mask == null || mask === this.masked.mask || mask === Date && this.masked instanceof MaskedDate;
        }
    }, {
        key: "value",
        get: function get() {
            return this._value;
        },
        set: function set(str) {
            this.masked.value = str;
            this.updateControl();
            this.alignCursor();
        }
        /** Unmasked value */

    }, {
        key: "unmaskedValue",
        get: function get() {
            return this._unmaskedValue;
        },
        set: function set(str) {
            this.masked.unmaskedValue = str;
            this.updateControl();
            this.alignCursor();
        }
        /** Typed unmasked value */

    }, {
        key: "typedValue",
        get: function get() {
            return this.masked.typedValue;
        },
        set: function set(val) {
            this.masked.typedValue = val;
            this.updateControl();
            this.alignCursor();
        }
        /**
         Starts listening to element events
         @protected
         */

    }, {
        key: "_bindEvents",
        value: function _bindEvents() {
            this.el.bindEvents({
                selectionChange: this._saveSelection,
                input: this._onInput,
                drop: this._onDrop,
                click: this._onClick,
                focus: this._onFocus,
                commit: this._onChange
            });
        }
        /**
         Stops listening to element events
         @protected
         */

    }, {
        key: "_unbindEvents",
        value: function _unbindEvents() {
            if (this.el) this.el.unbindEvents();
        }
        /**
         Fires custom event
         @protected
         */

    }, {
        key: "_fireEvent",
        value: function _fireEvent(ev) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
            }

            var listeners = this._listeners[ev];
            if (!listeners) return;
            listeners.forEach(function (l) {
                return l.apply(void 0, args);
            });
        }
        /**
         Current selection start
         @readonly
         */

    }, {
        key: "selectionStart",
        get: function get() {
            return this._cursorChanging ? this._changingCursorPos : this.el.selectionStart;
        }
        /** Current cursor position */

    }, {
        key: "cursorPos",
        get: function get() {
            return this._cursorChanging ? this._changingCursorPos : this.el.selectionEnd;
        },
        set: function set(pos) {
            if (!this.el || !this.el.isActive) return;
            this.el.select(pos, pos);

            this._saveSelection();
        }
        /**
         Stores current selection
         @protected
         */

    }, {
        key: "_saveSelection",
        value: function _saveSelection()
            /* ev */
        {
            if (this.value !== this.el.value) {
                console.warn('Element value was changed outside of mask. Syncronize mask using `mask.updateValue()` to work properly.'); // eslint-disable-line no-console
            }

            this._selection = {
                start: this.selectionStart,
                end: this.cursorPos
            };
        }
        /** Syncronizes model value from view */

    }, {
        key: "updateValue",
        value: function updateValue() {
            this.masked.value = this.el.value;
            this._value = this.masked.value;
        }
        /** Syncronizes view from model value, fires change events */

    }, {
        key: "updateControl",
        value: function updateControl() {
            var newUnmaskedValue = this.masked.unmaskedValue;
            var newValue = this.masked.value;
            var isChanged = this.unmaskedValue !== newUnmaskedValue || this.value !== newValue;
            this._unmaskedValue = newUnmaskedValue;
            this._value = newValue;
            if (this.el.value !== newValue) this.el.value = newValue;
            if (isChanged) this._fireChangeEvents();
        }
        /** Updates options with deep equal check, recreates @{link Masked} model if mask type changes */

    }, {
        key: "updateOptions",
        value: function updateOptions(opts) {
            var mask = opts.mask,
                restOpts = _objectWithoutProperties(opts, ["mask"]);

            var updateMask = !this.maskEquals(mask);
            var updateOpts = !objectIncludes(this.masked, restOpts);
            if (updateMask) this.mask = mask;
            if (updateOpts) this.masked.updateOptions(restOpts);
            if (updateMask || updateOpts) this.updateControl();
        }
        /** Updates cursor */

    }, {
        key: "updateCursor",
        value: function updateCursor(cursorPos) {
            if (cursorPos == null) return;
            this.cursorPos = cursorPos; // also queue change cursor for mobile browsers

            this._delayUpdateCursor(cursorPos);
        }
        /**
         Delays cursor update to support mobile browsers
         @private
         */

    }, {
        key: "_delayUpdateCursor",
        value: function _delayUpdateCursor(cursorPos) {
            var _this = this;

            this._abortUpdateCursor();

            this._changingCursorPos = cursorPos;
            this._cursorChanging = setTimeout(function () {
                if (!_this.el) return; // if was destroyed

                _this.cursorPos = _this._changingCursorPos;

                _this._abortUpdateCursor();
            }, 10);
        }
        /**
         Fires custom events
         @protected
         */

    }, {
        key: "_fireChangeEvents",
        value: function _fireChangeEvents() {
            this._fireEvent('accept', this._inputEvent);

            if (this.masked.isComplete) this._fireEvent('complete', this._inputEvent);
        }
        /**
         Aborts delayed cursor update
         @private
         */

    }, {
        key: "_abortUpdateCursor",
        value: function _abortUpdateCursor() {
            if (this._cursorChanging) {
                clearTimeout(this._cursorChanging);
                delete this._cursorChanging;
            }
        }
        /** Aligns cursor to nearest available position */

    }, {
        key: "alignCursor",
        value: function alignCursor() {
            this.cursorPos = this.masked.nearestInputPos(this.cursorPos, DIRECTION.LEFT);
        }
        /** Aligns cursor only if selection is empty */

    }, {
        key: "alignCursorFriendly",
        value: function alignCursorFriendly() {
            if (this.selectionStart !== this.cursorPos) return; // skip if range is selected

            this.alignCursor();
        }
        /** Adds listener on custom event */

    }, {
        key: "on",
        value: function on(ev, handler) {
            if (!this._listeners[ev]) this._listeners[ev] = [];

            this._listeners[ev].push(handler);

            return this;
        }
        /** Removes custom event listener */

    }, {
        key: "off",
        value: function off(ev, handler) {
            if (!this._listeners[ev]) return this;

            if (!handler) {
                delete this._listeners[ev];
                return this;
            }

            var hIndex = this._listeners[ev].indexOf(handler);

            if (hIndex >= 0) this._listeners[ev].splice(hIndex, 1);
            return this;
        }
        /** Handles view input event */

    }, {
        key: "_onInput",
        value: function _onInput(e) {
            this._inputEvent = e;

            this._abortUpdateCursor(); // fix strange IE behavior


            if (!this._selection) return this.updateValue();
            var details = new ActionDetails( // new state
                this.el.value, this.cursorPos, // old state
                this.value, this._selection);
            var oldRawValue = this.masked.rawInputValue;
            var offset = this.masked.splice(details.startChangePos, details.removed.length, details.inserted, details.removeDirection).offset; // force align in remove direction only if no input chars were removed
            // otherwise we still need to align with NONE (to get out from fixed symbols for instance)

            var removeDirection = oldRawValue === this.masked.rawInputValue ? details.removeDirection : DIRECTION.NONE;
            var cursorPos = this.masked.nearestInputPos(details.startChangePos + offset, removeDirection);
            this.updateControl();
            this.updateCursor(cursorPos);
            delete this._inputEvent;
        }
        /** Handles view change event and commits model value */

    }, {
        key: "_onChange",
        value: function _onChange() {
            if (this.value !== this.el.value) {
                this.updateValue();
            }

            this.masked.doCommit();
            this.updateControl();

            this._saveSelection();
        }
        /** Handles view drop event, prevents by default */

    }, {
        key: "_onDrop",
        value: function _onDrop(ev) {
            ev.preventDefault();
            ev.stopPropagation();
        }
        /** Restore last selection on focus */

    }, {
        key: "_onFocus",
        value: function _onFocus(ev) {
            this.alignCursorFriendly();
        }
        /** Restore last selection on focus */

    }, {
        key: "_onClick",
        value: function _onClick(ev) {
            this.alignCursorFriendly();
        }
        /** Unbind view events and removes element reference */

    }, {
        key: "destroy",
        value: function destroy() {
            this._unbindEvents(); // $FlowFixMe why not do so?


            this._listeners.length = 0; // $FlowFixMe

            delete this.el;
        }
    }]);

    return InputMask;
}();
IMask.InputMask = InputMask;

/** Pattern which validates enum values */

var MaskedEnum = /*#__PURE__*/function (_MaskedPattern) {
    _inherits(MaskedEnum, _MaskedPattern);

    var _super = _createSuper(MaskedEnum);

    function MaskedEnum() {
        _classCallCheck(this, MaskedEnum);

        return _super.apply(this, arguments);
    }

    _createClass(MaskedEnum, [{
        key: "_update",
        value:
            /**
             @override
             @param {Object} opts
             */
            function _update(opts) {
                // TODO type
                if (opts.enum) opts.mask = '*'.repeat(opts.enum[0].length);

                _get(_getPrototypeOf(MaskedEnum.prototype), "_update", this).call(this, opts);
            }
        /**
         @override
         */

    }, {
        key: "doValidate",
        value: function doValidate() {
            var _this = this,
                _get2;

            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            return this.enum.some(function (e) {
                return e.indexOf(_this.unmaskedValue) >= 0;
            }) && (_get2 = _get(_getPrototypeOf(MaskedEnum.prototype), "doValidate", this)).call.apply(_get2, [this].concat(args));
        }
    }]);

    return MaskedEnum;
}(MaskedPattern);
IMask.MaskedEnum = MaskedEnum;

/**
 Number mask
 @param {Object} opts
 @param {string} opts.radix - Single char
 @param {string} opts.thousandsSeparator - Single char
 @param {Array<string>} opts.mapToRadix - Array of single chars
 @param {number} opts.min
 @param {number} opts.max
 @param {number} opts.scale - Digits after point
 @param {boolean} opts.signed - Allow negative
 @param {boolean} opts.normalizeZeros - Flag to remove leading and trailing zeros in the end of editing
 @param {boolean} opts.padFractionalZeros - Flag to pad trailing zeros after point in the end of editing
 */
var MaskedNumber = /*#__PURE__*/function (_Masked) {
    _inherits(MaskedNumber, _Masked);

    var _super = _createSuper(MaskedNumber);

    /** Single char */

    /** Single char */

    /** Array of single chars */

    /** */

    /** */

    /** Digits after point */

    /** */

    /** Flag to remove leading and trailing zeros in the end of editing */

    /** Flag to pad trailing zeros after point in the end of editing */
    function MaskedNumber(opts) {
        _classCallCheck(this, MaskedNumber);

        return _super.call(this, Object.assign({}, MaskedNumber.DEFAULTS, opts));
    }
    /**
     @override
     */


    _createClass(MaskedNumber, [{
        key: "_update",
        value: function _update(opts) {
            _get(_getPrototypeOf(MaskedNumber.prototype), "_update", this).call(this, opts);

            this._updateRegExps();
        }
        /** */

    }, {
        key: "_updateRegExps",
        value: function _updateRegExps() {
            // use different regexp to process user input (more strict, input suffix) and tail shifting
            var start = '^' + (this.allowNegative ? '[+|\\-]?' : '');
            var midInput = '(0|([1-9]+\\d*))?';
            var mid = '\\d*';
            var end = (this.scale ? '(' + escapeRegExp(this.radix) + '\\d{0,' + this.scale + '})?' : '') + '$';
            this._numberRegExpInput = new RegExp(start + midInput + end);
            this._numberRegExp = new RegExp(start + mid + end);
            this._mapToRadixRegExp = new RegExp('[' + this.mapToRadix.map(escapeRegExp).join('') + ']', 'g');
            this._thousandsSeparatorRegExp = new RegExp(escapeRegExp(this.thousandsSeparator), 'g');
        }
        /** */

    }, {
        key: "_removeThousandsSeparators",
        value: function _removeThousandsSeparators(value) {
            return value.replace(this._thousandsSeparatorRegExp, '');
        }
        /** */

    }, {
        key: "_insertThousandsSeparators",
        value: function _insertThousandsSeparators(value) {
            // https://stackoverflow.com/questions/2901102/how-to-print-a-number-with-commas-as-thousands-separators-in-javascript
            var parts = value.split(this.radix);
            parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, this.thousandsSeparator);
            return parts.join(this.radix);
        }
        /**
         @override
         */

    }, {
        key: "doPrepare",
        value: function doPrepare(str) {
            var _get2;

            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
            }

            return (_get2 = _get(_getPrototypeOf(MaskedNumber.prototype), "doPrepare", this)).call.apply(_get2, [this, this._removeThousandsSeparators(str.replace(this._mapToRadixRegExp, this.radix))].concat(args));
        }
        /** */

    }, {
        key: "_separatorsCount",
        value: function _separatorsCount(to) {
            var extendOnSeparators = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            var count = 0;

            for (var pos = 0; pos < to; ++pos) {
                if (this._value.indexOf(this.thousandsSeparator, pos) === pos) {
                    ++count;
                    if (extendOnSeparators) to += this.thousandsSeparator.length;
                }
            }

            return count;
        }
        /** */

    }, {
        key: "_separatorsCountFromSlice",
        value: function _separatorsCountFromSlice() {
            var slice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._value;
            return this._separatorsCount(this._removeThousandsSeparators(slice).length, true);
        }
        /**
         @override
         */

    }, {
        key: "extractInput",
        value: function extractInput() {
            var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;
            var flags = arguments.length > 2 ? arguments[2] : undefined;

            var _this$_adjustRangeWit = this._adjustRangeWithSeparators(fromPos, toPos);

            var _this$_adjustRangeWit2 = _slicedToArray(_this$_adjustRangeWit, 2);

            fromPos = _this$_adjustRangeWit2[0];
            toPos = _this$_adjustRangeWit2[1];
            return this._removeThousandsSeparators(_get(_getPrototypeOf(MaskedNumber.prototype), "extractInput", this).call(this, fromPos, toPos, flags));
        }
        /**
         @override
         */

    }, {
        key: "_appendCharRaw",
        value: function _appendCharRaw(ch) {
            var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            if (!this.thousandsSeparator) return _get(_getPrototypeOf(MaskedNumber.prototype), "_appendCharRaw", this).call(this, ch, flags);
            var prevBeforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;

            var prevBeforeTailSeparatorsCount = this._separatorsCountFromSlice(prevBeforeTailValue);

            this._value = this._removeThousandsSeparators(this.value);

            var appendDetails = _get(_getPrototypeOf(MaskedNumber.prototype), "_appendCharRaw", this).call(this, ch, flags);

            this._value = this._insertThousandsSeparators(this._value);
            var beforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;

            var beforeTailSeparatorsCount = this._separatorsCountFromSlice(beforeTailValue);

            appendDetails.tailShift += (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length;
            appendDetails.skip = !appendDetails.rawInserted && ch === this.thousandsSeparator;
            return appendDetails;
        }
        /** */

    }, {
        key: "_findSeparatorAround",
        value: function _findSeparatorAround(pos) {
            if (this.thousandsSeparator) {
                var searchFrom = pos - this.thousandsSeparator.length + 1;
                var separatorPos = this.value.indexOf(this.thousandsSeparator, searchFrom);
                if (separatorPos <= pos) return separatorPos;
            }

            return -1;
        }
    }, {
        key: "_adjustRangeWithSeparators",
        value: function _adjustRangeWithSeparators(from, to) {
            var separatorAroundFromPos = this._findSeparatorAround(from);

            if (separatorAroundFromPos >= 0) from = separatorAroundFromPos;

            var separatorAroundToPos = this._findSeparatorAround(to);

            if (separatorAroundToPos >= 0) to = separatorAroundToPos + this.thousandsSeparator.length;
            return [from, to];
        }
        /**
         @override
         */

    }, {
        key: "remove",
        value: function remove() {
            var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;

            var _this$_adjustRangeWit3 = this._adjustRangeWithSeparators(fromPos, toPos);

            var _this$_adjustRangeWit4 = _slicedToArray(_this$_adjustRangeWit3, 2);

            fromPos = _this$_adjustRangeWit4[0];
            toPos = _this$_adjustRangeWit4[1];
            var valueBeforePos = this.value.slice(0, fromPos);
            var valueAfterPos = this.value.slice(toPos);

            var prevBeforeTailSeparatorsCount = this._separatorsCount(valueBeforePos.length);

            this._value = this._insertThousandsSeparators(this._removeThousandsSeparators(valueBeforePos + valueAfterPos));

            var beforeTailSeparatorsCount = this._separatorsCountFromSlice(valueBeforePos);

            return new ChangeDetails({
                tailShift: (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length
            });
        }
        /**
         @override
         */

    }, {
        key: "nearestInputPos",
        value: function nearestInputPos(cursorPos, direction) {
            if (!this.thousandsSeparator) return cursorPos;

            switch (direction) {
                case DIRECTION.NONE:
                case DIRECTION.LEFT:
                case DIRECTION.FORCE_LEFT:
                {
                    var separatorAtLeftPos = this._findSeparatorAround(cursorPos - 1);

                    if (separatorAtLeftPos >= 0) {
                        var separatorAtLeftEndPos = separatorAtLeftPos + this.thousandsSeparator.length;

                        if (cursorPos < separatorAtLeftEndPos || this.value.length <= separatorAtLeftEndPos || direction === DIRECTION.FORCE_LEFT) {
                            return separatorAtLeftPos;
                        }
                    }

                    break;
                }

                case DIRECTION.RIGHT:
                case DIRECTION.FORCE_RIGHT:
                {
                    var separatorAtRightPos = this._findSeparatorAround(cursorPos);

                    if (separatorAtRightPos >= 0) {
                        return separatorAtRightPos + this.thousandsSeparator.length;
                    }
                }
            }

            return cursorPos;
        }
        /**
         @override
         */

    }, {
        key: "doValidate",
        value: function doValidate(flags) {
            var regexp = flags.input ? this._numberRegExpInput : this._numberRegExp; // validate as string

            var valid = regexp.test(this._removeThousandsSeparators(this.value));

            if (valid) {
                // validate as number
                var number = this.number;
                valid = valid && !isNaN(number) && ( // check min bound for negative values
                    this.min == null || this.min >= 0 || this.min <= this.number) && ( // check max bound for positive values
                    this.max == null || this.max <= 0 || this.number <= this.max);
            }

            return valid && _get(_getPrototypeOf(MaskedNumber.prototype), "doValidate", this).call(this, flags);
        }
        /**
         @override
         */

    }, {
        key: "doCommit",
        value: function doCommit() {
            if (this.value) {
                var number = this.number;
                var validnum = number; // check bounds

                if (this.min != null) validnum = Math.max(validnum, this.min);
                if (this.max != null) validnum = Math.min(validnum, this.max);
                if (validnum !== number) this.unmaskedValue = String(validnum);
                var formatted = this.value;
                if (this.normalizeZeros) formatted = this._normalizeZeros(formatted);
                if (this.padFractionalZeros) formatted = this._padFractionalZeros(formatted);
                this._value = formatted;
            }

            _get(_getPrototypeOf(MaskedNumber.prototype), "doCommit", this).call(this);
        }
        /** */

    }, {
        key: "_normalizeZeros",
        value: function _normalizeZeros(value) {
            var parts = this._removeThousandsSeparators(value).split(this.radix); // remove leading zeros


            parts[0] = parts[0].replace(/^(\D*)(0*)(\d*)/, function (match, sign, zeros, num) {
                return sign + num;
            }); // add leading zero

            if (value.length && !/\d$/.test(parts[0])) parts[0] = parts[0] + '0';

            if (parts.length > 1) {
                parts[1] = parts[1].replace(/0*$/, ''); // remove trailing zeros

                if (!parts[1].length) parts.length = 1; // remove fractional
            }

            return this._insertThousandsSeparators(parts.join(this.radix));
        }
        /** */

    }, {
        key: "_padFractionalZeros",
        value: function _padFractionalZeros(value) {
            if (!value) return value;
            var parts = value.split(this.radix);
            if (parts.length < 2) parts.push('');
            parts[1] = parts[1].padEnd(this.scale, '0');
            return parts.join(this.radix);
        }
        /**
         @override
         */

    }, {
        key: "unmaskedValue",
        get: function get() {
            return this._removeThousandsSeparators(this._normalizeZeros(this.value)).replace(this.radix, '.');
        },
        set: function set(unmaskedValue) {
            _set(_getPrototypeOf(MaskedNumber.prototype), "unmaskedValue", unmaskedValue.replace('.', this.radix), this, true);
        }
        /**
         @override
         */

    }, {
        key: "typedValue",
        get: function get() {
            return Number(this.unmaskedValue);
        },
        set: function set(n) {
            _set(_getPrototypeOf(MaskedNumber.prototype), "unmaskedValue", String(n), this, true);
        }
        /** Parsed Number */

    }, {
        key: "number",
        get: function get() {
            return this.typedValue;
        },
        set: function set(number) {
            this.typedValue = number;
        }
        /**
         Is negative allowed
         @readonly
         */

    }, {
        key: "allowNegative",
        get: function get() {
            return this.signed || this.min != null && this.min < 0 || this.max != null && this.max < 0;
        }
    }]);

    return MaskedNumber;
}(Masked);
MaskedNumber.DEFAULTS = {
    radix: ',',
    thousandsSeparator: '',
    mapToRadix: ['.'],
    scale: 2,
    signed: false,
    normalizeZeros: true,
    padFractionalZeros: false
};
IMask.MaskedNumber = MaskedNumber;

/** Masking by custom Function */

var MaskedFunction = /*#__PURE__*/function (_Masked) {
    _inherits(MaskedFunction, _Masked);

    var _super = _createSuper(MaskedFunction);

    function MaskedFunction() {
        _classCallCheck(this, MaskedFunction);

        return _super.apply(this, arguments);
    }

    _createClass(MaskedFunction, [{
        key: "_update",
        value:
            /**
             @override
             @param {Object} opts
             */
            function _update(opts) {
                if (opts.mask) opts.validate = opts.mask;

                _get(_getPrototypeOf(MaskedFunction.prototype), "_update", this).call(this, opts);
            }
    }]);

    return MaskedFunction;
}(Masked);
IMask.MaskedFunction = MaskedFunction;

/** Dynamic mask for choosing apropriate mask in run-time */
var MaskedDynamic = /*#__PURE__*/function (_Masked) {
    _inherits(MaskedDynamic, _Masked);

    var _super = _createSuper(MaskedDynamic);

    /** Currently chosen mask */

    /** Compliled {@link Masked} options */

    /** Chooses {@link Masked} depending on input value */

    /**
     @param {Object} opts
     */
    function MaskedDynamic(opts) {
        var _this;

        _classCallCheck(this, MaskedDynamic);

        _this = _super.call(this, Object.assign({}, MaskedDynamic.DEFAULTS, opts));
        _this.currentMask = null;
        return _this;
    }
    /**
     @override
     */


    _createClass(MaskedDynamic, [{
        key: "_update",
        value: function _update(opts) {
            _get(_getPrototypeOf(MaskedDynamic.prototype), "_update", this).call(this, opts);

            if ('mask' in opts) {
                // mask could be totally dynamic with only `dispatch` option
                this.compiledMasks = Array.isArray(opts.mask) ? opts.mask.map(function (m) {
                    return createMask(m);
                }) : [];
            }
        }
        /**
         @override
         */

    }, {
        key: "_appendCharRaw",
        value: function _appendCharRaw(ch) {
            var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            var details = this._applyDispatch(ch, flags);

            if (this.currentMask) {
                details.aggregate(this.currentMask._appendChar(ch, flags));
            }

            return details;
        }
    }, {
        key: "_applyDispatch",
        value: function _applyDispatch() {
            var appended = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
            var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var prevValueBeforeTail = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._value : this.value;
            var inputValue = this.rawInputValue;
            var insertValue = flags.tail && flags._beforeTailState != null ? // $FlowFixMe - tired to fight with type system
                flags._beforeTailState._rawInputValue : inputValue;
            var tailValue = inputValue.slice(insertValue.length);
            var prevMask = this.currentMask;
            var details = new ChangeDetails();
            var prevMaskState = prevMask && prevMask.state; // clone flags to prevent overwriting `_beforeTailState`

            this.currentMask = this.doDispatch(appended, Object.assign({}, flags)); // restore state after dispatch

            if (this.currentMask) {
                if (this.currentMask !== prevMask) {
                    // if mask changed reapply input
                    this.currentMask.reset();

                    if (insertValue) {
                        // $FlowFixMe - it's ok, we don't change current mask above
                        var d = this.currentMask.append(insertValue, {
                            raw: true
                        });
                        details.tailShift = d.inserted.length - prevValueBeforeTail.length;
                    }

                    if (tailValue) {
                        // $FlowFixMe - it's ok, we don't change current mask above
                        details.tailShift += this.currentMask.append(tailValue, {
                            raw: true,
                            tail: true
                        }).tailShift;
                    }
                } else {
                    // Dispatch can do something bad with state, so
                    // restore prev mask state
                    this.currentMask.state = prevMaskState;
                }
            }

            return details;
        }
    }, {
        key: "_appendPlaceholder",
        value: function _appendPlaceholder() {
            var details = this._applyDispatch.apply(this, arguments);

            if (this.currentMask) {
                details.aggregate(this.currentMask._appendPlaceholder());
            }

            return details;
        }
        /**
         @override
         */

    }, {
        key: "doDispatch",
        value: function doDispatch(appended) {
            var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            return this.dispatch(appended, this, flags);
        }
        /**
         @override
         */

    }, {
        key: "doValidate",
        value: function doValidate() {
            var _get2, _this$currentMask;

            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            return (_get2 = _get(_getPrototypeOf(MaskedDynamic.prototype), "doValidate", this)).call.apply(_get2, [this].concat(args)) && (!this.currentMask || (_this$currentMask = this.currentMask).doValidate.apply(_this$currentMask, args));
        }
        /**
         @override
         */

    }, {
        key: "reset",
        value: function reset() {
            if (this.currentMask) this.currentMask.reset();
            this.compiledMasks.forEach(function (m) {
                return m.reset();
            });
        }
        /**
         @override
         */

    }, {
        key: "value",
        get: function get() {
            return this.currentMask ? this.currentMask.value : '';
        },
        set: function set(value) {
            _set(_getPrototypeOf(MaskedDynamic.prototype), "value", value, this, true);
        }
        /**
         @override
         */

    }, {
        key: "unmaskedValue",
        get: function get() {
            return this.currentMask ? this.currentMask.unmaskedValue : '';
        },
        set: function set(unmaskedValue) {
            _set(_getPrototypeOf(MaskedDynamic.prototype), "unmaskedValue", unmaskedValue, this, true);
        }
        /**
         @override
         */

    }, {
        key: "typedValue",
        get: function get() {
            return this.currentMask ? this.currentMask.typedValue : '';
        } // probably typedValue should not be used with dynamic
        ,
        set: function set(value) {
            var unmaskedValue = String(value); // double check it

            if (this.currentMask) {
                this.currentMask.typedValue = value;
                unmaskedValue = this.currentMask.unmaskedValue;
            }

            this.unmaskedValue = unmaskedValue;
        }
        /**
         @override
         */

    }, {
        key: "isComplete",
        get: function get() {
            return !!this.currentMask && this.currentMask.isComplete;
        }
        /**
         @override
         */

    }, {
        key: "remove",
        value: function remove() {
            var details = new ChangeDetails();

            if (this.currentMask) {
                var _this$currentMask2;

                details.aggregate((_this$currentMask2 = this.currentMask).remove.apply(_this$currentMask2, arguments)) // update with dispatch
                    .aggregate(this._applyDispatch());
            }

            return details;
        }
        /**
         @override
         */

    }, {
        key: "state",
        get: function get() {
            return Object.assign({}, _get(_getPrototypeOf(MaskedDynamic.prototype), "state", this), {
                _rawInputValue: this.rawInputValue,
                compiledMasks: this.compiledMasks.map(function (m) {
                    return m.state;
                }),
                currentMaskRef: this.currentMask,
                currentMask: this.currentMask && this.currentMask.state
            });
        },
        set: function set(state) {
            var compiledMasks = state.compiledMasks,
                currentMaskRef = state.currentMaskRef,
                currentMask = state.currentMask,
                maskedState = _objectWithoutProperties(state, ["compiledMasks", "currentMaskRef", "currentMask"]);

            this.compiledMasks.forEach(function (m, mi) {
                return m.state = compiledMasks[mi];
            });

            if (currentMaskRef != null) {
                this.currentMask = currentMaskRef;
                this.currentMask.state = currentMask;
            }

            _set(_getPrototypeOf(MaskedDynamic.prototype), "state", maskedState, this, true);
        }
        /**
         @override
         */

    }, {
        key: "extractInput",
        value: function extractInput() {
            var _this$currentMask3;

            return this.currentMask ? (_this$currentMask3 = this.currentMask).extractInput.apply(_this$currentMask3, arguments) : '';
        }
        /**
         @override
         */

    }, {
        key: "extractTail",
        value: function extractTail() {
            var _this$currentMask4, _get3;

            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = arguments[_key2];
            }

            return this.currentMask ? (_this$currentMask4 = this.currentMask).extractTail.apply(_this$currentMask4, args) : (_get3 = _get(_getPrototypeOf(MaskedDynamic.prototype), "extractTail", this)).call.apply(_get3, [this].concat(args));
        }
        /**
         @override
         */

    }, {
        key: "doCommit",
        value: function doCommit() {
            if (this.currentMask) this.currentMask.doCommit();

            _get(_getPrototypeOf(MaskedDynamic.prototype), "doCommit", this).call(this);
        }
        /**
         @override
         */

    }, {
        key: "nearestInputPos",
        value: function nearestInputPos() {
            var _this$currentMask5, _get4;

            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                args[_key3] = arguments[_key3];
            }

            return this.currentMask ? (_this$currentMask5 = this.currentMask).nearestInputPos.apply(_this$currentMask5, args) : (_get4 = _get(_getPrototypeOf(MaskedDynamic.prototype), "nearestInputPos", this)).call.apply(_get4, [this].concat(args));
        }
    }, {
        key: "overwrite",
        get: function get() {
            return this.currentMask ? this.currentMask.overwrite : _get(_getPrototypeOf(MaskedDynamic.prototype), "overwrite", this);
        },
        set: function set(overwrite) {
            console.warn('"overwrite" option is not available in dynamic mask, use this option in siblings');
        }
    }]);

    return MaskedDynamic;
}(Masked);
MaskedDynamic.DEFAULTS = {
    dispatch: function dispatch(appended, masked, flags) {
        if (!masked.compiledMasks.length) return;
        var inputValue = masked.rawInputValue; // simulate input

        var inputs = masked.compiledMasks.map(function (m, index) {
            m.reset();
            m.append(inputValue, {
                raw: true
            });
            m.append(appended, flags);
            var weight = m.rawInputValue.length;
            return {
                weight: weight,
                index: index
            };
        }); // pop masks with longer values first

        inputs.sort(function (i1, i2) {
            return i2.weight - i1.weight;
        });
        return masked.compiledMasks[inputs[0].index];
    }
};
IMask.MaskedDynamic = MaskedDynamic;

/** Mask pipe source and destination types */

var PIPE_TYPE = {
    MASKED: 'value',
    UNMASKED: 'unmaskedValue',
    TYPED: 'typedValue'
};
/** Creates new pipe function depending on mask type, source and destination options */

function createPipe(mask) {
    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : PIPE_TYPE.MASKED;
    var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PIPE_TYPE.MASKED;
    var masked = createMask(mask);
    return function (value) {
        return masked.runIsolated(function (m) {
            m[from] = value;
            return m[to];
        });
    };
}
/** Pipes value through mask depending on mask type, source and destination options */

function pipe(value) {
    for (var _len = arguments.length, pipeArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        pipeArgs[_key - 1] = arguments[_key];
    }

    return createPipe.apply(void 0, pipeArgs)(value);
}
IMask.PIPE_TYPE = PIPE_TYPE;
IMask.createPipe = createPipe;
IMask.pipe = pipe;

try {
    globalThis.IMask = IMask;
} catch (e) {}

var IMaskComponent = {
    name: 'imask-input',
    render: function render(createElement) {
        var _this = this;

        var props = {
            domProps: {
                value: this.maskRef ? this.maskRef.value : this.value
            },
            on: Object.assign({}, this.$listeners)
        }; // if there is no mask use default input event

        if (!this.$props.mask) {
            props.on.input = function (event) {
                return _this.$emit('input', event.target.value);
            };
        } else {
            delete props.on.input;
        }

        return createElement('input', props);
    },
    mounted: function mounted() {
        if (!this.$props.mask) return;

        this._initMask();
    },
    destroyed: function destroyed() {
        this._destroyMask();
    },
    computed: {
        maskOptions: function maskOptions() {
            return this._extractOptionsFromProps(this.$props);
        }
    },
    watch: {
        '$props': {
            handler: function handler(props) {
                var maskOptions = this.maskOptions;

                if (maskOptions.mask) {
                    if (this.maskRef) {
                        this.maskRef.updateOptions(maskOptions);

                        if ('value' in props && (props.value !== this._maskValue() || // handle cases like Number('') === 0,
                            // for details see https://github.com/uNmAnNeR/imaskjs/issues/134
                            typeof props.value !== 'string' && this.maskRef.value === '' && !this.maskRef.el.isActive)) {
                            this._updateValue();
                        }
                    } else {
                        this._initMask(maskOptions);

                        if (props.value !== this._maskValue()) this._onAccept();
                    }
                } else {
                    this._destroyMask();

                    if ('value' in props) this.$el.value = props.value;
                }
            },
            deep: true
        }
    },
    methods: {
        _extractOptionsFromProps: function _extractOptionsFromProps(props) {
            props = Object.assign({}, props); // keep only defined props

            Object.keys(props).filter(function (prop) {
                return props[prop] === undefined;
            }).forEach(function (undefinedProp) {
                delete props[undefinedProp];
            });
            delete props.value;
            delete props.unmask;
            return props;
        },
        _maskValue: function _maskValue() {
            if (this.unmask === 'typed') return this.maskRef.typedValue;
            if (this.unmask) return this.maskRef.unmaskedValue;
            return this.maskRef.value;
        },
        _updateValue: function _updateValue() {
            var value = this.value == null ? '' : this.value;
            if (this.unmask === 'typed') this.maskRef.typedValue = value;else if (this.unmask) this.maskRef.unmaskedValue = value;else this.maskRef.value = value;
        },
        _onAccept: function _onAccept() {
            var val = this._maskValue();

            this.$emit('input', val, this.maskRef);
            this.$emit('accept', val, this.maskRef);
        },
        _onComplete: function _onComplete() {
            this.$emit('complete', this._maskValue(), this.maskRef);
        },
        _initMask: function _initMask() {
            var maskOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.maskOptions;
            this.maskRef = IMask(this.$el, maskOptions).on('accept', this._onAccept.bind(this)).on('complete', this._onComplete.bind(this));

            this._updateValue();
        },
        _destroyMask: function _destroyMask() {
            if (this.maskRef) {
                this.maskRef.destroy();
                delete this.maskRef;
            }
        }
    },
    props: {
        // common
        mask: {},
        value: {},
        unmask: {
            validator: function validator(value) {
                return value === 'typed' || typeof value === 'boolean';
            }
        },
        prepare: Function,
        validate: Function,
        commit: Function,
        overwrite: {
            type: Boolean,
            required: false,
            default: undefined
        },
        // pattern
        placeholderChar: String,
        lazy: {
            type: Boolean,
            required: false,
            default: undefined
        },
        definitions: Object,
        blocks: Object,
        // date
        pattern: String,
        format: Function,
        parse: Function,
        autofix: {
            type: Boolean,
            required: false,
            default: undefined
        },
        // number
        radix: String,
        thousandsSeparator: String,
        mapToRadix: Array,
        scale: Number,
        signed: {
            type: Boolean,
            required: false,
            default: undefined
        },
        normalizeZeros: {
            type: Boolean,
            required: false,
            default: undefined
        },
        padFractionalZeros: {
            type: Boolean,
            required: false,
            default: undefined
        },
        min: [Number, Date],
        max: [Number, Date],
        // dynamic
        dispatch: Function
    }
};

var vueSelect = createCommonjsModule(function (module, exports) {
    !function(t,e){module.exports=e();}("undefined"!=typeof self?self:commonjsGlobal,(function(){return function(t){var e={};function n(o){if(e[o])return e[o].exports;var i=e[o]={i:o,l:!1,exports:{}};return t[o].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=t,n.c=e,n.d=function(t,e,o){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:o});},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0});},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var o=Object.create(null);if(n.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var i in t)n.d(o,i,function(e){return t[e]}.bind(null,i));return o},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="/",n(n.s=8)}([function(t,e,n){var o=n(4),i=n(5),s=n(6);t.exports=function(t){return o(t)||i(t)||s()};},function(t,e){function n(e){return "function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?t.exports=n=function(t){return typeof t}:t.exports=n=function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},n(e)}t.exports=n;},function(t,e,n){},function(t,e){t.exports=function(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t};},function(t,e){t.exports=function(t){if(Array.isArray(t)){for(var e=0,n=new Array(t.length);e<t.length;e++)n[e]=t[e];return n}};},function(t,e){t.exports=function(t){if(Symbol.iterator in Object(t)||"[object Arguments]"===Object.prototype.toString.call(t))return Array.from(t)};},function(t,e){t.exports=function(){throw new TypeError("Invalid attempt to spread non-iterable instance")};},function(t,e,n){var o=n(2);n.n(o).a;},function(t,e,n){n.r(e);var o=n(0),i=n.n(o),s=n(1),r=n.n(s),a=n(3),l=n.n(a),c={props:{autoscroll:{type:Boolean,default:!0}},watch:{typeAheadPointer:function(){this.autoscroll&&this.maybeAdjustScroll();}},methods:{maybeAdjustScroll:function(){var t,e=(null===(t=this.$refs.dropdownMenu)||void 0===t?void 0:t.children[this.typeAheadPointer])||!1;if(e){var n=this.getDropdownViewport(),o=e.getBoundingClientRect(),i=o.top,s=o.bottom,r=o.height;if(i<n.top)return this.$refs.dropdownMenu.scrollTop=e.offsetTop;if(s>n.bottom)return this.$refs.dropdownMenu.scrollTop=e.offsetTop-(n.height-r)}},getDropdownViewport:function(){return this.$refs.dropdownMenu?this.$refs.dropdownMenu.getBoundingClientRect():{height:0,top:0,bottom:0}}}},u={data:function(){return {typeAheadPointer:-1}},watch:{filteredOptions:function(){for(var t=0;t<this.filteredOptions.length;t++)if(this.selectable(this.filteredOptions[t])){this.typeAheadPointer=t;break}}},methods:{typeAheadUp:function(){for(var t=this.typeAheadPointer-1;t>=0;t--)if(this.selectable(this.filteredOptions[t])){this.typeAheadPointer=t;break}},typeAheadDown:function(){for(var t=this.typeAheadPointer+1;t<this.filteredOptions.length;t++)if(this.selectable(this.filteredOptions[t])){this.typeAheadPointer=t;break}},typeAheadSelect:function(){var t=this.filteredOptions[this.typeAheadPointer];t&&this.select(t);}}},p={props:{loading:{type:Boolean,default:!1}},data:function(){return {mutableLoading:!1}},watch:{search:function(){this.$emit("search",this.search,this.toggleLoading);},loading:function(t){this.mutableLoading=t;}},methods:{toggleLoading:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;return this.mutableLoading=null==t?!this.mutableLoading:t}}};function h(t,e,n,o,i,s,r,a){var l,c="function"==typeof t?t.options:t;if(e&&(c.render=e,c.staticRenderFns=n,c._compiled=!0),o&&(c.functional=!0),s&&(c._scopeId="data-v-"+s),r?(l=function(t){(t=t||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(t=__VUE_SSR_CONTEXT__),i&&i.call(this,t),t&&t._registeredComponents&&t._registeredComponents.add(r);},c._ssrRegister=l):i&&(l=a?function(){i.call(this,this.$root.$options.shadowRoot);}:i),l)if(c.functional){c._injectStyles=l;var u=c.render;c.render=function(t,e){return l.call(e),u(t,e)};}else {var p=c.beforeCreate;c.beforeCreate=p?[].concat(p,l):[l];}return {exports:t,options:c}}var d={Deselect:h({},(function(){var t=this.$createElement,e=this._self._c||t;return e("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",width:"10",height:"10"}},[e("path",{attrs:{d:"M6.895455 5l2.842897-2.842898c.348864-.348863.348864-.914488 0-1.263636L9.106534.261648c-.348864-.348864-.914489-.348864-1.263636 0L5 3.104545 2.157102.261648c-.348863-.348864-.914488-.348864-1.263636 0L.261648.893466c-.348864.348864-.348864.914489 0 1.263636L3.104545 5 .261648 7.842898c-.348864.348863-.348864.914488 0 1.263636l.631818.631818c.348864.348864.914773.348864 1.263636 0L5 6.895455l2.842898 2.842897c.348863.348864.914772.348864 1.263636 0l.631818-.631818c.348864-.348864.348864-.914489 0-1.263636L6.895455 5z"}})])}),[],!1,null,null,null).exports,OpenIndicator:h({},(function(){var t=this.$createElement,e=this._self._c||t;return e("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"10"}},[e("path",{attrs:{d:"M9.211364 7.59931l4.48338-4.867229c.407008-.441854.407008-1.158247 0-1.60046l-.73712-.80023c-.407008-.441854-1.066904-.441854-1.474243 0L7 5.198617 2.51662.33139c-.407008-.441853-1.066904-.441853-1.474243 0l-.737121.80023c-.407008.441854-.407008 1.158248 0 1.600461l4.48338 4.867228L7 10l2.211364-2.40069z"}})])}),[],!1,null,null,null).exports},f={inserted:function(t,e,n){var o=n.context;if(o.appendToBody){var i=o.$refs.toggle.getBoundingClientRect(),s=i.height,r=i.top,a=i.left,l=i.width,c=window.scrollX||window.pageXOffset,u=window.scrollY||window.pageYOffset;t.unbindPosition=o.calculatePosition(t,o,{width:l+"px",left:c+a+"px",top:u+r+s+"px"}),document.body.appendChild(t);}},unbind:function(t,e,n){n.context.appendToBody&&(t.unbindPosition&&"function"==typeof t.unbindPosition&&t.unbindPosition(),t.parentNode&&t.parentNode.removeChild(t));}};var y=function(t){var e={};return Object.keys(t).sort().forEach((function(n){e[n]=t[n];})),JSON.stringify(e)},b=0;var g=function(){return ++b};function v(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,o);}return n}function m(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?v(Object(n),!0).forEach((function(e){l()(t,e,n[e]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):v(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e));}));}return t}var _={components:m({},d),mixins:[c,u,p],directives:{appendToBody:f},props:{value:{},components:{type:Object,default:function(){return {}}},options:{type:Array,default:function(){return []}},disabled:{type:Boolean,default:!1},clearable:{type:Boolean,default:!0},searchable:{type:Boolean,default:!0},multiple:{type:Boolean,default:!1},placeholder:{type:String,default:""},transition:{type:String,default:"vs__fade"},clearSearchOnSelect:{type:Boolean,default:!0},closeOnSelect:{type:Boolean,default:!0},label:{type:String,default:"label"},autocomplete:{type:String,default:"off"},reduce:{type:Function,default:function(t){return t}},selectable:{type:Function,default:function(t){return !0}},getOptionLabel:{type:Function,default:function(t){return "object"===r()(t)?t.hasOwnProperty(this.label)?t[this.label]:console.warn('[vue-select warn]: Label key "option.'.concat(this.label,'" does not')+" exist in options object ".concat(JSON.stringify(t),".\n")+"https://vue-select.org/api/props.html#getoptionlabel"):t}},getOptionKey:{type:Function,default:function(t){if("object"!==r()(t))return t;try{return t.hasOwnProperty("id")?t.id:y(t)}catch(e){return console.warn("[vue-select warn]: Could not stringify this option to generate unique key. Please provide'getOptionKey' prop to return a unique key for each option.\nhttps://vue-select.org/api/props.html#getoptionkey",t,e)}}},onTab:{type:Function,default:function(){this.selectOnTab&&!this.isComposing&&this.typeAheadSelect();}},taggable:{type:Boolean,default:!1},tabindex:{type:Number,default:null},pushTags:{type:Boolean,default:!1},filterable:{type:Boolean,default:!0},filterBy:{type:Function,default:function(t,e,n){return (e||"").toLowerCase().indexOf(n.toLowerCase())>-1}},filter:{type:Function,default:function(t,e){var n=this;return t.filter((function(t){var o=n.getOptionLabel(t);return "number"==typeof o&&(o=o.toString()),n.filterBy(t,o,e)}))}},createOption:{type:Function,default:function(t){return "object"===r()(this.optionList[0])?l()({},this.label,t):t}},resetOnOptionsChange:{default:!1,validator:function(t){return ["function","boolean"].includes(r()(t))}},clearSearchOnBlur:{type:Function,default:function(t){var e=t.clearSearchOnSelect,n=t.multiple;return e&&!n}},noDrop:{type:Boolean,default:!1},inputId:{type:String},dir:{type:String,default:"auto"},selectOnTab:{type:Boolean,default:!1},selectOnKeyCodes:{type:Array,default:function(){return [13]}},searchInputQuerySelector:{type:String,default:"[type=search]"},mapKeydown:{type:Function,default:function(t,e){return t}},appendToBody:{type:Boolean,default:!1},calculatePosition:{type:Function,default:function(t,e,n){var o=n.width,i=n.top,s=n.left;t.style.top=i,t.style.left=s,t.style.width=o;}}},data:function(){return {uid:g(),search:"",open:!1,isComposing:!1,pushedTags:[],_value:[]}},watch:{options:function(t,e){var n=this;!this.taggable&&("function"==typeof n.resetOnOptionsChange?n.resetOnOptionsChange(t,e,n.selectedValue):n.resetOnOptionsChange)&&this.clearSelection(),this.value&&this.isTrackingValues&&this.setInternalValueFromOptions(this.value);},value:function(t){this.isTrackingValues&&this.setInternalValueFromOptions(t);},multiple:function(){this.clearSelection();},open:function(t){this.$emit(t?"open":"close");}},created:function(){this.mutableLoading=this.loading,void 0!==this.value&&this.isTrackingValues&&this.setInternalValueFromOptions(this.value),this.$on("option:created",this.pushTag);},methods:{setInternalValueFromOptions:function(t){var e=this;Array.isArray(t)?this.$data._value=t.map((function(t){return e.findOptionFromReducedValue(t)})):this.$data._value=this.findOptionFromReducedValue(t);},select:function(t){this.$emit("option:selecting",t),this.isOptionSelected(t)||(this.taggable&&!this.optionExists(t)&&this.$emit("option:created",t),this.multiple&&(t=this.selectedValue.concat(t)),this.updateValue(t),this.$emit("option:selected",t)),this.onAfterSelect(t);},deselect:function(t){var e=this;this.$emit("option:deselecting",t),this.updateValue(this.selectedValue.filter((function(n){return !e.optionComparator(n,t)}))),this.$emit("option:deselected",t);},clearSelection:function(){this.updateValue(this.multiple?[]:null);},onAfterSelect:function(t){this.closeOnSelect&&(this.open=!this.open,this.searchEl.blur()),this.clearSearchOnSelect&&(this.search="");},updateValue:function(t){var e=this;void 0===this.value&&(this.$data._value=t),null!==t&&(t=Array.isArray(t)?t.map((function(t){return e.reduce(t)})):this.reduce(t)),this.$emit("input",t);},toggleDropdown:function(t){var e=t.target!==this.searchEl;e&&t.preventDefault();var n=[].concat(i()(this.$refs.deselectButtons||[]),i()([this.$refs.clearButton]||!1));void 0===this.searchEl||n.filter(Boolean).some((function(e){return e.contains(t.target)||e===t.target}))?t.preventDefault():this.open&&e?this.searchEl.blur():this.disabled||(this.open=!0,this.searchEl.focus());},isOptionSelected:function(t){var e=this;return this.selectedValue.some((function(n){return e.optionComparator(n,t)}))},optionComparator:function(t,e){return this.getOptionKey(t)===this.getOptionKey(e)},findOptionFromReducedValue:function(t){var e=this,n=[].concat(i()(this.options),i()(this.pushedTags)).filter((function(n){return JSON.stringify(e.reduce(n))===JSON.stringify(t)}));return 1===n.length?n[0]:n.find((function(t){return e.optionComparator(t,e.$data._value)}))||t},closeSearchOptions:function(){this.open=!1,this.$emit("search:blur");},maybeDeleteValue:function(){if(!this.searchEl.value.length&&this.selectedValue&&this.selectedValue.length&&this.clearable){var t=null;this.multiple&&(t=i()(this.selectedValue.slice(0,this.selectedValue.length-1))),this.updateValue(t);}},optionExists:function(t){var e=this;return this.optionList.some((function(n){return e.optionComparator(n,t)}))},normalizeOptionForSlot:function(t){return "object"===r()(t)?t:l()({},this.label,t)},pushTag:function(t){this.pushedTags.push(t);},onEscape:function(){this.search.length?this.search="":this.searchEl.blur();},onSearchBlur:function(){if(!this.mousedown||this.searching){var t=this.clearSearchOnSelect,e=this.multiple;return this.clearSearchOnBlur({clearSearchOnSelect:t,multiple:e})&&(this.search=""),void this.closeSearchOptions()}this.mousedown=!1,0!==this.search.length||0!==this.options.length||this.closeSearchOptions();},onSearchFocus:function(){this.open=!0,this.$emit("search:focus");},onMousedown:function(){this.mousedown=!0;},onMouseUp:function(){this.mousedown=!1;},onSearchKeyDown:function(t){var e=this,n=function(t){return t.preventDefault(),!e.isComposing&&e.typeAheadSelect()},o={8:function(t){return e.maybeDeleteValue()},9:function(t){return e.onTab()},27:function(t){return e.onEscape()},38:function(t){return t.preventDefault(),e.typeAheadUp()},40:function(t){return t.preventDefault(),e.typeAheadDown()}};this.selectOnKeyCodes.forEach((function(t){return o[t]=n}));var i=this.mapKeydown(o,this);if("function"==typeof i[t.keyCode])return i[t.keyCode](t)}},computed:{isTrackingValues:function(){return void 0===this.value||this.$options.propsData.hasOwnProperty("reduce")},selectedValue:function(){var t=this.value;return this.isTrackingValues&&(t=this.$data._value),t?[].concat(t):[]},optionList:function(){return this.options.concat(this.pushTags?this.pushedTags:[])},searchEl:function(){return this.$scopedSlots.search?this.$refs.selectedOptions.querySelector(this.searchInputQuerySelector):this.$refs.search},scope:function(){var t=this,e={search:this.search,loading:this.loading,searching:this.searching,filteredOptions:this.filteredOptions};return {search:{attributes:m({disabled:this.disabled,placeholder:this.searchPlaceholder,tabindex:this.tabindex,readonly:!this.searchable,id:this.inputId,"aria-autocomplete":"list","aria-labelledby":"vs".concat(this.uid,"__combobox"),"aria-controls":"vs".concat(this.uid,"__listbox"),ref:"search",type:"search",autocomplete:this.autocomplete,value:this.search},this.dropdownOpen&&this.filteredOptions[this.typeAheadPointer]?{"aria-activedescendant":"vs".concat(this.uid,"__option-").concat(this.typeAheadPointer)}:{}),events:{compositionstart:function(){return t.isComposing=!0},compositionend:function(){return t.isComposing=!1},keydown:this.onSearchKeyDown,blur:this.onSearchBlur,focus:this.onSearchFocus,input:function(e){return t.search=e.target.value}}},spinner:{loading:this.mutableLoading},noOptions:{search:this.search,loading:this.loading,searching:this.searching},openIndicator:{attributes:{ref:"openIndicator",role:"presentation",class:"vs__open-indicator"}},listHeader:e,listFooter:e,header:m({},e,{deselect:this.deselect}),footer:m({},e,{deselect:this.deselect})}},childComponents:function(){return m({},d,{},this.components)},stateClasses:function(){return {"vs--open":this.dropdownOpen,"vs--single":!this.multiple,"vs--searching":this.searching&&!this.noDrop,"vs--searchable":this.searchable&&!this.noDrop,"vs--unsearchable":!this.searchable,"vs--loading":this.mutableLoading,"vs--disabled":this.disabled}},searching:function(){return !!this.search},dropdownOpen:function(){return !this.noDrop&&(this.open&&!this.mutableLoading)},searchPlaceholder:function(){if(this.isValueEmpty&&this.placeholder)return this.placeholder},filteredOptions:function(){var t=[].concat(this.optionList);if(!this.filterable&&!this.taggable)return t;var e=this.search.length?this.filter(t,this.search,this):t;if(this.taggable&&this.search.length){var n=this.createOption(this.search);this.optionExists(n)||e.unshift(n);}return e},isValueEmpty:function(){return 0===this.selectedValue.length},showClearButton:function(){return !this.multiple&&this.clearable&&!this.open&&!this.isValueEmpty}}},O=(n(7),h(_,(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",{staticClass:"v-select",class:t.stateClasses,attrs:{dir:t.dir}},[t._t("header",null,null,t.scope.header),t._v(" "),n("div",{ref:"toggle",staticClass:"vs__dropdown-toggle",attrs:{id:"vs"+t.uid+"__combobox",role:"combobox","aria-expanded":t.dropdownOpen.toString(),"aria-owns":"vs"+t.uid+"__listbox","aria-label":"Search for option"},on:{mousedown:function(e){return t.toggleDropdown(e)}}},[n("div",{ref:"selectedOptions",staticClass:"vs__selected-options"},[t._l(t.selectedValue,(function(e){return t._t("selected-option-container",[n("span",{key:t.getOptionKey(e),staticClass:"vs__selected"},[t._t("selected-option",[t._v("\n            "+t._s(t.getOptionLabel(e))+"\n          ")],null,t.normalizeOptionForSlot(e)),t._v(" "),t.multiple?n("button",{ref:"deselectButtons",refInFor:!0,staticClass:"vs__deselect",attrs:{disabled:t.disabled,type:"button",title:"Deselect "+t.getOptionLabel(e),"aria-label":"Deselect "+t.getOptionLabel(e)},on:{click:function(n){return t.deselect(e)}}},[n(t.childComponents.Deselect,{tag:"component"})],1):t._e()],2)],{option:t.normalizeOptionForSlot(e),deselect:t.deselect,multiple:t.multiple,disabled:t.disabled})})),t._v(" "),t._t("search",[n("input",t._g(t._b({staticClass:"vs__search"},"input",t.scope.search.attributes,!1),t.scope.search.events))],null,t.scope.search)],2),t._v(" "),n("div",{ref:"actions",staticClass:"vs__actions"},[n("button",{directives:[{name:"show",rawName:"v-show",value:t.showClearButton,expression:"showClearButton"}],ref:"clearButton",staticClass:"vs__clear",attrs:{disabled:t.disabled,type:"button",title:"Clear Selected","aria-label":"Clear Selected"},on:{click:t.clearSelection}},[n(t.childComponents.Deselect,{tag:"component"})],1),t._v(" "),t._t("open-indicator",[t.noDrop?t._e():n(t.childComponents.OpenIndicator,t._b({tag:"component"},"component",t.scope.openIndicator.attributes,!1))],null,t.scope.openIndicator),t._v(" "),t._t("spinner",[n("div",{directives:[{name:"show",rawName:"v-show",value:t.mutableLoading,expression:"mutableLoading"}],staticClass:"vs__spinner"},[t._v("Loading...")])],null,t.scope.spinner)],2)]),t._v(" "),n("transition",{attrs:{name:t.transition}},[t.dropdownOpen?n("ul",{directives:[{name:"append-to-body",rawName:"v-append-to-body"}],key:"vs"+t.uid+"__listbox",ref:"dropdownMenu",staticClass:"vs__dropdown-menu",attrs:{id:"vs"+t.uid+"__listbox",role:"listbox",tabindex:"-1"},on:{mousedown:function(e){return e.preventDefault(),t.onMousedown(e)},mouseup:t.onMouseUp}},[t._t("list-header",null,null,t.scope.listHeader),t._v(" "),t._l(t.filteredOptions,(function(e,o){return n("li",{key:t.getOptionKey(e),staticClass:"vs__dropdown-option",class:{"vs__dropdown-option--selected":t.isOptionSelected(e),"vs__dropdown-option--highlight":o===t.typeAheadPointer,"vs__dropdown-option--disabled":!t.selectable(e)},attrs:{role:"option",id:"vs"+t.uid+"__option-"+o,"aria-selected":o===t.typeAheadPointer||null},on:{mouseover:function(n){t.selectable(e)&&(t.typeAheadPointer=o);},mousedown:function(n){n.preventDefault(),n.stopPropagation(),t.selectable(e)&&t.select(e);}}},[t._t("option",[t._v("\n          "+t._s(t.getOptionLabel(e))+"\n        ")],null,t.normalizeOptionForSlot(e))],2)})),t._v(" "),0===t.filteredOptions.length?n("li",{staticClass:"vs__no-options"},[t._t("no-options",[t._v("Sorry, no matching options.")],null,t.scope.noOptions)],2):t._e(),t._v(" "),t._t("list-footer",null,null,t.scope.listFooter)],2):n("ul",{staticStyle:{display:"none",visibility:"hidden"},attrs:{id:"vs"+t.uid+"__listbox",role:"listbox"}})]),t._v(" "),t._t("footer",null,null,t.scope.footer)],2)}),[],!1,null,null,null).exports),w={ajax:p,pointer:u,pointerScroll:c};n.d(e,"VueSelect",(function(){return O})),n.d(e,"mixins",(function(){return w}));e.default=O;}])}));

});

var vSelect = unwrapExports(vueSelect);
vueSelect.VueSelect;

//

var script$6 = {
    components: {
        IMaskComponent,
        vSelect,
        BTooltip
    },
    mounted() {
        this.imaskComponent = this.$refs.vehicleId.maskRef;
    },
    created() {
        this.articles = window.articles;
        this.offenseTypes = window.offenseTypes;
        this.locale = window.locale;
        this.imaskComponent;
        this.mask_opts = {
            mask: [
                {
                    overwrite: true,
                    placeholder: "X 000000",
                    mask: "X 000000",
                    definitions: { X: /[Xx]/ },
                    cls: "vehicle_id--green",
                },
                {
                    overwrite: true,
                    placeholder: "T 000000",
                    mask: "T 000000",
                    definitions: { T: /[Tt]/ },
                    cls: "vehicle_id--green",
                },
                {
                    overwrite: true,
                    placeholder: "D 000000",
                    mask: "D 000000",
                    definitions: { D: /[Dd]/ },
                    cls: "vehicle_id--green",
                },
                {
                    overwrite: true,
                    placeholder: "00 M 000000",
                    mask: "00 M 000000",
                    definitions: { M: /[Mm]/ },
                    cls: "vehicle_id--green",
                },
                {
                    overwrite: true,
                    placeholder: "00 H 000000",
                    mask: "00 H 000000",
                    definitions: { H: /[Hh]/ },
                    cls: "vehicle_id--yellow",
                },
                {
                    overwrite: true,
                    placeholder: "00 000 ##",
                    mask: "00 000 ##",
                    definitions: { "#": /[A-Z]/ },
                    cls: "vehicle_id--flag",
                },
                {
                    overwrite: true,
                    placeholder: "00 000 ###",
                    mask: "00 000 ###",
                    definitions: { "#": /[A-Za-z]/ },
                    cls: "vehicle_id--flag",
                },
                {
                    overwrite: true,
                    placeholder: "00 0000 ##",
                    mask: "00 0000 ##",
                    definitions: { "#": /[A-Za-z]/ },
                    cls: "vehicle_id--flag",
                },
                {
                    overwrite: true,
                    placeholder: "00 # 000 ##",
                    mask: "00 # 000 ##",
                    definitions: { "#": /[A-Za-z]/ },
                    cls: "vehicle_id--flag",
                },
                {
                    overwrite: true,
                    placeholder: "UN 0000",
                    mask: "UN 0000",
                    definitions: { U: /[Uu]/, N: /[Nn]/ },
                    cls: "vehicle_id--blue",
                },
                {
                    overwrite: true,
                    placeholder: "00 0000 ##",
                    mask: "00 0000 ##",
                    definitions: { "#": /[A-Za-z]/ },
                    cls: "vehicle_id--flag",
                },
                {
                    overwrite: true,
                    placeholder: "00 MX 0000",
                    mask: "00 MX 0000",
                    definitions: { M: /[Mm]/, X: /[Xx]/ },
                    cls: "vehicle_id--black",
                },
                {
                    overwrite: true,
                    placeholder: "CMD 0000",
                    mask: "CMD 0000",
                    definitions: { C: /[Cc]/, M: /[Mm]/, D: /[Dd]/ },
                    cls: "vehicle_id--green",
                },
                {
                    overwrite: true,
                    placeholder: "PAA 000",
                    mask: "PAA 000",
                    definitions: { P: /[Pp]/, A: /[Aa]/ },
                    cls: "vehicle_id--spec",
                },
            ],
            prepare: function (str) {
                return str.toUpperCase();
            },
            dispatch: (appended, masked, flags) => {
                const inputValue = masked.rawInputValue;
                const inputs = masked.compiledMasks.map((m, index) => {
                    m.reset();
                    m.append(inputValue, { raw: true });
                    m.append(appended, flags);
                    return {
                        index,
                        weight: m.rawInputValue.length,
                        current: m === masked.currentMask,
                    };
                });

                inputs.sort((i1, i2) => {
                    if (i2.weight === i1.weight) {
                        if (i2.current) return 1;
                        if (i1.current) return -1;
                    }
                    return i2.weight - i1.weight;
                });
                return masked.compiledMasks[inputs[0].index];
            },
        };
    },

    methods: {
        onTypeIdChange(typeId) {
            this.selectedTypeId = typeId;
            this.$emit('typeChange', this.offenseTypes.find((offenseType) => offenseType.id === typeId));
            if (!this.selectedType.show_details) {
                this.$emit('testimonyChange', "");
            }
        },
        vehicleIdAccept(value, mask) {
            this.vehicleClasses = [
                mask.masked.isComplete ? mask.masked.currentMask.cls : "",
            ];
            this.$emit("vehicleIdChange", value.toUpperCase());
            this.$emit("validFlagChange", mask.masked.isComplete);
        },
    },

    data() {
        return {
            vid: "",
            vehicleClasses: [],
            selectedTypeId: ""
        };
    },

    props: {
        typeId: Number,
        testimony: String,
        removable: Boolean,
        valid: Boolean,
        vehicleId: String,
        errors: Object,
        id: String
    },

    computed: {
        selectedType() {
            return this.offenseTypes.find((offenseType) => offenseType.id === this.selectedTypeId)
        },
        plateInputSize() {
            if (!this.vehicleId) {
                return 10;
            } else {
                return this.vehicleId.length;
            }
        },
    },
};

/* script */
const __vue_script__$6 = script$6;

/* template */
var __vue_render__$6 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"border-bottom pb-4"},[_c('div',{staticClass:"row flex-md-nowrap flex-sm-wrap"},[_c('div',{staticClass:"col-lg-3 col-md-4 col-sm-12 vehicle_id-input"},[_c('div',{staticClass:"form-group mb-0",class:{ 'is-invalid': _vm.errors.vehicleId || _vm.errors.valid }},[_c('label',{staticClass:"d-block"},[_vm._v(_vm._s(_vm._f("t")(" ")))]),_vm._v(" "),_c('IMaskComponent',_vm._b({directives:[{name:"autosize",rawName:"v-autosize",value:(_vm.vehicleId),expression:"vehicleId"}],ref:"vehicleId",staticClass:"vehicle_id",class:_vm.vehicleClasses.concat( [{ 'is-invalid': _vm.errors.vehicleId || _vm.errors.valid }] ),attrs:{"value":_vm.vehicleId || _vm.vid,"unmask":false,"placeholder":"00 A 000 AA","type":"text","size":12},on:{"accept":_vm.vehicleIdAccept}},'IMaskComponent',_vm.mask_opts,false)),_vm._v(" "),_c('div',{staticClass:"error invalid-feedback"},[_vm._v("\n          "+_vm._s(_vm.errors.vehicleId || _vm.errors.valid)+"\n        ")])],1)]),_vm._v(" "),(_vm.offenseTypes.length)?_c('div',{staticClass:"col-lg-9 col-md-7 col-sm-12"},[_c('div',{staticClass:"form-group mb-0",class:{ 'is-invalid': _vm.errors.typeId }},[_c('label',[_vm._v(_vm._s(_vm._f("t")(" ")))]),_vm._v(" "),_c('vSelect',{attrs:{"clearable":false,"options":_vm.offenseTypes.map(function (offenseType) { return ({
            value: offenseType.id,
            label:
                offenseType[("name_" + _vm.locale)]
        }); })},on:{"input":function($event){return _vm.onTypeIdChange($event.value)}}}),_vm._v(" "),_c('div',{staticClass:"error invalid-feedback"},[_vm._v(_vm._s(_vm.errors.typeId))])],1)]):_vm._e(),_vm._v(" "),(_vm.removable)?_c('button',{staticClass:"btn btn-outline-danger btn-sm btn-icon btn-circle flex-shrink-0",staticStyle:{"margin":"2.1rem 1rem 0 0"},attrs:{"type":"button"},on:{"click":function($event){return _vm.$emit('remove', _vm.$vnode.key)}}},[_c('i',{staticClass:"la la-remove"})]):_vm._e()]),_vm._v(" "),(_vm.selectedType && _vm.selectedType.show_details)?_c('div',{staticClass:"row"},[_c('div',{staticClass:"col-lg-3 col-md-4 col-sm-12 vehicle_id-input"}),_vm._v(" "),_c('div',{staticClass:"col-lg-9 col-md-7 col-sm-12"},[_c('div',{staticClass:"form-group mb-0",class:{ 'is-invalid': _vm.errors.testimony }},[_c('label',[_vm._v(_vm._s(_vm._f("t")(" ")))]),_vm._v(" "),_c('textarea',{directives:[{name:"autosize",rawName:"v-autosize",value:(_vm.testimony),expression:"testimony"}],staticClass:"form-control",class:{ 'is-invalid': _vm.errors.testimony },attrs:{"placeholder":_vm.t(
            ' ,       .'
        ),"maxlength":"500","required":""},domProps:{"value":_vm.testimony},on:{"input":function($event){return _vm.$emit('testimonyChange', $event.target.value)}}}),_vm._v(" "),_c('div',{staticClass:"error invalid-feedback"},[_vm._v(_vm._s(_vm.errors.testimony))])])])]):_vm._e()])};
var __vue_staticRenderFns__$6 = [];

/* style */
const __vue_inject_styles__$6 = function (inject) {
    if (!inject) return
    inject("data-v-ac8c5bd6_0", { source: "input.vehicle_id{width:fit-content}.form-control.is-invalid:not(.vehicle_id--flag){background-image:none}.vehicle_id-input{margin-bottom:0}@media (max-width:768px){.vehicle_id-input{margin-bottom:1rem}}", map: undefined, media: undefined });

};
/* scoped */
const __vue_scope_id__$6 = undefined;
/* module identifier */
const __vue_module_identifier__$1 = undefined;
/* functional template */
const __vue_is_functional_template__$6 = false;
/* component normalizer */
function __vue_normalize__$6(
    template, style, script,
    scope, functional, moduleIdentifier,
    createInjector, createInjectorSSR
) {
    const component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "offense.vue";

    if (!component.render) {
        component.render = template.render;
        component.staticRenderFns = template.staticRenderFns;
        component._compiled = true;

        if (functional) component.functional = true;
    }

    component._scopeId = scope;

    {
        let hook;
        if (style) {
            hook = function(context) {
                style.call(this, createInjector(context));
            };
        }

        if (hook !== undefined) {
            if (component.functional) {
                // register for functional component in vue file
                const originalRender = component.render;
                component.render = function renderWithStyleInjection(h, context) {
                    hook.call(context);
                    return originalRender(h, context)
                };
            } else {
                // inject component registration as beforeCreate hook
                const existing = component.beforeCreate;
                component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
            }
        }
    }

    return component
}
/* style inject */
function __vue_create_injector__$1() {
    const head = document.head || document.getElementsByTagName('head')[0];
    const styles = __vue_create_injector__$1.styles || (__vue_create_injector__$1.styles = {});
    const isOldIE =
        typeof navigator !== 'undefined' &&
        /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
        if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return // SSR styles are present.

        const group = isOldIE ? css.media || 'default' : id;
        const style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

        if (!style.ids.includes(id)) {
            let code = css.source;
            let index = style.ids.length;

            style.ids.push(id);

            if (css.map) {
                // https://developer.chrome.com/devtools/docs/javascript-debugging
                // this makes source maps inside style tags work properly in Chrome
                code += '\n/*# sourceURL=' + css.map.sources[0] + ' */';
                // http://stackoverflow.com/a/26603875
                code +=
                    '\n/*# sourceMappingURL=data:application/json;base64,' +
                    btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) +
                    ' */';
            }

            if (isOldIE) {
                style.element = style.element || document.querySelector('style[data-group=' + group + ']');
            }

            if (!style.element) {
                const el = style.element = document.createElement('style');
                el.type = 'text/css';

                if (css.media) el.setAttribute('media', css.media);
                if (isOldIE) {
                    el.setAttribute('data-group', group);
                    el.setAttribute('data-next-index', '0');
                }

                head.appendChild(el);
            }

            if (isOldIE) {
                index = parseInt(style.element.getAttribute('data-next-index'));
                style.element.setAttribute('data-next-index', index + 1);
            }

            if (style.element.styleSheet) {
                style.parts.push(code);
                style.element.styleSheet.cssText = style.parts
                    .filter(Boolean)
                    .join('\n');
            } else {
                const textNode = document.createTextNode(code);
                const nodes = style.element.childNodes;
                if (nodes[index]) style.element.removeChild(nodes[index]);
                if (nodes.length) style.element.insertBefore(textNode, nodes[index]);
                else style.element.appendChild(textNode);
            }
        }
    }
}
/* style inject SSR */



var offenseForm = __vue_normalize__$6(
    { render: __vue_render__$6, staticRenderFns: __vue_staticRenderFns__$6 },
    __vue_inject_styles__$6,
    __vue_script__$6,
    __vue_scope_id__$6,
    __vue_is_functional_template__$6,
    __vue_module_identifier__$1,
    __vue_create_injector__$1);

//

var script$5 = {
    components: { offenseForm },
    computed: {
        offenses() {
            return this.$store.state.offenses.list;
        },
    },
    methods: {
        ...mapMutations({
            removeOffense: "offenses/removeOffense",
            updateVehicleId: "offenses/updateVehicleId",
            updateArticleId: "offenses/updateArticleId",
            updateTestimony: "offenses/updateTestimony",
            updateType: "offenses/updateType",
            updateValidFlag: "offenses/updateValidFlag",
            addOffense: "offenses/addOffense",
        }),
    },
};

/* script */
const __vue_script__$5 = script$5;

/* template */
var __vue_render__$5 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('transition-group',{staticClass:"offenses-list",attrs:{"name":"slide"}},_vm._l((_vm.offenses),function(offense,index){return _c('offenseForm',{key:offense.key,staticClass:"mb-4 offense",attrs:{"removable":offense.removable,"vehicleId":offense.vehicleId,"typeId":offense.typeId,"testimony":offense.testimony,"valid":offense.valid,"errors":offense.errors,"id":(index + "_item")},on:{"vehicleIdChange":function($event){return _vm.updateVehicleId({ index: index, vehicleId: $event })},"testimonyChange":function($event){return _vm.updateTestimony({ index: index, testimony: $event })},"articleIdChange":function($event){return _vm.updateArticleId({ index: index, articleId: $event })},"typeChange":function($event){return _vm.updateType({ index: index, type: $event })},"validFlagChange":function($event){return _vm.updateValidFlag({ index: index, valid: $event })},"remove":function($event){return _vm.removeOffense($event)}}})}),1),_vm._v(" "),(_vm.offenses.length < 15)?_c('button',{staticClass:"btn btn btn-primary btn-pill",attrs:{"type":"button"},on:{"click":_vm.addOffense}},[_c('span',[_c('i',{staticClass:"la la-plus"}),_vm._v(" "),_c('span',[_vm._v(_vm._s(_vm._f("t")(" ")))])])]):_vm._e()],1)};
var __vue_staticRenderFns__$5 = [];

/* style */
const __vue_inject_styles__$5 = undefined;
/* scoped */
const __vue_scope_id__$5 = undefined;
/* functional template */
const __vue_is_functional_template__$5 = false;
/* component normalizer */
function __vue_normalize__$5(
    template, style, script,
    scope, functional, moduleIdentifier,
    createInjector, createInjectorSSR
) {
    const component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "Index.vue";

    if (!component.render) {
        component.render = template.render;
        component.staticRenderFns = template.staticRenderFns;
        component._compiled = true;

        if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component
}
/* style inject */

/* style inject SSR */



var OffensesForm = __vue_normalize__$5(
    { render: __vue_render__$5, staticRenderFns: __vue_staticRenderFns__$5 },
    __vue_inject_styles__$5,
    __vue_script__$5,
    __vue_scope_id__$5,
    __vue_is_functional_template__$5);

//
var script$4 = {
    mounted() {
        this.funds = window.funds;
        this.types = window.rewardTypes;
        this.organizations = window.organizations;
        this.phone = window.profile.phone;
    },

    components: { IMaskComponent },
    methods: {
        onAcceptPhone(e, mask) {
            this.phone = e;
            this.phoneValid = mask.masked.isComplete;
        },

        async onAcceptCard(number, mask) {
            let card = {};
            if (mask.masked.isComplete) {
                card = await this.$store.dispatch("reward/sendCardNumber", number);
                card.error = card.error || "";
            } else {
                card.error = t("   ");
            }
            this.card = {
                ...card,
                number,
            };
        },
    },

    computed: {
        bank: {
            get() {
                return this.$store.state.reward.bank;
            },
            set(bank) {
                this.$store.commit("reward/updateBank", bank);
            },
        },

        fund: {
            get() {
                return this.$store.state.reward.fund;
            },
            set(fund) {
                this.$store.commit("reward/updateFund", fund);
            },
        },

        type: {
            get() {
                return this.$store.state.reward.type;
            },
            set(type) {
                this.$store.commit("reward/updateType", type);
            },
        },

        phone: {
            get() {
                return this.$store.state.reward.phone;
            },
            set(phone) {
                this.$store.commit("reward/updatePhone", phone);
            },
        },

        phoneValid: {
            get() {
                return this.$store.state.reward.phoneValid;
            },
            set(valid) {
                this.$store.commit("reward/updatePhoneValidFlag", valid);
            },
        },

        errors() {
            return this.$store.state.reward.errors;
        },
    },
};

/* script */
const __vue_script__$4 = script$4;

/* template */
var __vue_render__$4 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('div',{staticClass:"form-group"},[_c('label',[_vm._v(_vm._s(_vm._f("t")(" ")))]),_vm._v(" "),_c('div',{staticClass:"row"},_vm._l((_vm.types),function(reward,name){return (!reward.hidden)?_c('div',{staticClass:"col-lg-6 mb-2"},[_c('label',{staticClass:"kt-option",class:{ 'position-relative overflow-hidden': reward.unavailable },staticStyle:{"min-height":"9.25rem"}},[(reward.unavailable)?_c('div',{staticClass:"ribbon"},[_vm._v("\n            "+_vm._s(_vm._f("t")(""))+"\n          ")]):_vm._e(),_vm._v(" "),_c('span',{staticClass:"kt-option__control"},[_c('span',{staticClass:"kt-radio kt-radio--check-bold"},[_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.type),expression:"type"}],attrs:{"disabled":reward.unavailable,"required":"","type":"radio"},domProps:{"value":name,"checked":_vm._q(_vm.type,name)},on:{"change":function($event){_vm.type=name;}}}),_vm._v(" "),_c('span')])]),_vm._v(" "),_c('span',{staticClass:"kt-option__label"},[_c('span',{staticClass:"kt-option__head"},[_c('span',{staticClass:"kt-option__title"},[_vm._v(_vm._s(_vm._f("t")(reward.name)))])]),_vm._v(" "),_c('span',{staticClass:"kt-option__body d-flex justify-content-start"},[_c('span',{staticClass:"mr-2 reward-icon"},[_vm._v(_vm._s(reward.icon))]),_vm._v(" "),_c('span',[_vm._v(_vm._s(_vm._f("t")(reward.description)))])])])])]):_vm._e()}),0)]),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.type === 'phone'),expression:"type === 'phone'"}],staticClass:"row"},[_c('div',{staticClass:"col-md-6"},[_c('div',{staticClass:"form-group"},[_c('label',[_vm._v(_vm._s(_vm._f("t")("    ")))]),_vm._v(" "),_c('IMaskComponent',_vm._b({staticClass:"form-control",class:[{ 'is-invalid': _vm.errors.phone || _vm.errors.phoneValid }],attrs:{"value":_vm.phone,"type":"text"},on:{"accept":_vm.onAcceptPhone}},'IMaskComponent',{ mask: '+\\9\\9\\8 00 000 00 00' },false)),_vm._v(" "),_c('div',{staticClass:"error invalid-feedback"},[_vm._v("\n          "+_vm._s(_vm.errors.phone || _vm.errors.phoneValid)+"\n        ")])],1)])]),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.type === 'fund'),expression:"type === 'fund'"}],staticClass:"row"},[_c('div',{staticClass:"col-md-6"},[_c('div',{staticClass:"form-group"},[_c('label',[_vm._v(_vm._s(_vm._f("t")(" ")))]),_vm._v(" "),_c('select',{directives:[{name:"model",rawName:"v-model",value:(_vm.fund),expression:"fund"}],staticClass:"form-control",class:[{ 'is-invalid': _vm.errors.fund }],on:{"change":function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.fund=$event.target.multiple ? $$selectedVal : $$selectedVal[0];}}},[_c('option'),_vm._v(" "),_vm._l((_vm.funds),function(_,fundName){return _c('option',{domProps:{"value":fundName}},[_vm._v("\n            "+_vm._s(_vm._f("t")(fundName))+"\n          ")])})],2),_vm._v(" "),_c('div',{staticClass:"error invalid-feedback"},[_vm._v(_vm._s(_vm.errors.fund))]),_vm._v(" "),_c('div',{staticClass:"mt-2"},[_c('span',[_vm._v(_vm._s(_vm._f("t")("   "))+":")]),_vm._v(" "),_c('ul',_vm._l((_vm.funds),function(fundUrl,fundName){return _c('li',[_c('a',{class:{ 'selected-fund-item': _vm.fund === fundName },attrs:{"target":"_blank","href":fundUrl}},[_vm._v(_vm._s(_vm._f("t")(fundName)))])])}),0)])])])]),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.type === 'bank'),expression:"type === 'bank'"}],staticClass:"row"},[_c('div',{staticClass:"col-md-6"},[_c('div',{staticClass:"form-group"},[_c('label',[_vm._v(_vm._s(_vm._f("t")("")))]),_vm._v(" "),_c('select',{directives:[{name:"model",rawName:"v-model",value:(_vm.bank),expression:"bank"}],staticClass:"form-control",class:[{ 'is-invalid': _vm.errors.bank }],on:{"change":function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.bank=$event.target.multiple ? $$selectedVal : $$selectedVal[0];}}},_vm._l((_vm.organizations),function(organization){return _c('option',{domProps:{"value":organization.bank_account}},[_vm._v("\n            "+_vm._s(organization.name)+" - "+_vm._s(organization.bank_account)+"\n          ")])}),0),_vm._v(" "),_c('div',{staticClass:"error invalid-feedback"},[_vm._v(_vm._s(_vm.errors.bank))])])])]),_vm._v(" "),_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.type === 'card'),expression:"type === 'card'"}],staticClass:"row",staticStyle:{"display":"none"}},[_c('div',{staticClass:"col-md-12"},[_c('div',{staticClass:"form-group"},[_c('p',[_vm._v(_vm._s(_vm._f("t")("     ,   .          ,     . ,          .")))])])])])])};
var __vue_staticRenderFns__$4 = [];

/* style */
const __vue_inject_styles__$4 = undefined;
/* scoped */
const __vue_scope_id__$4 = undefined;
/* functional template */
const __vue_is_functional_template__$4 = false;
/* component normalizer */
function __vue_normalize__$4(
    template, style, script,
    scope, functional, moduleIdentifier,
    createInjector, createInjectorSSR
) {
    const component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "Index.vue";

    if (!component.render) {
        component.render = template.render;
        component.staticRenderFns = template.staticRenderFns;
        component._compiled = true;

        if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component
}
/* style inject */

/* style inject SSR */



var RewardForm = __vue_normalize__$4(
    { render: __vue_render__$4, staticRenderFns: __vue_staticRenderFns__$4 },
    __vue_inject_styles__$4,
    __vue_script__$4,
    __vue_scope_id__$4,
    __vue_is_functional_template__$4);

//
//
//
//
//

var script$3 = {
    props: {
        text: String,
        warn: String
    }
};

/* script */
const __vue_script__$3 = script$3;

/* template */
var __vue_render__$3 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return (_vm.warn)?_c('span',{staticClass:"kt-font-danger"},[_vm._v(_vm._s(_vm.warn))]):(_vm.text)?_c('span',{staticClass:"kt-font-info"},[_vm._v(_vm._s(_vm.text))]):_c('span',{staticClass:"kt-font-danger"},[_vm._v(_vm._s(_vm._f("t")(" ")))])};
var __vue_staticRenderFns__$3 = [];

/* style */
const __vue_inject_styles__$3 = undefined;
/* scoped */
const __vue_scope_id__$3 = undefined;
/* functional template */
const __vue_is_functional_template__$3 = false;
/* component normalizer */
function __vue_normalize__$3(
    template, style, script,
    scope, functional, moduleIdentifier,
    createInjector, createInjectorSSR
) {
    const component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "info.vue";

    if (!component.render) {
        component.render = template.render;
        component.staticRenderFns = template.staticRenderFns;
        component._compiled = true;

        if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component
}
/* style inject */

/* style inject SSR */



var Info = __vue_normalize__$3(
    { render: __vue_render__$3, staticRenderFns: __vue_staticRenderFns__$3 },
    __vue_inject_styles__$3,
    __vue_script__$3,
    __vue_scope_id__$3,
    __vue_is_functional_template__$3);

//

var script$2 = {
    components: {Info},
    props: {
        width: Number,
        height: Number,
        filename: String,
        duration: Number,
        filesize: Number,
        error: String
    },
    computed: {
        resolution() {
            const width = this.width;
            const height = this.height;
            return width && height && `${width} x ${height}`
        },
        durationStr() {
            if (!!this.duration)
                return t(`%d `, this.duration)
        }

    }
};

/* script */
const __vue_script__$2 = script$2;

/* template */
var __vue_render__$2 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_vm._v("\n  "+_vm._s(_vm._f("t")(" "))+":\n  "),_c('Info',{attrs:{"text":_vm.filename}}),_vm._v(" "),_c('br'),_vm._v("\n  "+_vm._s(_vm._f("t")(""))+":\n  "),_c('Info',{attrs:{"text":_vm._f("humanFileSize")(_vm.filesize)}}),_vm._v(" "),(_vm.error)?_c('div',[_vm._v("\n    "+_vm._s(_vm._f("t")(""))+":\n    "),_c('Info',{attrs:{"warn":_vm.error}})],1):_vm._e()],1)};
var __vue_staticRenderFns__$2 = [];

/* style */
const __vue_inject_styles__$2 = undefined;
/* scoped */
const __vue_scope_id__$2 = undefined;
/* functional template */
const __vue_is_functional_template__$2 = false;
/* component normalizer */
function __vue_normalize__$2(
    template, style, script,
    scope, functional, moduleIdentifier,
    createInjector, createInjectorSSR
) {
    const component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "videoInfo.vue";

    if (!component.render) {
        component.render = template.render;
        component.staticRenderFns = template.staticRenderFns;
        component._compiled = true;

        if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component
}
/* style inject */

/* style inject SSR */



var VideoInfo = __vue_normalize__$2(
    { render: __vue_render__$2, staticRenderFns: __vue_staticRenderFns__$2 },
    __vue_inject_styles__$2,
    __vue_script__$2,
    __vue_scope_id__$2,
    __vue_is_functional_template__$2);

function _isPlaceholder(a) {
    return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
}

/**
 * Optimized internal one-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */

function _curry1(fn) {
    return function f1(a) {
        if (arguments.length === 0 || _isPlaceholder(a)) {
            return f1;
        } else {
            return fn.apply(this, arguments);
        }
    };
}

/**
 * Optimized internal two-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */

function _curry2(fn) {
    return function f2(a, b) {
        switch (arguments.length) {
            case 0:
                return f2;

            case 1:
                return _isPlaceholder(a) ? f2 : _curry1(function (_b) {
                    return fn(a, _b);
                });

            default:
                return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {
                    return fn(_a, b);
                }) : _isPlaceholder(b) ? _curry1(function (_b) {
                    return fn(a, _b);
                }) : fn(a, b);
        }
    };
}

function _arity(n, fn) {
    /* eslint-disable no-unused-vars */
    switch (n) {
        case 0:
            return function () {
                return fn.apply(this, arguments);
            };

        case 1:
            return function (a0) {
                return fn.apply(this, arguments);
            };

        case 2:
            return function (a0, a1) {
                return fn.apply(this, arguments);
            };

        case 3:
            return function (a0, a1, a2) {
                return fn.apply(this, arguments);
            };

        case 4:
            return function (a0, a1, a2, a3) {
                return fn.apply(this, arguments);
            };

        case 5:
            return function (a0, a1, a2, a3, a4) {
                return fn.apply(this, arguments);
            };

        case 6:
            return function (a0, a1, a2, a3, a4, a5) {
                return fn.apply(this, arguments);
            };

        case 7:
            return function (a0, a1, a2, a3, a4, a5, a6) {
                return fn.apply(this, arguments);
            };

        case 8:
            return function (a0, a1, a2, a3, a4, a5, a6, a7) {
                return fn.apply(this, arguments);
            };

        case 9:
            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
                return fn.apply(this, arguments);
            };

        case 10:
            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
                return fn.apply(this, arguments);
            };

        default:
            throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
    }
}

/**
 * Internal curryN function.
 *
 * @private
 * @category Function
 * @param {Number} length The arity of the curried function.
 * @param {Array} received An array of arguments received thus far.
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */

function _curryN(length, received, fn) {
    return function () {
        var combined = [];
        var argsIdx = 0;
        var left = length;
        var combinedIdx = 0;

        while (combinedIdx < received.length || argsIdx < arguments.length) {
            var result;

            if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
                result = received[combinedIdx];
            } else {
                result = arguments[argsIdx];
                argsIdx += 1;
            }

            combined[combinedIdx] = result;

            if (!_isPlaceholder(result)) {
                left -= 1;
            }

            combinedIdx += 1;
        }

        return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
    };
}

/**
 * Tests whether or not an object is an array.
 *
 * @private
 * @param {*} val The object to test.
 * @return {Boolean} `true` if `val` is an array, `false` otherwise.
 * @example
 *
 *      _isArray([]); //=> true
 *      _isArray(null); //=> false
 *      _isArray({}); //=> false
 */
var _isArray = Array.isArray || function _isArray(val) {
    return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
};

function _isTransformer(obj) {
    return obj != null && typeof obj['@@transducer/step'] === 'function';
}

/**
 * Returns a function that dispatches with different strategies based on the
 * object in list position (last argument). If it is an array, executes [fn].
 * Otherwise, if it has a function with one of the given method names, it will
 * execute that function (functor case). Otherwise, if it is a transformer,
 * uses transducer [xf] to return a new transformer (transducer case).
 * Otherwise, it will default to executing [fn].
 *
 * @private
 * @param {Array} methodNames properties to check for a custom implementation
 * @param {Function} xf transducer to initialize if object is transformer
 * @param {Function} fn default ramda implementation
 * @return {Function} A function that dispatches on object in list position
 */

function _dispatchable(methodNames, xf, fn) {
    return function () {
        if (arguments.length === 0) {
            return fn();
        }

        var args = Array.prototype.slice.call(arguments, 0);
        var obj = args.pop();

        if (!_isArray(obj)) {
            var idx = 0;

            while (idx < methodNames.length) {
                if (typeof obj[methodNames[idx]] === 'function') {
                    return obj[methodNames[idx]].apply(obj, args);
                }

                idx += 1;
            }

            if (_isTransformer(obj)) {
                var transducer = xf.apply(null, args);
                return transducer(obj);
            }
        }

        return fn.apply(this, arguments);
    };
}

var _xfBase = {
    init: function () {
        return this.xf['@@transducer/init']();
    },
    result: function (result) {
        return this.xf['@@transducer/result'](result);
    }
};

function _isString(x) {
    return Object.prototype.toString.call(x) === '[object String]';
}

/**
 * Tests whether or not an object is similar to an array.
 *
 * @private
 * @category Type
 * @category List
 * @sig * -> Boolean
 * @param {*} x The object to test.
 * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
 * @example
 *
 *      _isArrayLike([]); //=> true
 *      _isArrayLike(true); //=> false
 *      _isArrayLike({}); //=> false
 *      _isArrayLike({length: 10}); //=> false
 *      _isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
 */

var _isArrayLike =
    /*#__PURE__*/
    _curry1(function isArrayLike(x) {
        if (_isArray(x)) {
            return true;
        }

        if (!x) {
            return false;
        }

        if (typeof x !== 'object') {
            return false;
        }

        if (_isString(x)) {
            return false;
        }

        if (x.nodeType === 1) {
            return !!x.length;
        }

        if (x.length === 0) {
            return true;
        }

        if (x.length > 0) {
            return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
        }

        return false;
    });

var XWrap =
    /*#__PURE__*/
    function () {
        function XWrap(fn) {
            this.f = fn;
        }

        XWrap.prototype['@@transducer/init'] = function () {
            throw new Error('init not implemented on XWrap');
        };

        XWrap.prototype['@@transducer/result'] = function (acc) {
            return acc;
        };

        XWrap.prototype['@@transducer/step'] = function (acc, x) {
            return this.f(acc, x);
        };

        return XWrap;
    }();

function _xwrap(fn) {
    return new XWrap(fn);
}

/**
 * Creates a function that is bound to a context.
 * Note: `R.bind` does not provide the additional argument-binding capabilities of
 * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
 *
 * @func
 * @memberOf R
 * @since v0.6.0
 * @category Function
 * @category Object
 * @sig (* -> *) -> {*} -> (* -> *)
 * @param {Function} fn The function to bind to context
 * @param {Object} thisObj The context to bind `fn` to
 * @return {Function} A function that will execute in the context of `thisObj`.
 * @see R.partial
 * @example
 *
 *      const log = R.bind(console.log, console);
 *      R.pipe(R.assoc('a', 2), R.tap(log), R.assoc('a', 3))({a: 1}); //=> {a: 3}
 *      // logs {a: 2}
 * @symb R.bind(f, o)(a, b) = f.call(o, a, b)
 */

var bind =
    /*#__PURE__*/
    _curry2(function bind(fn, thisObj) {
        return _arity(fn.length, function () {
            return fn.apply(thisObj, arguments);
        });
    });

function _arrayReduce(xf, acc, list) {
    var idx = 0;
    var len = list.length;

    while (idx < len) {
        acc = xf['@@transducer/step'](acc, list[idx]);

        if (acc && acc['@@transducer/reduced']) {
            acc = acc['@@transducer/value'];
            break;
        }

        idx += 1;
    }

    return xf['@@transducer/result'](acc);
}

function _iterableReduce(xf, acc, iter) {
    var step = iter.next();

    while (!step.done) {
        acc = xf['@@transducer/step'](acc, step.value);

        if (acc && acc['@@transducer/reduced']) {
            acc = acc['@@transducer/value'];
            break;
        }

        step = iter.next();
    }

    return xf['@@transducer/result'](acc);
}

function _methodReduce(xf, acc, obj, methodName) {
    return xf['@@transducer/result'](obj[methodName](bind(xf['@@transducer/step'], xf), acc));
}

var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
function _reduce(fn, acc, list) {
    if (typeof fn === 'function') {
        fn = _xwrap(fn);
    }

    if (_isArrayLike(list)) {
        return _arrayReduce(fn, acc, list);
    }

    if (typeof list['fantasy-land/reduce'] === 'function') {
        return _methodReduce(fn, acc, list, 'fantasy-land/reduce');
    }

    if (list[symIterator] != null) {
        return _iterableReduce(fn, acc, list[symIterator]());
    }

    if (typeof list.next === 'function') {
        return _iterableReduce(fn, acc, list);
    }

    if (typeof list.reduce === 'function') {
        return _methodReduce(fn, acc, list, 'reduce');
    }

    throw new TypeError('reduce: list must be array or iterable');
}

function _has(prop, obj) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}

/**
 * Determine if the passed argument is an integer.
 *
 * @private
 * @param {*} n
 * @category Type
 * @return {Boolean}
 */
var _isInteger = Number.isInteger || function _isInteger(n) {
    return n << 0 === n;
};

/**
 * Returns the nth element of the given list or string. If n is negative the
 * element at index length + n is returned.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Number -> [a] -> a | Undefined
 * @sig Number -> String -> String
 * @param {Number} offset
 * @param {*} list
 * @return {*}
 * @example
 *
 *      const list = ['foo', 'bar', 'baz', 'quux'];
 *      R.nth(1, list); //=> 'bar'
 *      R.nth(-1, list); //=> 'quux'
 *      R.nth(-99, list); //=> undefined
 *
 *      R.nth(2, 'abc'); //=> 'c'
 *      R.nth(3, 'abc'); //=> ''
 * @symb R.nth(-1, [a, b, c]) = c
 * @symb R.nth(0, [a, b, c]) = a
 * @symb R.nth(1, [a, b, c]) = b
 */

var nth =
    /*#__PURE__*/
    _curry2(function nth(offset, list) {
        var idx = offset < 0 ? list.length + offset : offset;
        return _isString(list) ? list.charAt(idx) : list[idx];
    });

/**
 * Retrieves the values at given paths of an object.
 *
 * @func
 * @memberOf R
 * @since v0.27.1
 * @category Object
 * @typedefn Idx = [String | Int]
 * @sig [Idx] -> {a} -> [a | Undefined]
 * @param {Array} pathsArray The array of paths to be fetched.
 * @param {Object} obj The object to retrieve the nested properties from.
 * @return {Array} A list consisting of values at paths specified by "pathsArray".
 * @see R.path
 * @example
 *
 *      R.paths([['a', 'b'], ['p', 0, 'q']], {a: {b: 2}, p: [{q: 3}]}); //=> [2, 3]
 *      R.paths([['a', 'b'], ['p', 'r']], {a: {b: 2}, p: [{q: 3}]}); //=> [2, undefined]
 */

var paths =
    /*#__PURE__*/
    _curry2(function paths(pathsArray, obj) {
        return pathsArray.map(function (paths) {
            var val = obj;
            var idx = 0;
            var p;

            while (idx < paths.length) {
                if (val == null) {
                    return;
                }

                p = paths[idx];
                val = _isInteger(p) ? nth(p, val) : val[p];
                idx += 1;
            }

            return val;
        });
    });

/**
 * Retrieve the value at a given path.
 *
 * @func
 * @memberOf R
 * @since v0.2.0
 * @category Object
 * @typedefn Idx = String | Int
 * @sig [Idx] -> {a} -> a | Undefined
 * @param {Array} path The path to use.
 * @param {Object} obj The object to retrieve the nested property from.
 * @return {*} The data at `path`.
 * @see R.prop, R.nth
 * @example
 *
 *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2
 *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined
 *      R.path(['a', 'b', 0], {a: {b: [1, 2, 3]}}); //=> 1
 *      R.path(['a', 'b', -2], {a: {b: [1, 2, 3]}}); //=> 2
 */

var path =
    /*#__PURE__*/
    _curry2(function path(pathAr, obj) {
        return paths([pathAr], obj)[0];
    });

/**
 * Returns a function that when supplied an object returns the indicated
 * property of that object, if it exists.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @typedefn Idx = String | Int
 * @sig Idx -> {s: a} -> a | Undefined
 * @param {String|Number} p The property name or array index
 * @param {Object} obj The object to query
 * @return {*} The value at `obj.p`.
 * @see R.path, R.nth
 * @example
 *
 *      R.prop('x', {x: 100}); //=> 100
 *      R.prop('x', {}); //=> undefined
 *      R.prop(0, [100]); //=> 100
 *      R.compose(R.inc, R.prop('x'))({ x: 3 }) //=> 4
 */

var prop =
    /*#__PURE__*/
    _curry2(function prop(p, obj) {
        return path([p], obj);
    });

function _cloneRegExp(pattern) {
    return new RegExp(pattern.source, (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : ''));
}

/**
 * Gives a single-word string description of the (native) type of a value,
 * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not
 * attempt to distinguish user Object types any further, reporting them all as
 * 'Object'.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Type
 * @sig (* -> {*}) -> String
 * @param {*} val The value to test
 * @return {String}
 * @example
 *
 *      R.type({}); //=> "Object"
 *      R.type(1); //=> "Number"
 *      R.type(false); //=> "Boolean"
 *      R.type('s'); //=> "String"
 *      R.type(null); //=> "Null"
 *      R.type([]); //=> "Array"
 *      R.type(/[A-z]/); //=> "RegExp"
 *      R.type(() => {}); //=> "Function"
 *      R.type(undefined); //=> "Undefined"
 */

var type =
    /*#__PURE__*/
    _curry1(function type(val) {
        return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
    });

/**
 * Copies an object.
 *
 * @private
 * @param {*} value The value to be copied
 * @param {Array} refFrom Array containing the source references
 * @param {Array} refTo Array containing the copied source references
 * @param {Boolean} deep Whether or not to perform deep cloning.
 * @return {*} The copied value.
 */

function _clone(value, refFrom, refTo, deep) {
    var copy = function copy(copiedValue) {
        var len = refFrom.length;
        var idx = 0;

        while (idx < len) {
            if (value === refFrom[idx]) {
                return refTo[idx];
            }

            idx += 1;
        }

        refFrom[idx + 1] = value;
        refTo[idx + 1] = copiedValue;

        for (var key in value) {
            copiedValue[key] = deep ? _clone(value[key], refFrom, refTo, true) : value[key];
        }

        return copiedValue;
    };

    switch (type(value)) {
        case 'Object':
            return copy({});

        case 'Array':
            return copy([]);

        case 'Date':
            return new Date(value.valueOf());

        case 'RegExp':
            return _cloneRegExp(value);

        default:
            return value;
    }
}

var XReduceBy =
    /*#__PURE__*/
    function () {
        function XReduceBy(valueFn, valueAcc, keyFn, xf) {
            this.valueFn = valueFn;
            this.valueAcc = valueAcc;
            this.keyFn = keyFn;
            this.xf = xf;
            this.inputs = {};
        }

        XReduceBy.prototype['@@transducer/init'] = _xfBase.init;

        XReduceBy.prototype['@@transducer/result'] = function (result) {
            var key;

            for (key in this.inputs) {
                if (_has(key, this.inputs)) {
                    result = this.xf['@@transducer/step'](result, this.inputs[key]);

                    if (result['@@transducer/reduced']) {
                        result = result['@@transducer/value'];
                        break;
                    }
                }
            }

            this.inputs = null;
            return this.xf['@@transducer/result'](result);
        };

        XReduceBy.prototype['@@transducer/step'] = function (result, input) {
            var key = this.keyFn(input);
            this.inputs[key] = this.inputs[key] || [key, this.valueAcc];
            this.inputs[key][1] = this.valueFn(this.inputs[key][1], input);
            return result;
        };

        return XReduceBy;
    }();

var _xreduceBy =
    /*#__PURE__*/
    _curryN(4, [], function _xreduceBy(valueFn, valueAcc, keyFn, xf) {
        return new XReduceBy(valueFn, valueAcc, keyFn, xf);
    });

/**
 * Groups the elements of the list according to the result of calling
 * the String-returning function `keyFn` on each element and reduces the elements
 * of each group to a single value via the reducer function `valueFn`.
 *
 * This function is basically a more general [`groupBy`](#groupBy) function.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.20.0
 * @category List
 * @sig ((a, b) -> a) -> a -> (b -> String) -> [b] -> {String: a}
 * @param {Function} valueFn The function that reduces the elements of each group to a single
 *        value. Receives two values, accumulator for a particular group and the current element.
 * @param {*} acc The (initial) accumulator value for each group.
 * @param {Function} keyFn The function that maps the list's element into a key.
 * @param {Array} list The array to group.
 * @return {Object} An object with the output of `keyFn` for keys, mapped to the output of
 *         `valueFn` for elements which produced that key when passed to `keyFn`.
 * @see R.groupBy, R.reduce
 * @example
 *
 *      const groupNames = (acc, {name}) => acc.concat(name)
 *      const toGrade = ({score}) =>
 *        score < 65 ? 'F' :
 *        score < 70 ? 'D' :
 *        score < 80 ? 'C' :
 *        score < 90 ? 'B' : 'A'
 *
 *      var students = [
 *        {name: 'Abby', score: 83},
 *        {name: 'Bart', score: 62},
 *        {name: 'Curt', score: 88},
 *        {name: 'Dora', score: 92},
 *      ]
 *
 *      reduceBy(groupNames, [], toGrade, students)
 *      //=> {"A": ["Dora"], "B": ["Abby", "Curt"], "F": ["Bart"]}
 */

var reduceBy =
    /*#__PURE__*/
    _curryN(4, [],
        /*#__PURE__*/
        _dispatchable([], _xreduceBy, function reduceBy(valueFn, valueAcc, keyFn, list) {
            return _reduce(function (acc, elt) {
                var key = keyFn(elt);
                acc[key] = valueFn(_has(key, acc) ? acc[key] : _clone(valueAcc, [], [], false), elt);
                return acc;
            }, {}, list);
        }));

/**
 * Given a function that generates a key, turns a list of objects into an
 * object indexing the objects by the given key. Note that if multiple
 * objects generate the same value for the indexing key only the last value
 * will be included in the generated object.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig (a -> String) -> [{k: v}] -> {k: {k: v}}
 * @param {Function} fn Function :: a -> String
 * @param {Array} array The array of objects to index
 * @return {Object} An object indexing each array element by the given property.
 * @example
 *
 *      const list = [{id: 'xyz', title: 'A'}, {id: 'abc', title: 'B'}];
 *      R.indexBy(R.prop('id'), list);
 *      //=> {abc: {id: 'abc', title: 'B'}, xyz: {id: 'xyz', title: 'A'}}
 */

var indexBy =
    /*#__PURE__*/
    reduceBy(function (acc, elem) {
        return elem;
    }, null);

//

var script$1 = {
    components: { VideoInfo, Info },
    created() {
        this.articles = indexBy(prop("id"), window.articles);
        this.offenseTypes = indexBy(prop("id"), window.offenseTypes);
        this.locale = window.locale;
    },
    computed: {
        withExtraVideo: function () {
            return this.$store.state.withExtraVideo;
        },
        video() {
            return {
                ...this.$store.state.video,
                size: this.$store.getters["video/size"],
                name: this.$store.getters["video/name"],
            };
        },
        extraVideo() {
            return {
                ...this.$store.state.extraVideo,
                size: this.$store.getters["extraVideo/size"],
                name: this.$store.getters["extraVideo/name"],
            };
        },
        details() {
            return {
                ...this.$store.state.details,
                address: this.$store.getters["details/yAddress"],
                errorCount: this.$store.getters["details/errorCount"],
            };
        },
        offenses() {
            return this.$store.state.offenses.list;
        },

        reward() {
            return this.$store.state.reward;
        },
    },
};

/* script */
const __vue_script__$1 = script$1;

/* template */
var __vue_render__$1 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('div',{staticClass:"kt-wizard-v3__review"},[_c('div',{staticClass:"kt-wizard-v3__review-item"},[_c('div',{staticClass:"kt-wizard-v3__review-title"},[_vm._v("\n        "+_vm._s(_vm._f("t")(" "))+"\n      ")]),_vm._v(" "),_c('div',{staticClass:"kt-wizard-v3__review-content"},[_c('VideoInfo',_vm._b({},'VideoInfo',_vm.video,false))],1)]),_vm._v(" "),(_vm.withExtraVideo)?_c('div',{staticClass:"kt-wizard-v3__review-item"},[_c('div',{staticClass:"kt-wizard-v3__review-title"},[_vm._v("\n        "+_vm._s(_vm._f("t")("  "))+"\n      ")]),_vm._v(" "),_c('div',{staticClass:"kt-wizard-v3__review-content"},[_c('VideoInfo',_vm._b({},'VideoInfo',_vm.extraVideo,false))],1)]):_vm._e(),_vm._v(" "),_c('div',{staticClass:"kt-wizard-v3__review-item"},[_c('div',{staticClass:"kt-wizard-v3__review-title"},[_vm._v("\n        "+_vm._s(_vm._f("t")(" "))+"\n      ")]),_vm._v(" "),_c('div',{staticClass:"kt-wizard-v3__review-content"},[_vm._v("\n        "+_vm._s(_vm._f("t")(" "))+":\n        "),_c('Info',{attrs:{"text":_vm.details && _vm.details.address,"warn":_vm.details.errors.address ||
            _vm.details.errors.area ||
            _vm.details.errors.district}}),_vm._v(" "),_c('br'),_vm._v("\n        "+_vm._s(_vm._f("t")(""))+":\n        "),_c('Info',{attrs:{"text":_vm.details && ((_vm.details.coords[1]) + ", " + (_vm.details.coords[0])),"warn":_vm.details.errors.coords}}),_vm._v(" "),_c('br'),_vm._v("\n        "+_vm._s(_vm._f("t")(""))+":\n        "),_c('Info',{attrs:{"text":_vm.details && _vm.details.time,"warn":_vm.details.errors.time}}),_vm._v(" "),_c('br')],1)]),_vm._v(" "),_c('div',{staticClass:"kt-wizard-v3__review-item"},[_c('div',{staticClass:"kt-wizard-v3__review-title"},[_vm._v("\n        "+_vm._s(_vm._f("t")(""))+"\n      ")]),_vm._v(" "),_c('div',{staticClass:"kt-wizard-v3__review-content"},[_c('ul',{attrs:{"id":"review-offenses"}},_vm._l((_vm.offenses),function(offense){return _c('li',{key:offense.key},[_c('Info',{attrs:{"text":offense.vehicleId,"warn":offense.errors.vehicleId || offense.errors.valid}}),_vm._v(_vm._s(!offense.typeId ? "," : "")+"\n            "),_c('Info',{attrs:{"text":_vm.offenseTypes[offense.typeId]? _vm.offenseTypes[offense.typeId][("name_" + (_vm.locale||'ru'))]: null,"warn":offense.errors.typeId}}),_vm._v(_vm._s(!offense.testimony ? "," : "")+"\n            "),(offense.testimony)?_c('Info',{attrs:{"text":offense.testimony,"warn":offense.errors.testimony}}):_vm._e(),_vm._v(_vm._s(offense.citizenArticleId ? "," : "")+"\n            "),(offense.citizenArticleId)?_c('Info',{attrs:{"text":_vm.articles[offense.citizenArticleId] &&
            _vm.articles[offense.citizenArticleId][("alias_" + _vm.locale)]}}):_vm._e()],1)}),0)])]),_vm._v(" "),_c('div',{staticClass:"kt-wizard-v3__review-item"},[_c('div',{staticClass:"kt-wizard-v3__review-title"},[_vm._v("\n        "+_vm._s(_vm._f("t")(""))+"\n      ")]),_vm._v(" "),(_vm.reward.type === 'phone')?_c('div',{staticClass:"kt-wizard-v3__review-content"},[_vm._v("\n        "+_vm._s(_vm._f("t")("  "))+":\n        "),_c('Info',{attrs:{"text":_vm.reward.phone,"warn":_vm.reward.errors.phone || _vm.reward.errors.phoneValid}}),_vm._v(" "),_c('br')],1):(_vm.reward.type === 'card')?_c('div',{staticClass:"kt-wizard-v3__review-content"},[_vm._v("\n        "+_vm._s(_vm._f("t")("  "))+":\n        "),_c('Info',{attrs:{"text":_vm._f("t")('    '),"warn":_vm.reward.errors.card}}),_vm._v(" "),_c('br')],1):(_vm.reward.type === 'fund')?_c('div',{staticClass:"kt-wizard-v3__review-content"},[_vm._v("\n        "+_vm._s(_vm._f("t")("  "))+":\n        "),_c('Info',{attrs:{"text":_vm.reward.fund,"warn":_vm.reward.errors.fund}}),_vm._v(" "),_c('br')],1):(_vm.reward.type === 'bank')?_c('div',{staticClass:"kt-wizard-v3__review-content"},[_vm._v("\n        "+_vm._s(_vm._f("t")(" "))+":\n        "),_c('Info',{attrs:{"text":_vm.reward.bank,"warn":_vm.reward.errors.bank}}),_vm._v(" "),_c('br')],1):(_vm.reward.type === 'no-reward')?_c('div',{staticClass:"kt-wizard-v3__review-content"},[_vm._v("\n        "+_vm._s(_vm._f("t")(" "))+"\n        "),_c('br')]):_c('div',{staticClass:"kt-wizard-v3__review-content"},[_c('Info'),_vm._v(" "),_c('br')],1)])])])};
var __vue_staticRenderFns__$1 = [];

/* style */
const __vue_inject_styles__$1 = undefined;
/* scoped */
const __vue_scope_id__$1 = undefined;
/* functional template */
const __vue_is_functional_template__$1 = false;
/* component normalizer */
function __vue_normalize__$1(
    template, style, script,
    scope, functional, moduleIdentifier,
    createInjector, createInjectorSSR
) {
    const component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "Index.vue";

    if (!component.render) {
        component.render = template.render;
        component.staticRenderFns = template.staticRenderFns;
        component._compiled = true;

        if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component
}
/* style inject */

/* style inject SSR */



var Review = __vue_normalize__$1(
    { render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 },
    __vue_inject_styles__$1,
    __vue_script__$1,
    __vue_scope_id__$1,
    __vue_is_functional_template__$1);

//

const steps = ['offenses', 'details', 'reward', 'review'];
var script = {
    components: {VideoUploadForm, OffensesForm, RewardForm, Review, DetailsForm},
    mounted() {
        new KTWizard("wizard", {startStep: 1}).on('change',
            (e) => {
                if (this.currentTab !== 'offenses') {
                    this.$store.dispatch(this.currentTab + '/validate');
                } else if (this.currentTab !== 'review') {
                    this.$store.dispatch(this.currentTab + '/validateList');
                }
                this.currentTab = steps[e.getStep() - 1];
            });
    },
    computed: {
        ...mapGetters({
            errorCount: 'errorCount',
            detailsErrorCount: 'details/errorCount',
            offensesErrorCount: 'offenses/errorCount',
            rewardErrorCount: 'reward/errorCount'
        }),
    },

    data() {
        return {
            hasVideoInputted: false,
            currentTab: 'offenses',
            date: moment().format("DD.MM.YYYY")
        }
    },

    methods: {}
};

/* script */
const __vue_script__ = script;

/* template */
var __vue_render__ = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('VideoUploadForm'),_vm._v(" "),_c('div',{staticClass:"kt-portlet mt-4"},[_c('div',{staticClass:"kt-portlet__body kt-portlet__body--fit"},[_c('div',{staticClass:"kt-grid kt-wizard-v3 kt-wizard-v3--white",attrs:{"data-ktwizard-state":"first","id":"wizard"}},[_c('div',{staticClass:"kt-grid__item"},[_c('div',{staticClass:"kt-wizard-v3__nav"},[_c('div',{staticClass:"kt-wizard-v3__nav-items row justify-content-center"},[_c('a',{staticClass:"kt-wizard-v3__nav-item col-sm-12 col-lg-3",attrs:{"data-ktwizard-state":"current","data-ktwizard-type":"step","href":"#d"}},[_c('div',{staticClass:"kt-wizard-v3__nav-body"},[_c('div',{staticClass:"kt-wizard-v3__nav-label"},[_c('span',{staticClass:"step-number"},[_vm._v("1")]),_vm._v(" "),_c('span',[_vm._v(_vm._s(_vm._f("t")("")))]),_vm._v(" "),(_vm.offensesErrorCount!==0)?_c('i',{staticClass:"fa fa-exclamation-triangle btn-font-danger ml-2"}):_vm._e()]),_vm._v(" "),_c('div',{staticClass:"kt-wizard-v3__nav-bar"})])]),_vm._v(" "),_c('a',{staticClass:"kt-wizard-v3__nav-item col-sm-12 col-lg-3",attrs:{"data-ktwizard-state":"pending","data-ktwizard-type":"step"}},[_c('div',{staticClass:"kt-wizard-v3__nav-body"},[_c('div',{staticClass:"kt-wizard-v3__nav-label"},[_c('span',{staticClass:"step-number"},[_vm._v("2")]),_vm._v(" "),_c('span',[_vm._v("\n                      "+_vm._s(_vm._f("t")("  "))+"\n                    ")]),_vm._v(" "),(_vm.detailsErrorCount!==0)?_c('i',{staticClass:"fa fa-exclamation-triangle btn-font-danger ml-2"}):_vm._e()]),_vm._v(" "),_c('div',{staticClass:"kt-wizard-v3__nav-bar"})])]),_vm._v(" "),_c('a',{staticClass:"kt-wizard-v3__nav-item col-sm-12 col-lg-3",attrs:{"data-ktwizard-state":"pending","data-ktwizard-type":"step","href":"#d"}},[_c('div',{staticClass:"kt-wizard-v3__nav-body"},[_c('div',{staticClass:"kt-wizard-v3__nav-label"},[_c('span',{staticClass:"step-number"},[_vm._v("3")]),_vm._v(" "),_c('span',[_vm._v(_vm._s(_vm._f("t")("")))]),_vm._v(" "),(_vm.rewardErrorCount!==0)?_c('i',{staticClass:"fa fa-exclamation-triangle btn-font-danger ml-2"}):_vm._e()]),_vm._v(" "),_c('div',{staticClass:"kt-wizard-v3__nav-bar"})])]),_vm._v(" "),_c('a',{staticClass:"kt-wizard-v3__nav-item col-sm-12 col-lg-3",attrs:{"data-ktwizard-state":"pending","data-ktwizard-type":"step","href":"#d"}},[_c('div',{staticClass:"kt-wizard-v3__nav-body"},[_c('div',{staticClass:"kt-wizard-v3__nav-label"},[_c('span',{staticClass:"step-number"},[_vm._v("4")]),_vm._v(" "),_c('span',[_vm._v(_vm._s(_vm._f("t")("")))])]),_vm._v(" "),_c('div',{staticClass:"kt-wizard-v3__nav-bar"})])])])])]),_vm._v(" "),_c('div',{staticClass:"kt-grid__item kt-grid__item--fluid kt-wizard-v3__wrapper pt-0"},[_c('form',{staticClass:"kt-form pt-3",attrs:{"id":"kt_form","novalidate":"novalidate"}},[_c('div',{staticClass:"kt-wizard-v3__content",attrs:{"data-ktwizard-state":"current","data-ktwizard-type":"step-content"}},[_c('div',{staticClass:"kt-heading kt-heading--md"},[_vm._v("\n                "+_vm._s(_vm._f("t")("  "))+"\n              ")]),_vm._v(" "),_c('div',{staticClass:"kt-form__section kt-form__section--first"},[_c('div',{staticClass:"kt-wizard-v3__form"},[_c('OffensesForm')],1)])]),_vm._v(" "),_c('div',{staticClass:"kt-wizard-v3__content",attrs:{"data-ktwizard-type":"step-content"}},[_c('div',{staticClass:"kt-heading kt-heading--md"},[_vm._v("\n                "+_vm._s(('    '))+"\n              ")]),_vm._v(" "),_c('div',{staticClass:"kt-form__section kt-form__section--first"},[_c('div',{staticClass:"kt-wizard-v3__form"},[_c('div',{staticClass:"kt-wizard-v1__form"},[_c('DetailsForm')],1)])])]),_vm._v(" "),_c('div',{staticClass:"kt-wizard-v3__content",attrs:{"data-ktwizard-type":"step-content"}},[_c('div',{staticClass:"kt-heading kt-heading--md"},[_vm._v(" "+_vm._s(_vm._f("t")("   ")))]),_vm._v(" "),_c('RewardForm')],1),_vm._v(" "),_c('div',{staticClass:"kt-wizard-v3__content",attrs:{"data-ktwizard-type":"step-content"}},[_c('div',{staticClass:"kt-heading kt-heading--md"},[_vm._v("\n                "+_vm._s(_vm._f("t")("    "))+"\n              ")]),_vm._v(" "),_c('div',{staticClass:"kt-form__section kt-form__section--first"},[_c('Review')],1)]),_vm._v(" "),_c('div',{staticClass:"kt-form__actions"},[_c('div',{staticClass:"btn btn-secondary btn-md btn-tall btn-wide kt-font-bold\n                        kt-font-transform-u",attrs:{"data-ktwizard-type":"action-prev"}},[_vm._v("\n                "+_vm._s(_vm._f("t")(""))+"\n              ")]),_vm._v(" "),_c('button',{staticClass:"btn btn-success btn-md btn-tall btn-wide kt-font-bold\n                        kt-font-transform-u",attrs:{"data-ktwizard-type":"action-submit","type":"button"},on:{"click":function($event){return _vm.$store.dispatch('sendReport')}}},[_vm._v("\n                "+_vm._s(_vm._f("t")(""))+"\n              ")]),_vm._v(" "),_c('div',{staticClass:"btn btn-brand btn-md btn-tall btn-wide kt-font-bold\n                        kt-font-transform-u",attrs:{"data-ktwizard-type":"action-next"}},[_vm._v("\n                "+_vm._s(_vm._f("t")(""))+"\n              ")])])])])])])])],1)};
var __vue_staticRenderFns__ = [];

/* style */
const __vue_inject_styles__ = function (inject) {
    if (!inject) return
    inject("data-v-576133de_0", { source: ".is-valid .valid-feedback{display:inline-block}.is-invalid .invalid-feedback{display:inline-block}.kt-badge{font-size:.8rem!important;padding:.65rem .45rem}.nav-link{padding-top:.6rem!important;padding-bottom:.5rem!important}@-webkit-keyframes fadeInUp{from{opacity:0;-webkit-transform:translate3d(0,100%,0);transform:translate3d(0,100%,0)}to{opacity:1;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}}@keyframes fadeInUp{from{opacity:0;-webkit-transform:translate3d(0,100%,0);transform:translate3d(0,100%,0)}to{opacity:1;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}}.fadeInUp{-webkit-animation-name:fadeInUp;animation-name:fadeInUp}@-webkit-keyframes fadeOut{from{opacity:1}to{opacity:0}}@keyframes fadeOut{from{opacity:1}to{opacity:0}}.fadeOut{-webkit-animation-name:fadeOut;animation-name:fadeOut}.animated{-webkit-animation-duration:1s;animation-duration:1s;-webkit-animation-fill-mode:both;animation-fill-mode:both}.offenses-list{overflow-y:hidden}.slide-enter-to,.slide-leave-active{height:75px;opacity:1;transition:all .5s}.slide-enter{transition:all .5s;opacity:0;height:0;margin-bottom:0!important}.slide-leave-to{opacity:0;height:0;margin-bottom:0!important}", map: undefined, media: undefined });

};
/* scoped */
const __vue_scope_id__ = undefined;
/* module identifier */
const __vue_module_identifier__ = undefined;
/* functional template */
const __vue_is_functional_template__ = false;
/* component normalizer */
function __vue_normalize__(
    template, style, script,
    scope, functional, moduleIdentifier,
    createInjector, createInjectorSSR
) {
    const component = (typeof script === 'function' ? script.options : script) || {};

    // For security concerns, we use only base name in production mode.
    component.__file = "Form.vue";

    if (!component.render) {
        component.render = template.render;
        component.staticRenderFns = template.staticRenderFns;
        component._compiled = true;

        if (functional) component.functional = true;
    }

    component._scopeId = scope;

    {
        let hook;
        if (style) {
            hook = function(context) {
                style.call(this, createInjector(context));
            };
        }

        if (hook !== undefined) {
            if (component.functional) {
                // register for functional component in vue file
                const originalRender = component.render;
                component.render = function renderWithStyleInjection(h, context) {
                    hook.call(context);
                    return originalRender(h, context)
                };
            } else {
                // inject component registration as beforeCreate hook
                const existing = component.beforeCreate;
                component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
            }
        }
    }

    return component
}
/* style inject */
function __vue_create_injector__() {
    const head = document.head || document.getElementsByTagName('head')[0];
    const styles = __vue_create_injector__.styles || (__vue_create_injector__.styles = {});
    const isOldIE =
        typeof navigator !== 'undefined' &&
        /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

    return function addStyle(id, css) {
        if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return // SSR styles are present.

        const group = isOldIE ? css.media || 'default' : id;
        const style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });

        if (!style.ids.includes(id)) {
            let code = css.source;
            let index = style.ids.length;

            style.ids.push(id);

            if (css.map) {
                // https://developer.chrome.com/devtools/docs/javascript-debugging
                // this makes source maps inside style tags work properly in Chrome
                code += '\n/*# sourceURL=' + css.map.sources[0] + ' */';
                // http://stackoverflow.com/a/26603875
                code +=
                    '\n/*# sourceMappingURL=data:application/json;base64,' +
                    btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) +
                    ' */';
            }

            if (isOldIE) {
                style.element = style.element || document.querySelector('style[data-group=' + group + ']');
            }

            if (!style.element) {
                const el = style.element = document.createElement('style');
                el.type = 'text/css';

                if (css.media) el.setAttribute('media', css.media);
                if (isOldIE) {
                    el.setAttribute('data-group', group);
                    el.setAttribute('data-next-index', '0');
                }

                head.appendChild(el);
            }

            if (isOldIE) {
                index = parseInt(style.element.getAttribute('data-next-index'));
                style.element.setAttribute('data-next-index', index + 1);
            }

            if (style.element.styleSheet) {
                style.parts.push(code);
                style.element.styleSheet.cssText = style.parts
                    .filter(Boolean)
                    .join('\n');
            } else {
                const textNode = document.createTextNode(code);
                const nodes = style.element.childNodes;
                if (nodes[index]) style.element.removeChild(nodes[index]);
                if (nodes.length) style.element.insertBefore(textNode, nodes[index]);
                else style.element.appendChild(textNode);
            }
        }
    }
}
/* style inject SSR */



var App = __vue_normalize__(
    { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
    __vue_inject_styles__,
    __vue_script__,
    __vue_scope_id__,
    __vue_is_functional_template__,
    __vue_module_identifier__,
    __vue_create_injector__);

var joiBrowser = createCommonjsModule(function (module, exports) {
    (function webpackUniversalModuleDefinition(root, factory) {
        module.exports = factory();
    })(commonjsGlobal, function() {
        return /******/ (function(modules) { // webpackBootstrap
            /******/ 	// The module cache
            /******/ 	var installedModules = {};
            /******/
            /******/ 	// The require function
            /******/ 	function __webpack_require__(moduleId) {
                /******/
                /******/ 		// Check if module is in cache
                /******/ 		if(installedModules[moduleId]) {
                    /******/ 			return installedModules[moduleId].exports;
                    /******/ 		}
                /******/ 		// Create a new module (and put it into the cache)
                /******/ 		var module = installedModules[moduleId] = {
                    /******/ 			i: moduleId,
                    /******/ 			l: false,
                    /******/ 			exports: {}
                    /******/ 		};
                /******/
                /******/ 		// Execute the module function
                /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
                /******/
                /******/ 		// Flag the module as loaded
                /******/ 		module.l = true;
                /******/
                /******/ 		// Return the exports of the module
                /******/ 		return module.exports;
                /******/ 	}
            /******/
            /******/
            /******/ 	// expose the modules object (__webpack_modules__)
            /******/ 	__webpack_require__.m = modules;
            /******/
            /******/ 	// expose the module cache
            /******/ 	__webpack_require__.c = installedModules;
            /******/
            /******/ 	// identity function for calling harmony imports with the correct context
            /******/ 	__webpack_require__.i = function(value) { return value; };
            /******/
            /******/ 	// define getter function for harmony exports
            /******/ 	__webpack_require__.d = function(exports, name, getter) {
                /******/ 		if(!__webpack_require__.o(exports, name)) {
                    /******/ 			Object.defineProperty(exports, name, {
                        /******/ 				configurable: false,
                        /******/ 				enumerable: true,
                        /******/ 				get: getter
                        /******/ 			});
                    /******/ 		}
                /******/ 	};
            /******/
            /******/ 	// getDefaultExport function for compatibility with non-harmony modules
            /******/ 	__webpack_require__.n = function(module) {
                /******/ 		var getter = module && module.__esModule ?
                    /******/ 			function getDefault() { return module['default']; } :
                    /******/ 			function getModuleExports() { return module; };
                /******/ 		__webpack_require__.d(getter, 'a', getter);
                /******/ 		return getter;
                /******/ 	};
            /******/
            /******/ 	// Object.prototype.hasOwnProperty.call
            /******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
            /******/
            /******/ 	// __webpack_public_path__
            /******/ 	__webpack_require__.p = "";
            /******/
            /******/ 	// Load entry module and return exports
            /******/ 	return __webpack_require__(__webpack_require__.s = 32);
            /******/ })
            /************************************************************************/
            /******/ ([
                /* 0 */
                /***/ (function(module, exports, __webpack_require__) {
                    /* WEBPACK VAR INJECTION */(function(Buffer, process) {

// Load modules

                        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

                        var Assert = __webpack_require__(17);
                        var Crypto = __webpack_require__(15);
                        var Path = __webpack_require__(37);
                        var Util = __webpack_require__(16);

                        var Escape = __webpack_require__(18);

// Declare internals

                        var internals = {};

// Clone object or array

                        exports.clone = function (obj, seen) {

                            if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' || obj === null) {

                                return obj;
                            }

                            seen = seen || new Map();

                            var lookup = seen.get(obj);
                            if (lookup) {
                                return lookup;
                            }

                            var newObj = void 0;
                            var cloneDeep = false;

                            if (!Array.isArray(obj)) {
                                if (Buffer.isBuffer(obj)) {
                                    newObj = Buffer.from(obj);
                                } else if (obj instanceof Date) {
                                    newObj = new Date(obj.getTime());
                                } else if (obj instanceof RegExp) {
                                    newObj = new RegExp(obj);
                                } else {
                                    var proto = Object.getPrototypeOf(obj);
                                    if (proto && proto.isImmutable) {

                                        newObj = obj;
                                    } else {
                                        newObj = Object.create(proto);
                                        cloneDeep = true;
                                    }
                                }
                            } else {
                                newObj = [];
                                cloneDeep = true;
                            }

                            seen.set(obj, newObj);

                            if (cloneDeep) {
                                var keys = Object.getOwnPropertyNames(obj);
                                for (var i = 0; i < keys.length; ++i) {
                                    var key = keys[i];
                                    var descriptor = Object.getOwnPropertyDescriptor(obj, key);
                                    if (descriptor && (descriptor.get || descriptor.set)) {

                                        Object.defineProperty(newObj, key, descriptor);
                                    } else {
                                        newObj[key] = exports.clone(obj[key], seen);
                                    }
                                }
                            }

                            return newObj;
                        };

// Merge all the properties of source into target, source wins in conflict, and by default null and undefined from source are applied

                        /*eslint-disable */
                        exports.merge = function (target, source, isNullOverride /* = true */, isMergeArrays /* = true */) {
                            /*eslint-enable */

                            exports.assert(target && (typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object', 'Invalid target value: must be an object');
                            exports.assert(source === null || source === undefined || (typeof source === 'undefined' ? 'undefined' : _typeof(source)) === 'object', 'Invalid source value: must be null, undefined, or an object');

                            if (!source) {
                                return target;
                            }

                            if (Array.isArray(source)) {
                                exports.assert(Array.isArray(target), 'Cannot merge array onto an object');
                                if (isMergeArrays === false) {
                                    // isMergeArrays defaults to true
                                    target.length = 0; // Must not change target assignment
                                }

                                for (var i = 0; i < source.length; ++i) {
                                    target.push(exports.clone(source[i]));
                                }

                                return target;
                            }

                            var keys = Object.keys(source);
                            for (var _i = 0; _i < keys.length; ++_i) {
                                var key = keys[_i];
                                if (key === '__proto__') {
                                    continue;
                                }

                                var value = source[key];
                                if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {

                                    if (!target[key] || _typeof(target[key]) !== 'object' || Array.isArray(target[key]) !== Array.isArray(value) || value instanceof Date || Buffer.isBuffer(value) || value instanceof RegExp) {

                                        target[key] = exports.clone(value);
                                    } else {
                                        exports.merge(target[key], value, isNullOverride, isMergeArrays);
                                    }
                                } else {
                                    if (value !== null && value !== undefined) {
                                        // Explicit to preserve empty strings

                                        target[key] = value;
                                    } else if (isNullOverride !== false) {
                                        // Defaults to true
                                        target[key] = value;
                                    }
                                }
                            }

                            return target;
                        };

// Apply options to a copy of the defaults

                        exports.applyToDefaults = function (defaults, options, isNullOverride) {

                            exports.assert(defaults && (typeof defaults === 'undefined' ? 'undefined' : _typeof(defaults)) === 'object', 'Invalid defaults value: must be an object');
                            exports.assert(!options || options === true || (typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object', 'Invalid options value: must be true, falsy or an object');

                            if (!options) {
                                // If no options, return null
                                return null;
                            }

                            var copy = exports.clone(defaults);

                            if (options === true) {
                                // If options is set to true, use defaults
                                return copy;
                            }

                            return exports.merge(copy, options, isNullOverride === true, false);
                        };

// Clone an object except for the listed keys which are shallow copied

                        exports.cloneWithShallow = function (source, keys) {

                            if (!source || (typeof source === 'undefined' ? 'undefined' : _typeof(source)) !== 'object') {

                                return source;
                            }

                            var storage = internals.store(source, keys); // Move shallow copy items to storage
                            var copy = exports.clone(source); // Deep copy the rest
                            internals.restore(copy, source, storage); // Shallow copy the stored items and restore
                            return copy;
                        };

                        internals.store = function (source, keys) {

                            var storage = {};
                            for (var i = 0; i < keys.length; ++i) {
                                var key = keys[i];
                                var value = exports.reach(source, key);
                                if (value !== undefined) {
                                    storage[key] = value;
                                    internals.reachSet(source, key, undefined);
                                }
                            }

                            return storage;
                        };

                        internals.restore = function (copy, source, storage) {

                            var keys = Object.keys(storage);
                            for (var i = 0; i < keys.length; ++i) {
                                var key = keys[i];
                                internals.reachSet(copy, key, storage[key]);
                                internals.reachSet(source, key, storage[key]);
                            }
                        };

                        internals.reachSet = function (obj, key, value) {

                            var path = key.split('.');
                            var ref = obj;
                            for (var i = 0; i < path.length; ++i) {
                                var segment = path[i];
                                if (i + 1 === path.length) {
                                    ref[segment] = value;
                                }

                                ref = ref[segment];
                            }
                        };

// Apply options to defaults except for the listed keys which are shallow copied from option without merging

                        exports.applyToDefaultsWithShallow = function (defaults, options, keys) {

                            exports.assert(defaults && (typeof defaults === 'undefined' ? 'undefined' : _typeof(defaults)) === 'object', 'Invalid defaults value: must be an object');
                            exports.assert(!options || options === true || (typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object', 'Invalid options value: must be true, falsy or an object');
                            exports.assert(keys && Array.isArray(keys), 'Invalid keys');

                            if (!options) {
                                // If no options, return null
                                return null;
                            }

                            var copy = exports.cloneWithShallow(defaults, keys);

                            if (options === true) {
                                // If options is set to true, use defaults
                                return copy;
                            }

                            var storage = internals.store(options, keys); // Move shallow copy items to storage
                            exports.merge(copy, options, false, false); // Deep copy the rest
                            internals.restore(copy, options, storage); // Shallow copy the stored items and restore
                            return copy;
                        };

// Deep object or array comparison

                        exports.deepEqual = function (obj, ref, options, seen) {

                            options = options || { prototype: true };

                            var type = typeof obj === 'undefined' ? 'undefined' : _typeof(obj);

                            if (type !== (typeof ref === 'undefined' ? 'undefined' : _typeof(ref))) {
                                return false;
                            }

                            if (type !== 'object' || obj === null || ref === null) {

                                if (obj === ref) {
                                    // Copied from Deep-eql, copyright(c) 2013 Jake Luer, jake@alogicalparadox.com, MIT Licensed, https://github.com/chaijs/deep-eql
                                    return obj !== 0 || 1 / obj === 1 / ref; // -0 / +0
                                }

                                return obj !== obj && ref !== ref; // NaN
                            }

                            seen = seen || [];
                            if (seen.indexOf(obj) !== -1) {
                                return true; // If previous comparison failed, it would have stopped execution
                            }

                            seen.push(obj);

                            if (Array.isArray(obj)) {
                                if (!Array.isArray(ref)) {
                                    return false;
                                }

                                if (!options.part && obj.length !== ref.length) {
                                    return false;
                                }

                                for (var i = 0; i < obj.length; ++i) {
                                    if (options.part) {
                                        var found = false;
                                        for (var j = 0; j < ref.length; ++j) {
                                            if (exports.deepEqual(obj[i], ref[j], options)) {
                                                found = true;
                                                break;
                                            }
                                        }

                                        return found;
                                    }

                                    if (!exports.deepEqual(obj[i], ref[i], options)) {
                                        return false;
                                    }
                                }

                                return true;
                            }

                            if (Buffer.isBuffer(obj)) {
                                if (!Buffer.isBuffer(ref)) {
                                    return false;
                                }

                                if (obj.length !== ref.length) {
                                    return false;
                                }

                                for (var _i2 = 0; _i2 < obj.length; ++_i2) {
                                    if (obj[_i2] !== ref[_i2]) {
                                        return false;
                                    }
                                }

                                return true;
                            }

                            if (obj instanceof Date) {
                                return ref instanceof Date && obj.getTime() === ref.getTime();
                            }

                            if (obj instanceof RegExp) {
                                return ref instanceof RegExp && obj.toString() === ref.toString();
                            }

                            if (options.prototype) {
                                if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {
                                    return false;
                                }
                            }

                            var keys = Object.getOwnPropertyNames(obj);

                            if (!options.part && keys.length !== Object.getOwnPropertyNames(ref).length) {
                                return false;
                            }

                            for (var _i3 = 0; _i3 < keys.length; ++_i3) {
                                var key = keys[_i3];
                                var descriptor = Object.getOwnPropertyDescriptor(obj, key);
                                if (descriptor.get) {
                                    if (!exports.deepEqual(descriptor, Object.getOwnPropertyDescriptor(ref, key), options, seen)) {
                                        return false;
                                    }
                                } else if (!exports.deepEqual(obj[key], ref[key], options, seen)) {
                                    return false;
                                }
                            }

                            return true;
                        };

// Remove duplicate items from array

                        exports.unique = function (array, key) {

                            var result = void 0;
                            if (key) {
                                result = [];
                                var index = new Set();
                                array.forEach(function (item) {

                                    var identifier = item[key];
                                    if (!index.has(identifier)) {
                                        index.add(identifier);
                                        result.push(item);
                                    }
                                });
                            } else {
                                result = Array.from(new Set(array));
                            }

                            return result;
                        };

// Convert array into object

                        exports.mapToObject = function (array, key) {

                            if (!array) {
                                return null;
                            }

                            var obj = {};
                            for (var i = 0; i < array.length; ++i) {
                                if (key) {
                                    if (array[i][key]) {
                                        obj[array[i][key]] = true;
                                    }
                                } else {
                                    obj[array[i]] = true;
                                }
                            }

                            return obj;
                        };

// Find the common unique items in two arrays

                        exports.intersect = function (array1, array2, justFirst) {

                            if (!array1 || !array2) {
                                return [];
                            }

                            var common = [];
                            var hash = Array.isArray(array1) ? exports.mapToObject(array1) : array1;
                            var found = {};
                            for (var i = 0; i < array2.length; ++i) {
                                if (hash[array2[i]] && !found[array2[i]]) {
                                    if (justFirst) {
                                        return array2[i];
                                    }

                                    common.push(array2[i]);
                                    found[array2[i]] = true;
                                }
                            }

                            return justFirst ? null : common;
                        };

// Test if the reference contains the values

                        exports.contain = function (ref, values, options) {

                            /*
        string -> string(s)
        array -> item(s)
        object -> key(s)
        object -> object (key:value)
    */

                            var valuePairs = null;
                            if ((typeof ref === 'undefined' ? 'undefined' : _typeof(ref)) === 'object' && (typeof values === 'undefined' ? 'undefined' : _typeof(values)) === 'object' && !Array.isArray(ref) && !Array.isArray(values)) {

                                valuePairs = values;
                                values = Object.keys(values);
                            } else {
                                values = [].concat(values);
                            }

                            options = options || {}; // deep, once, only, part

                            exports.assert(typeof ref === 'string' || (typeof ref === 'undefined' ? 'undefined' : _typeof(ref)) === 'object', 'Reference must be string or an object');
                            exports.assert(values.length, 'Values array cannot be empty');

                            var compare = void 0;
                            var compareFlags = void 0;
                            if (options.deep) {
                                compare = exports.deepEqual;

                                var hasOnly = options.hasOwnProperty('only');
                                var hasPart = options.hasOwnProperty('part');

                                compareFlags = {
                                    prototype: hasOnly ? options.only : hasPart ? !options.part : false,
                                    part: hasOnly ? !options.only : hasPart ? options.part : true
                                };
                            } else {
                                compare = function compare(a, b) {
                                    return a === b;
                                };
                            }

                            var misses = false;
                            var matches = new Array(values.length);
                            for (var i = 0; i < matches.length; ++i) {
                                matches[i] = 0;
                            }

                            if (typeof ref === 'string') {
                                var pattern = '(';
                                for (var _i4 = 0; _i4 < values.length; ++_i4) {
                                    var value = values[_i4];
                                    exports.assert(typeof value === 'string', 'Cannot compare string reference to non-string value');
                                    pattern += (_i4 ? '|' : '') + exports.escapeRegex(value);
                                }

                                var regex = new RegExp(pattern + ')', 'g');
                                var leftovers = ref.replace(regex, function ($0, $1) {

                                    var index = values.indexOf($1);
                                    ++matches[index];
                                    return ''; // Remove from string
                                });

                                misses = !!leftovers;
                            } else if (Array.isArray(ref)) {
                                for (var _i5 = 0; _i5 < ref.length; ++_i5) {
                                    var matched = false;
                                    for (var j = 0; j < values.length && matched === false; ++j) {
                                        matched = compare(values[j], ref[_i5], compareFlags) && j;
                                    }

                                    if (matched !== false) {
                                        ++matches[matched];
                                    } else {
                                        misses = true;
                                    }
                                }
                            } else {
                                var keys = Object.getOwnPropertyNames(ref);
                                for (var _i6 = 0; _i6 < keys.length; ++_i6) {
                                    var key = keys[_i6];
                                    var pos = values.indexOf(key);
                                    if (pos !== -1) {
                                        if (valuePairs && !compare(valuePairs[key], ref[key], compareFlags)) {

                                            return false;
                                        }

                                        ++matches[pos];
                                    } else {
                                        misses = true;
                                    }
                                }
                            }

                            var result = false;
                            for (var _i7 = 0; _i7 < matches.length; ++_i7) {
                                result = result || !!matches[_i7];
                                if (options.once && matches[_i7] > 1 || !options.part && !matches[_i7]) {

                                    return false;
                                }
                            }

                            if (options.only && misses) {

                                return false;
                            }

                            return result;
                        };

// Flatten array

                        exports.flatten = function (array, target) {

                            var result = target || [];

                            for (var i = 0; i < array.length; ++i) {
                                if (Array.isArray(array[i])) {
                                    exports.flatten(array[i], result);
                                } else {
                                    result.push(array[i]);
                                }
                            }

                            return result;
                        };

// Convert an object key chain string ('a.b.c') to reference (object[a][b][c])

                        exports.reach = function (obj, chain, options) {

                            if (chain === false || chain === null || typeof chain === 'undefined') {

                                return obj;
                            }

                            options = options || {};
                            if (typeof options === 'string') {
                                options = { separator: options };
                            }

                            var path = chain.split(options.separator || '.');
                            var ref = obj;
                            for (var i = 0; i < path.length; ++i) {
                                var key = path[i];
                                if (key[0] === '-' && Array.isArray(ref)) {
                                    key = key.slice(1, key.length);
                                    key = ref.length - key;
                                }

                                if (!ref || !(((typeof ref === 'undefined' ? 'undefined' : _typeof(ref)) === 'object' || typeof ref === 'function') && key in ref) || (typeof ref === 'undefined' ? 'undefined' : _typeof(ref)) !== 'object' && options.functions === false) {
                                    // Only object and function can have properties

                                    exports.assert(!options.strict || i + 1 === path.length, 'Missing segment', key, 'in reach path ', chain);
                                    exports.assert((typeof ref === 'undefined' ? 'undefined' : _typeof(ref)) === 'object' || options.functions === true || typeof ref !== 'function', 'Invalid segment', key, 'in reach path ', chain);
                                    ref = options.default;
                                    break;
                                }

                                ref = ref[key];
                            }

                            return ref;
                        };

                        exports.reachTemplate = function (obj, template, options) {

                            return template.replace(/{([^}]+)}/g, function ($0, chain) {

                                var value = exports.reach(obj, chain, options);
                                return value === undefined || value === null ? '' : value;
                            });
                        };

                        exports.formatStack = function (stack) {

                            var trace = [];
                            for (var i = 0; i < stack.length; ++i) {
                                var item = stack[i];
                                trace.push([item.getFileName(), item.getLineNumber(), item.getColumnNumber(), item.getFunctionName(), item.isConstructor()]);
                            }

                            return trace;
                        };

                        exports.formatTrace = function (trace) {

                            var display = [];

                            for (var i = 0; i < trace.length; ++i) {
                                var row = trace[i];
                                display.push((row[4] ? 'new ' : '') + row[3] + ' (' + row[0] + ':' + row[1] + ':' + row[2] + ')');
                            }

                            return display;
                        };

                        exports.callStack = function (slice) {

                            // http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi

                            var v8 = Error.prepareStackTrace;
                            Error.prepareStackTrace = function (_, stack) {

                                return stack;
                            };

                            var capture = {};
                            Error.captureStackTrace(capture, this);
                            var stack = capture.stack;

                            Error.prepareStackTrace = v8;

                            var trace = exports.formatStack(stack);

                            return trace.slice(1 + slice);
                        };

                        exports.displayStack = function (slice) {

                            var trace = exports.callStack(slice === undefined ? 1 : slice + 1);

                            return exports.formatTrace(trace);
                        };

                        exports.abortThrow = false;

                        exports.abort = function (message, hideStack) {

                            if (exports.abortThrow === true) {
                                throw new Error(message || 'Unknown error');
                            }

                            var stack = '';
                            if (!hideStack) {
                                stack = exports.displayStack(1).join('\n\t');
                            }
                            console.log('ABORT: ' + message + '\n\t' + stack);
                            process.exit(1);
                        };

                        exports.assert = function (condition) {

                            if (condition) {
                                return;
                            }

                            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                                args[_key - 1] = arguments[_key];
                            }

                            if (args.length === 1 && args[0] instanceof Error) {
                                throw args[0];
                            }

                            var msgs = args.filter(function (arg) {
                                return arg !== '';
                            }).map(function (arg) {

                                return typeof arg === 'string' ? arg : arg instanceof Error ? arg.message : exports.stringify(arg);
                            });

                            throw new Assert.AssertionError({
                                message: msgs.join(' ') || 'Unknown error',
                                actual: false,
                                expected: true,
                                operator: '==',
                                stackStartFunction: exports.assert
                            });
                        };

                        exports.Bench = function () {

                            this.ts = 0;
                            this.reset();
                        };

                        exports.Bench.prototype.reset = function () {

                            this.ts = exports.Bench.now();
                        };

                        exports.Bench.prototype.elapsed = function () {

                            return exports.Bench.now() - this.ts;
                        };

                        exports.Bench.now = function () {

                            var ts = process.hrtime();
                            return ts[0] * 1e3 + ts[1] / 1e6;
                        };

// Escape string for Regex construction

                        exports.escapeRegex = function (string) {

                            // Escape ^$.*+-?=!:|\/()[]{},
                            return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, '\\$&');
                        };

// Base64url (RFC 4648) encode

                        exports.base64urlEncode = function (value, encoding) {

                            exports.assert(typeof value === 'string' || Buffer.isBuffer(value), 'value must be string or buffer');
                            var buf = Buffer.isBuffer(value) ? value : Buffer.from(value, encoding || 'binary');
                            return buf.toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
                        };

// Base64url (RFC 4648) decode

                        exports.base64urlDecode = function (value, encoding) {

                            if (typeof value !== 'string') {

                                throw new Error('Value not a string');
                            }

                            if (!/^[\w\-]*$/.test(value)) {

                                throw new Error('Invalid character');
                            }

                            var buf = Buffer.from(value, 'base64');
                            return encoding === 'buffer' ? buf : buf.toString(encoding || 'binary');
                        };

// Escape attribute value for use in HTTP header

                        exports.escapeHeaderAttribute = function (attribute) {

                            // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \, "

                            exports.assert(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/.test(attribute), 'Bad attribute value (' + attribute + ')');

                            return attribute.replace(/\\/g, '\\\\').replace(/\"/g, '\\"'); // Escape quotes and slash
                        };

                        exports.escapeHtml = function (string) {

                            return Escape.escapeHtml(string);
                        };

                        exports.escapeJavaScript = function (string) {

                            return Escape.escapeJavaScript(string);
                        };

                        exports.escapeJson = function (string) {

                            return Escape.escapeJson(string);
                        };

                        exports.once = function (method) {

                            if (method._hoekOnce) {
                                return method;
                            }

                            var once = false;
                            var wrapped = function wrapped() {

                                if (!once) {
                                    once = true;

                                    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                                        args[_key2] = arguments[_key2];
                                    }

                                    method.apply(null, args);
                                }
                            };

                            wrapped._hoekOnce = true;
                            return wrapped;
                        };

                        exports.isInteger = Number.isSafeInteger;

                        exports.ignore = function () {};

                        exports.inherits = Util.inherits;

                        exports.format = Util.format;

                        exports.transform = function (source, transform, options) {

                            exports.assert(source === null || source === undefined || (typeof source === 'undefined' ? 'undefined' : _typeof(source)) === 'object' || Array.isArray(source), 'Invalid source object: must be null, undefined, an object, or an array');
                            var separator = (typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object' && options !== null ? options.separator || '.' : '.';

                            if (Array.isArray(source)) {
                                var results = [];
                                for (var i = 0; i < source.length; ++i) {
                                    results.push(exports.transform(source[i], transform, options));
                                }
                                return results;
                            }

                            var result = {};
                            var keys = Object.keys(transform);

                            for (var _i8 = 0; _i8 < keys.length; ++_i8) {
                                var key = keys[_i8];
                                var path = key.split(separator);
                                var sourcePath = transform[key];

                                exports.assert(typeof sourcePath === 'string', 'All mappings must be "." delineated strings');

                                var segment = void 0;
                                var res = result;

                                while (path.length > 1) {
                                    segment = path.shift();
                                    if (!res[segment]) {
                                        res[segment] = {};
                                    }
                                    res = res[segment];
                                }
                                segment = path.shift();
                                res[segment] = exports.reach(source, sourcePath, options);
                            }

                            return result;
                        };

                        exports.uniqueFilename = function (path, extension) {

                            if (extension) {
                                extension = extension[0] !== '.' ? '.' + extension : extension;
                            } else {
                                extension = '';
                            }

                            path = Path.resolve(path);
                            var name = [Date.now(), process.pid, Crypto.randomBytes(8).toString('hex')].join('-') + extension;
                            return Path.join(path, name);
                        };

                        exports.stringify = function () {

                            try {
                                for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                                    args[_key3] = arguments[_key3];
                                }

                                return JSON.stringify.apply(null, args);
                            } catch (err) {
                                return '[Cannot display object: ' + err.message + ']';
                            }
                        };

                        exports.shallow = function (source) {

                            var target = {};
                            var keys = Object.keys(source);
                            for (var i = 0; i < keys.length; ++i) {
                                var key = keys[i];
                                target[key] = source[key];
                            }

                            return target;
                        };

                        exports.wait = function (timeout) {

                            return new Promise(function (resolve) {
                                return setTimeout(resolve, timeout);
                            });
                        };

                        exports.block = function () {

                            return new Promise(exports.ignore);
                        };
                        /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).Buffer, __webpack_require__(7)));

                    /***/ }),
                /* 1 */
                /***/ (function(module, exports, __webpack_require__) {


// Load modules

                    var Hoek = __webpack_require__(0);

                    exports.create = function (key, options) {

                        Hoek.assert(typeof key === 'string', 'Invalid reference key:', key);

                        var settings = Hoek.clone(options); // options can be reused and modified

                        var ref = function ref(value, validationOptions) {

                            return Hoek.reach(ref.isContext ? validationOptions.context : value, ref.key, settings);
                        };

                        ref.isContext = key[0] === (settings && settings.contextPrefix || '$');
                        ref.key = ref.isContext ? key.slice(1) : key;
                        ref.path = ref.key.split(settings && settings.separator || '.');
                        ref.depth = ref.path.length;
                        ref.root = ref.path[0];
                        ref.isJoi = true;

                        ref.toString = function () {

                            return (ref.isContext ? 'context:' : 'ref:') + ref.key;
                        };

                        return ref;
                    };

                    exports.isRef = function (ref) {

                        return typeof ref === 'function' && ref.isJoi;
                    };

                    exports.push = function (array, ref) {

                        if (exports.isRef(ref) && !ref.isContext) {

                            array.push(ref.root);
                        }
                    };

                    /***/ }),
                /* 2 */
                /***/ (function(module, exports, __webpack_require__) {


// Load modules

                    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

                    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

                    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

                    var Hoek = __webpack_require__(0);
                    var Settings = __webpack_require__(11);
                    var Ref = __webpack_require__(1);
                    var Errors = __webpack_require__(6);
                    var Alternatives = null; // Delay-loaded to prevent circular dependencies
                    var Cast = null;

// Declare internals

                    var internals = {
                        Set: __webpack_require__(9)
                    };

                    internals.defaults = {
                        abortEarly: true,
                        convert: true,
                        allowUnknown: false,
                        skipFunctions: false,
                        stripUnknown: false,
                        language: {},
                        presence: 'optional',
                        strip: false,
                        noDefaults: false,
                        escapeHtml: false

                        // context: null
                    };

                    module.exports = internals.Any = function () {
                        function _class() {
                            _classCallCheck(this, _class);

                            Cast = Cast || __webpack_require__(4);

                            this.isJoi = true;
                            this._type = 'any';
                            this._settings = null;
                            this._valids = new internals.Set();
                            this._invalids = new internals.Set();
                            this._tests = [];
                            this._refs = [];
                            this._flags = {
                                /*
             presence: 'optional',                   // optional, required, forbidden, ignore
             allowOnly: false,
             allowUnknown: undefined,
             default: undefined,
             forbidden: false,
             encoding: undefined,
             insensitive: false,
             trim: false,
             normalize: undefined,                   // NFC, NFD, NFKC, NFKD
             case: undefined,                        // upper, lower
             empty: undefined,
             func: false,
             raw: false
             */
                            };

                            this._description = null;
                            this._unit = null;
                            this._notes = [];
                            this._tags = [];
                            this._examples = [];
                            this._meta = [];

                            this._inner = {}; // Hash of arrays of immutable objects
                        }

                        _class.prototype._init = function _init() {

                            return this;
                        };

                        _class.prototype.createError = function createError(type, context, state, options) {
                            var flags = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this._flags;


                            return Errors.create(type, context, state, options, flags);
                        };

                        _class.prototype.createOverrideError = function createOverrideError(type, context, state, options, message, template) {

                            return Errors.create(type, context, state, options, this._flags, message, template);
                        };

                        _class.prototype.checkOptions = function checkOptions(options) {

                            var Schemas = __webpack_require__(21);
                            var result = Schemas.options.validate(options);
                            if (result.error) {
                                throw new Error(result.error.details[0].message);
                            }
                        };

                        _class.prototype.clone = function clone() {

                            var obj = Object.create(Object.getPrototypeOf(this));

                            obj.isJoi = true;
                            obj._currentJoi = this._currentJoi;
                            obj._type = this._type;
                            obj._settings = this._settings;
                            obj._baseType = this._baseType;
                            obj._valids = this._valids.slice();
                            obj._invalids = this._invalids.slice();
                            obj._tests = this._tests.slice();
                            obj._refs = this._refs.slice();
                            obj._flags = Hoek.clone(this._flags);

                            obj._description = this._description;
                            obj._unit = this._unit;
                            obj._notes = this._notes.slice();
                            obj._tags = this._tags.slice();
                            obj._examples = this._examples.slice();
                            obj._meta = this._meta.slice();

                            obj._inner = {};
                            var inners = Object.keys(this._inner);
                            for (var i = 0; i < inners.length; ++i) {
                                var key = inners[i];
                                obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;
                            }

                            return obj;
                        };

                        _class.prototype.concat = function concat(schema) {

                            Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');
                            Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);

                            var obj = this.clone();

                            if (this._type === 'any' && schema._type !== 'any') {

                                // Reset values as if we were "this"
                                var tmpObj = schema.clone();
                                var keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit', '_notes', '_tags', '_examples', '_meta', '_inner'];

                                for (var i = 0; i < keysToRestore.length; ++i) {
                                    tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];
                                }

                                obj = tmpObj;
                            }

                            obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;
                            obj._valids.merge(schema._valids, schema._invalids);
                            obj._invalids.merge(schema._invalids, schema._valids);
                            obj._tests = obj._tests.concat(schema._tests);
                            obj._refs = obj._refs.concat(schema._refs);
                            Hoek.merge(obj._flags, schema._flags);

                            obj._description = schema._description || obj._description;
                            obj._unit = schema._unit || obj._unit;
                            obj._notes = obj._notes.concat(schema._notes);
                            obj._tags = obj._tags.concat(schema._tags);
                            obj._examples = obj._examples.concat(schema._examples);
                            obj._meta = obj._meta.concat(schema._meta);

                            var inners = Object.keys(schema._inner);
                            var isObject = obj._type === 'object';
                            for (var _i = 0; _i < inners.length; ++_i) {
                                var key = inners[_i];
                                var source = schema._inner[key];
                                if (source) {
                                    var target = obj._inner[key];
                                    if (target) {
                                        if (isObject && key === 'children') {
                                            var keys = {};

                                            for (var j = 0; j < target.length; ++j) {
                                                keys[target[j].key] = j;
                                            }

                                            for (var _j = 0; _j < source.length; ++_j) {
                                                var sourceKey = source[_j].key;
                                                if (keys[sourceKey] >= 0) {
                                                    target[keys[sourceKey]] = {
                                                        key: sourceKey,
                                                        schema: target[keys[sourceKey]].schema.concat(source[_j].schema)
                                                    };
                                                } else {
                                                    target.push(source[_j]);
                                                }
                                            }
                                        } else {
                                            obj._inner[key] = obj._inner[key].concat(source);
                                        }
                                    } else {
                                        obj._inner[key] = source.slice();
                                    }
                                }
                            }

                            return obj;
                        };

                        _class.prototype._test = function _test(name, arg, func, options) {

                            var obj = this.clone();
                            obj._tests.push({ func: func, name: name, arg: arg, options: options });
                            return obj;
                        };

                        _class.prototype.options = function options(_options) {

                            Hoek.assert(!_options.context, 'Cannot override context');
                            this.checkOptions(_options);

                            var obj = this.clone();
                            obj._settings = Settings.concat(obj._settings, _options);
                            return obj;
                        };

                        _class.prototype.strict = function strict(isStrict) {

                            var obj = this.clone();

                            var convert = isStrict === undefined ? false : !isStrict;
                            obj._settings = Settings.concat(obj._settings, { convert: convert });
                            return obj;
                        };

                        _class.prototype.raw = function raw(isRaw) {

                            var value = isRaw === undefined ? true : isRaw;

                            if (this._flags.raw === value) {
                                return this;
                            }

                            var obj = this.clone();
                            obj._flags.raw = value;
                            return obj;
                        };

                        _class.prototype.error = function error(err) {

                            Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');

                            var obj = this.clone();
                            obj._flags.error = err;
                            return obj;
                        };

                        _class.prototype.allow = function allow() {
                            for (var _len = arguments.length, values = Array(_len), _key = 0; _key < _len; _key++) {
                                values[_key] = arguments[_key];
                            }

                            var obj = this.clone();
                            values = Hoek.flatten(values);
                            for (var i = 0; i < values.length; ++i) {
                                var value = values[i];

                                Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');
                                obj._invalids.remove(value);
                                obj._valids.add(value, obj._refs);
                            }
                            return obj;
                        };

                        _class.prototype.valid = function valid() {

                            var obj = this.allow.apply(this, arguments);
                            obj._flags.allowOnly = true;
                            return obj;
                        };

                        _class.prototype.invalid = function invalid() {
                            for (var _len2 = arguments.length, values = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                                values[_key2] = arguments[_key2];
                            }

                            var obj = this.clone();
                            values = Hoek.flatten(values);
                            for (var i = 0; i < values.length; ++i) {
                                var value = values[i];

                                Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');
                                obj._valids.remove(value);
                                obj._invalids.add(value, obj._refs);
                            }

                            return obj;
                        };

                        _class.prototype.required = function required() {

                            if (this._flags.presence === 'required') {
                                return this;
                            }

                            var obj = this.clone();
                            obj._flags.presence = 'required';
                            return obj;
                        };

                        _class.prototype.optional = function optional() {

                            if (this._flags.presence === 'optional') {
                                return this;
                            }

                            var obj = this.clone();
                            obj._flags.presence = 'optional';
                            return obj;
                        };

                        _class.prototype.forbidden = function forbidden() {

                            if (this._flags.presence === 'forbidden') {
                                return this;
                            }

                            var obj = this.clone();
                            obj._flags.presence = 'forbidden';
                            return obj;
                        };

                        _class.prototype.strip = function strip() {

                            if (this._flags.strip) {
                                return this;
                            }

                            var obj = this.clone();
                            obj._flags.strip = true;
                            return obj;
                        };

                        _class.prototype.applyFunctionToChildren = function applyFunctionToChildren(children, fn, args, root) {

                            children = [].concat(children);

                            if (children.length !== 1 || children[0] !== '') {
                                root = root ? root + '.' : '';

                                var extraChildren = (children[0] === '' ? children.slice(1) : children).map(function (child) {

                                    return root + child;
                                });

                                throw new Error('unknown key(s) ' + extraChildren.join(', '));
                            }

                            return this[fn].apply(this, args);
                        };

                        _class.prototype.default = function _default(value, description) {

                            if (typeof value === 'function' && !Ref.isRef(value)) {

                                if (!value.description && description) {

                                    value.description = description;
                                }

                                if (!this._flags.func) {
                                    Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');
                                }
                            }

                            var obj = this.clone();
                            obj._flags.default = value;
                            Ref.push(obj._refs, value);
                            return obj;
                        };

                        _class.prototype.empty = function empty(schema) {

                            var obj = this.clone();
                            if (schema === undefined) {
                                delete obj._flags.empty;
                            } else {
                                obj._flags.empty = Cast.schema(this._currentJoi, schema);
                            }
                            return obj;
                        };

                        _class.prototype.when = function when(condition, options) {

                            Hoek.assert(options && (typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object', 'Invalid options');
                            Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of "then" or "otherwise"');

                            var then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;
                            var otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;

                            Alternatives = Alternatives || __webpack_require__(10);

                            var alternativeOptions = { then: then, otherwise: otherwise };
                            if (Object.prototype.hasOwnProperty.call(options, 'is')) {
                                alternativeOptions.is = options.is;
                            }
                            var obj = Alternatives.when(condition, alternativeOptions);
                            obj._flags.presence = 'ignore';
                            obj._baseType = this;

                            return obj;
                        };

                        _class.prototype.description = function description(desc) {

                            Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');

                            var obj = this.clone();
                            obj._description = desc;
                            return obj;
                        };

                        _class.prototype.notes = function notes(_notes) {

                            Hoek.assert(_notes && (typeof _notes === 'string' || Array.isArray(_notes)), 'Notes must be a non-empty string or array');

                            var obj = this.clone();
                            obj._notes = obj._notes.concat(_notes);
                            return obj;
                        };

                        _class.prototype.tags = function tags(_tags) {

                            Hoek.assert(_tags && (typeof _tags === 'string' || Array.isArray(_tags)), 'Tags must be a non-empty string or array');

                            var obj = this.clone();
                            obj._tags = obj._tags.concat(_tags);
                            return obj;
                        };

                        _class.prototype.meta = function meta(_meta) {

                            Hoek.assert(_meta !== undefined, 'Meta cannot be undefined');

                            var obj = this.clone();
                            obj._meta = obj._meta.concat(_meta);
                            return obj;
                        };

                        _class.prototype.example = function example() {

                            Hoek.assert(arguments.length === 1, 'Missing example');
                            var value = arguments.length <= 0 ? undefined : arguments[0];

                            var obj = this.clone();
                            obj._examples.push(value);
                            return obj;
                        };

                        _class.prototype.unit = function unit(name) {

                            Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');

                            var obj = this.clone();
                            obj._unit = name;
                            return obj;
                        };

                        _class.prototype._prepareEmptyValue = function _prepareEmptyValue(value) {

                            if (typeof value === 'string' && this._flags.trim) {
                                return value.trim();
                            }

                            return value;
                        };

                        _class.prototype._validate = function _validate(value, state, options, reference) {
                            var _this = this;

                            var originalValue = value;

                            // Setup state and settings

                            state = state || { key: '', path: [], parent: null, reference: reference };

                            if (this._settings) {
                                options = Settings.concat(options, this._settings);
                            }

                            var errors = [];
                            var finish = function finish() {

                                var finalValue = void 0;

                                if (value !== undefined) {
                                    finalValue = _this._flags.raw ? originalValue : value;
                                } else if (options.noDefaults) {
                                    finalValue = value;
                                } else if (Ref.isRef(_this._flags.default)) {
                                    finalValue = _this._flags.default(state.parent, options);
                                } else if (typeof _this._flags.default === 'function' && !(_this._flags.func && !_this._flags.default.description)) {

                                    var args = void 0;

                                    if (state.parent !== null && _this._flags.default.length > 0) {

                                        args = [Hoek.clone(state.parent), options];
                                    }

                                    var defaultValue = internals._try(_this._flags.default, args);
                                    finalValue = defaultValue.value;
                                    if (defaultValue.error) {
                                        errors.push(_this.createError('any.default', { error: defaultValue.error }, state, options));
                                    }
                                } else {
                                    finalValue = Hoek.clone(_this._flags.default);
                                }

                                if (errors.length && typeof _this._flags.error === 'function') {
                                    var change = _this._flags.error.call(_this, errors);

                                    if (typeof change === 'string') {
                                        errors = [_this.createOverrideError('override', { reason: errors }, state, options, change)];
                                    } else {
                                        errors = [].concat(change).map(function (err) {

                                            return err instanceof Error ? err : _this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);
                                        });
                                    }
                                }

                                return {
                                    value: _this._flags.strip ? undefined : finalValue,
                                    finalValue: finalValue,
                                    errors: errors.length ? errors : null
                                };
                            };

                            if (this._coerce) {
                                var coerced = this._coerce.call(this, value, state, options);
                                if (coerced.errors) {
                                    value = coerced.value;
                                    errors = errors.concat(coerced.errors);
                                    return finish(); // Coerced error always aborts early
                                }

                                value = coerced.value;
                            }

                            if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {
                                value = undefined;
                            }

                            // Check presence requirements

                            var presence = this._flags.presence || options.presence;
                            if (presence === 'optional') {
                                if (value === undefined) {
                                    var isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;
                                    if (isDeepDefault && this._type === 'object') {
                                        value = {};
                                    } else {
                                        return finish();
                                    }
                                }
                            } else if (presence === 'required' && value === undefined) {

                                errors.push(this.createError('any.required', null, state, options));
                                return finish();
                            } else if (presence === 'forbidden') {
                                if (value === undefined) {
                                    return finish();
                                }

                                errors.push(this.createError('any.unknown', null, state, options));
                                return finish();
                            }

                            // Check allowed and denied values using the original value

                            if (this._valids.has(value, state, options, this._flags.insensitive)) {
                                return finish();
                            }

                            if (this._invalids.has(value, state, options, this._flags.insensitive)) {
                                errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value: value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));
                                if (options.abortEarly || value === undefined) {
                                    // No reason to keep validating missing value

                                    return finish();
                                }
                            }

                            // Convert value and validate type

                            if (this._base) {
                                var base = this._base.call(this, value, state, options);
                                if (base.errors) {
                                    value = base.value;
                                    errors = errors.concat(base.errors);
                                    return finish(); // Base error always aborts early
                                }

                                if (base.value !== value) {
                                    value = base.value;

                                    // Check allowed and denied values using the converted value

                                    if (this._valids.has(value, state, options, this._flags.insensitive)) {
                                        return finish();
                                    }

                                    if (this._invalids.has(value, state, options, this._flags.insensitive)) {
                                        errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value: value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));
                                        if (options.abortEarly) {
                                            return finish();
                                        }
                                    }
                                }
                            }

                            // Required values did not match

                            if (this._flags.allowOnly) {
                                errors.push(this.createError('any.allowOnly', { value: value, valids: this._valids.values({ stripUndefined: true }) }, state, options));
                                if (options.abortEarly) {
                                    return finish();
                                }
                            }

                            // Validate tests

                            for (var i = 0; i < this._tests.length; ++i) {
                                var test = this._tests[i];
                                var ret = test.func.call(this, value, state, options);
                                if (ret instanceof Errors.Err) {
                                    errors.push(ret);
                                    if (options.abortEarly) {
                                        return finish();
                                    }
                                } else {
                                    value = ret;
                                }
                            }

                            return finish();
                        };

                        _class.prototype._validateWithOptions = function _validateWithOptions(value, options, callback) {

                            if (options) {
                                this.checkOptions(options);
                            }

                            var settings = Settings.concat(internals.defaults, options);
                            var result = this._validate(value, null, settings);
                            var errors = Errors.process(result.errors, value);

                            if (callback) {
                                return callback(errors, result.value);
                            }

                            return {
                                error: errors,
                                value: result.value,
                                then: function then(resolve, reject) {

                                    if (errors) {
                                        return Promise.reject(errors).catch(reject);
                                    }

                                    return Promise.resolve(result.value).then(resolve);
                                },
                                catch: function _catch(reject) {

                                    if (errors) {
                                        return Promise.reject(errors).catch(reject);
                                    }

                                    return Promise.resolve(result.value);
                                }
                            };
                        };

                        _class.prototype.validate = function validate(value, options, callback) {

                            if (typeof options === 'function') {
                                return this._validateWithOptions(value, null, options);
                            }

                            return this._validateWithOptions(value, options, callback);
                        };

                        _class.prototype.describe = function describe() {
                            var _this2 = this;

                            var description = {
                                type: this._type
                            };

                            var flags = Object.keys(this._flags);
                            if (flags.length) {
                                if (['empty', 'default', 'lazy', 'label'].some(function (flag) {
                                    return _this2._flags.hasOwnProperty(flag);
                                })) {
                                    description.flags = {};
                                    for (var i = 0; i < flags.length; ++i) {
                                        var flag = flags[i];
                                        if (flag === 'empty') {
                                            description.flags[flag] = this._flags[flag].describe();
                                        } else if (flag === 'default') {
                                            if (Ref.isRef(this._flags[flag])) {
                                                description.flags[flag] = this._flags[flag].toString();
                                            } else if (typeof this._flags[flag] === 'function') {
                                                description.flags[flag] = {
                                                    description: this._flags[flag].description,
                                                    function: this._flags[flag]
                                                };
                                            } else {
                                                description.flags[flag] = this._flags[flag];
                                            }
                                        } else if (flag === 'lazy' || flag === 'label') ; else {
                                            description.flags[flag] = this._flags[flag];
                                        }
                                    }
                                } else {
                                    description.flags = this._flags;
                                }
                            }

                            if (this._settings) {
                                description.options = Hoek.clone(this._settings);
                            }

                            if (this._baseType) {
                                description.base = this._baseType.describe();
                            }

                            if (this._description) {
                                description.description = this._description;
                            }

                            if (this._notes.length) {
                                description.notes = this._notes;
                            }

                            if (this._tags.length) {
                                description.tags = this._tags;
                            }

                            if (this._meta.length) {
                                description.meta = this._meta;
                            }

                            if (this._examples.length) {
                                description.examples = this._examples;
                            }

                            if (this._unit) {
                                description.unit = this._unit;
                            }

                            var valids = this._valids.values();
                            if (valids.length) {
                                description.valids = valids.map(function (v) {

                                    return Ref.isRef(v) ? v.toString() : v;
                                });
                            }

                            var invalids = this._invalids.values();
                            if (invalids.length) {
                                description.invalids = invalids.map(function (v) {

                                    return Ref.isRef(v) ? v.toString() : v;
                                });
                            }

                            description.rules = [];

                            for (var _i2 = 0; _i2 < this._tests.length; ++_i2) {
                                var validator = this._tests[_i2];
                                var item = { name: validator.name };

                                if (validator.arg !== void 0) {
                                    item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;
                                }

                                var options = validator.options;
                                if (options) {
                                    if (options.hasRef) {
                                        item.arg = {};
                                        var keys = Object.keys(validator.arg);
                                        for (var j = 0; j < keys.length; ++j) {
                                            var key = keys[j];
                                            var value = validator.arg[key];
                                            item.arg[key] = Ref.isRef(value) ? value.toString() : value;
                                        }
                                    }

                                    if (typeof options.description === 'string') {
                                        item.description = options.description;
                                    } else if (typeof options.description === 'function') {
                                        item.description = options.description(item.arg);
                                    }
                                }

                                description.rules.push(item);
                            }

                            if (!description.rules.length) {
                                delete description.rules;
                            }

                            var label = this._getLabel();
                            if (label) {
                                description.label = label;
                            }

                            return description;
                        };

                        _class.prototype.label = function label(name) {

                            Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');

                            var obj = this.clone();
                            obj._flags.label = name;
                            return obj;
                        };

                        _class.prototype._getLabel = function _getLabel(def) {

                            return this._flags.label || def;
                        };

                        _createClass(_class, [{
                            key: 'schemaType',
                            get: function get() {

                                return this._type;
                            }
                        }]);

                        return _class;
                    }();

                    internals.Any.prototype.isImmutable = true; // Prevents Hoek from deep cloning schema objects

// Aliases

                    internals.Any.prototype.only = internals.Any.prototype.equal = internals.Any.prototype.valid;
                    internals.Any.prototype.disallow = internals.Any.prototype.not = internals.Any.prototype.invalid;
                    internals.Any.prototype.exist = internals.Any.prototype.required;

                    internals._try = function (fn, args) {

                        var err = void 0;
                        var result = void 0;

                        try {
                            result = fn.apply(null, args);
                        } catch (e) {
                            err = e;
                        }

                        return {
                            value: result,
                            error: err
                        };
                    };

                    /***/ }),
                /* 3 */
                /***/ (function(module, exports, __webpack_require__) {
                    /* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
                        /* eslint-disable no-proto */



                        var base64 = __webpack_require__(33);
                        var ieee754 = __webpack_require__(34);
                        var isArray = __webpack_require__(35);

                        exports.Buffer = Buffer;
                        exports.SlowBuffer = SlowBuffer;
                        exports.INSPECT_MAX_BYTES = 50;

                        /**
                         * If `Buffer.TYPED_ARRAY_SUPPORT`:
                         *   === true    Use Uint8Array implementation (fastest)
                         *   === false   Use Object implementation (most compatible, even IE6)
                         *
                         * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
                         * Opera 11.6+, iOS 4.2+.
                         *
                         * Due to various browser bugs, sometimes the Object implementation will be used even
                         * when the browser supports typed arrays.
                         *
                         * Note:
                         *
                         *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
                         *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
                         *
                         *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
                         *
                         *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
                         *     incorrect length in some situations.

                         * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
                         * get the Object implementation, which is slower but behaves correctly.
                         */
                        Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
                            ? global.TYPED_ARRAY_SUPPORT
                            : typedArraySupport();

                        /*
 * Export kMaxLength after typed array support is determined.
 */
                        exports.kMaxLength = kMaxLength();

                        function typedArraySupport () {
                            try {
                                var arr = new Uint8Array(1);
                                arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }};
                                return arr.foo() === 42 && // typed array instances can be augmented
                                    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
                                    arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
                            } catch (e) {
                                return false
                            }
                        }

                        function kMaxLength () {
                            return Buffer.TYPED_ARRAY_SUPPORT
                                ? 0x7fffffff
                                : 0x3fffffff
                        }

                        function createBuffer (that, length) {
                            if (kMaxLength() < length) {
                                throw new RangeError('Invalid typed array length')
                            }
                            if (Buffer.TYPED_ARRAY_SUPPORT) {
                                // Return an augmented `Uint8Array` instance, for best performance
                                that = new Uint8Array(length);
                                that.__proto__ = Buffer.prototype;
                            } else {
                                // Fallback: Return an object instance of the Buffer class
                                if (that === null) {
                                    that = new Buffer(length);
                                }
                                that.length = length;
                            }

                            return that
                        }

                        /**
                         * The Buffer constructor returns instances of `Uint8Array` that have their
                         * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
                         * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
                         * and the `Uint8Array` methods. Square bracket notation works as expected -- it
                         * returns a single octet.
                         *
                         * The `Uint8Array` prototype remains unmodified.
                         */

                        function Buffer (arg, encodingOrOffset, length) {
                            if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
                                return new Buffer(arg, encodingOrOffset, length)
                            }

                            // Common case.
                            if (typeof arg === 'number') {
                                if (typeof encodingOrOffset === 'string') {
                                    throw new Error(
                                        'If encoding is specified then the first argument must be a string'
                                    )
                                }
                                return allocUnsafe(this, arg)
                            }
                            return from(this, arg, encodingOrOffset, length)
                        }

                        Buffer.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
                        Buffer._augment = function (arr) {
                            arr.__proto__ = Buffer.prototype;
                            return arr
                        };

                        function from (that, value, encodingOrOffset, length) {
                            if (typeof value === 'number') {
                                throw new TypeError('"value" argument must not be a number')
                            }

                            if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
                                return fromArrayBuffer(that, value, encodingOrOffset, length)
                            }

                            if (typeof value === 'string') {
                                return fromString(that, value, encodingOrOffset)
                            }

                            return fromObject(that, value)
                        }

                        /**
                         * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
                         * if value is a number.
                         * Buffer.from(str[, encoding])
                         * Buffer.from(array)
                         * Buffer.from(buffer)
                         * Buffer.from(arrayBuffer[, byteOffset[, length]])
                         **/
                        Buffer.from = function (value, encodingOrOffset, length) {
                            return from(null, value, encodingOrOffset, length)
                        };

                        if (Buffer.TYPED_ARRAY_SUPPORT) {
                            Buffer.prototype.__proto__ = Uint8Array.prototype;
                            Buffer.__proto__ = Uint8Array;
                            if (typeof Symbol !== 'undefined' && Symbol.species &&
                                Buffer[Symbol.species] === Buffer) {
                                // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
                                Object.defineProperty(Buffer, Symbol.species, {
                                    value: null,
                                    configurable: true
                                });
                            }
                        }

                        function assertSize (size) {
                            if (typeof size !== 'number') {
                                throw new TypeError('"size" argument must be a number')
                            } else if (size < 0) {
                                throw new RangeError('"size" argument must not be negative')
                            }
                        }

                        function alloc (that, size, fill, encoding) {
                            assertSize(size);
                            if (size <= 0) {
                                return createBuffer(that, size)
                            }
                            if (fill !== undefined) {
                                // Only pay attention to encoding if it's a string. This
                                // prevents accidentally sending in a number that would
                                // be interpretted as a start offset.
                                return typeof encoding === 'string'
                                    ? createBuffer(that, size).fill(fill, encoding)
                                    : createBuffer(that, size).fill(fill)
                            }
                            return createBuffer(that, size)
                        }

                        /**
                         * Creates a new filled Buffer instance.
                         * alloc(size[, fill[, encoding]])
                         **/
                        Buffer.alloc = function (size, fill, encoding) {
                            return alloc(null, size, fill, encoding)
                        };

                        function allocUnsafe (that, size) {
                            assertSize(size);
                            that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
                            if (!Buffer.TYPED_ARRAY_SUPPORT) {
                                for (var i = 0; i < size; ++i) {
                                    that[i] = 0;
                                }
                            }
                            return that
                        }

                        /**
                         * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
                         * */
                        Buffer.allocUnsafe = function (size) {
                            return allocUnsafe(null, size)
                        };
                        /**
                         * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
                         */
                        Buffer.allocUnsafeSlow = function (size) {
                            return allocUnsafe(null, size)
                        };

                        function fromString (that, string, encoding) {
                            if (typeof encoding !== 'string' || encoding === '') {
                                encoding = 'utf8';
                            }

                            if (!Buffer.isEncoding(encoding)) {
                                throw new TypeError('"encoding" must be a valid string encoding')
                            }

                            var length = byteLength(string, encoding) | 0;
                            that = createBuffer(that, length);

                            var actual = that.write(string, encoding);

                            if (actual !== length) {
                                // Writing a hex string, for example, that contains invalid characters will
                                // cause everything after the first invalid character to be ignored. (e.g.
                                // 'abxxcd' will be treated as 'ab')
                                that = that.slice(0, actual);
                            }

                            return that
                        }

                        function fromArrayLike (that, array) {
                            var length = array.length < 0 ? 0 : checked(array.length) | 0;
                            that = createBuffer(that, length);
                            for (var i = 0; i < length; i += 1) {
                                that[i] = array[i] & 255;
                            }
                            return that
                        }

                        function fromArrayBuffer (that, array, byteOffset, length) {
                            array.byteLength; // this throws if `array` is not a valid ArrayBuffer

                            if (byteOffset < 0 || array.byteLength < byteOffset) {
                                throw new RangeError('\'offset\' is out of bounds')
                            }

                            if (array.byteLength < byteOffset + (length || 0)) {
                                throw new RangeError('\'length\' is out of bounds')
                            }

                            if (byteOffset === undefined && length === undefined) {
                                array = new Uint8Array(array);
                            } else if (length === undefined) {
                                array = new Uint8Array(array, byteOffset);
                            } else {
                                array = new Uint8Array(array, byteOffset, length);
                            }

                            if (Buffer.TYPED_ARRAY_SUPPORT) {
                                // Return an augmented `Uint8Array` instance, for best performance
                                that = array;
                                that.__proto__ = Buffer.prototype;
                            } else {
                                // Fallback: Return an object instance of the Buffer class
                                that = fromArrayLike(that, array);
                            }
                            return that
                        }

                        function fromObject (that, obj) {
                            if (Buffer.isBuffer(obj)) {
                                var len = checked(obj.length) | 0;
                                that = createBuffer(that, len);

                                if (that.length === 0) {
                                    return that
                                }

                                obj.copy(that, 0, 0, len);
                                return that
                            }

                            if (obj) {
                                if ((typeof ArrayBuffer !== 'undefined' &&
                                    obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
                                    if (typeof obj.length !== 'number' || isnan(obj.length)) {
                                        return createBuffer(that, 0)
                                    }
                                    return fromArrayLike(that, obj)
                                }

                                if (obj.type === 'Buffer' && isArray(obj.data)) {
                                    return fromArrayLike(that, obj.data)
                                }
                            }

                            throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
                        }

                        function checked (length) {
                            // Note: cannot use `length < kMaxLength()` here because that fails when
                            // length is NaN (which is otherwise coerced to zero.)
                            if (length >= kMaxLength()) {
                                throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                                    'size: 0x' + kMaxLength().toString(16) + ' bytes')
                            }
                            return length | 0
                        }

                        function SlowBuffer (length) {
                            if (+length != length) { // eslint-disable-line eqeqeq
                                length = 0;
                            }
                            return Buffer.alloc(+length)
                        }

                        Buffer.isBuffer = function isBuffer (b) {
                            return !!(b != null && b._isBuffer)
                        };

                        Buffer.compare = function compare (a, b) {
                            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                                throw new TypeError('Arguments must be Buffers')
                            }

                            if (a === b) return 0

                            var x = a.length;
                            var y = b.length;

                            for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                                if (a[i] !== b[i]) {
                                    x = a[i];
                                    y = b[i];
                                    break
                                }
                            }

                            if (x < y) return -1
                            if (y < x) return 1
                            return 0
                        };

                        Buffer.isEncoding = function isEncoding (encoding) {
                            switch (String(encoding).toLowerCase()) {
                                case 'hex':
                                case 'utf8':
                                case 'utf-8':
                                case 'ascii':
                                case 'latin1':
                                case 'binary':
                                case 'base64':
                                case 'ucs2':
                                case 'ucs-2':
                                case 'utf16le':
                                case 'utf-16le':
                                    return true
                                default:
                                    return false
                            }
                        };

                        Buffer.concat = function concat (list, length) {
                            if (!isArray(list)) {
                                throw new TypeError('"list" argument must be an Array of Buffers')
                            }

                            if (list.length === 0) {
                                return Buffer.alloc(0)
                            }

                            var i;
                            if (length === undefined) {
                                length = 0;
                                for (i = 0; i < list.length; ++i) {
                                    length += list[i].length;
                                }
                            }

                            var buffer = Buffer.allocUnsafe(length);
                            var pos = 0;
                            for (i = 0; i < list.length; ++i) {
                                var buf = list[i];
                                if (!Buffer.isBuffer(buf)) {
                                    throw new TypeError('"list" argument must be an Array of Buffers')
                                }
                                buf.copy(buffer, pos);
                                pos += buf.length;
                            }
                            return buffer
                        };

                        function byteLength (string, encoding) {
                            if (Buffer.isBuffer(string)) {
                                return string.length
                            }
                            if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
                                (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
                                return string.byteLength
                            }
                            if (typeof string !== 'string') {
                                string = '' + string;
                            }

                            var len = string.length;
                            if (len === 0) return 0

                            // Use a for loop to avoid recursion
                            var loweredCase = false;
                            for (;;) {
                                switch (encoding) {
                                    case 'ascii':
                                    case 'latin1':
                                    case 'binary':
                                        return len
                                    case 'utf8':
                                    case 'utf-8':
                                    case undefined:
                                        return utf8ToBytes(string).length
                                    case 'ucs2':
                                    case 'ucs-2':
                                    case 'utf16le':
                                    case 'utf-16le':
                                        return len * 2
                                    case 'hex':
                                        return len >>> 1
                                    case 'base64':
                                        return base64ToBytes(string).length
                                    default:
                                        if (loweredCase) return utf8ToBytes(string).length // assume utf8
                                        encoding = ('' + encoding).toLowerCase();
                                        loweredCase = true;
                                }
                            }
                        }
                        Buffer.byteLength = byteLength;

                        function slowToString (encoding, start, end) {
                            var loweredCase = false;

                            // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
                            // property of a typed array.

                            // This behaves neither like String nor Uint8Array in that we set start/end
                            // to their upper/lower bounds if the value passed is out of range.
                            // undefined is handled specially as per ECMA-262 6th Edition,
                            // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
                            if (start === undefined || start < 0) {
                                start = 0;
                            }
                            // Return early if start > this.length. Done here to prevent potential uint32
                            // coercion fail below.
                            if (start > this.length) {
                                return ''
                            }

                            if (end === undefined || end > this.length) {
                                end = this.length;
                            }

                            if (end <= 0) {
                                return ''
                            }

                            // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
                            end >>>= 0;
                            start >>>= 0;

                            if (end <= start) {
                                return ''
                            }

                            if (!encoding) encoding = 'utf8';

                            while (true) {
                                switch (encoding) {
                                    case 'hex':
                                        return hexSlice(this, start, end)

                                    case 'utf8':
                                    case 'utf-8':
                                        return utf8Slice(this, start, end)

                                    case 'ascii':
                                        return asciiSlice(this, start, end)

                                    case 'latin1':
                                    case 'binary':
                                        return latin1Slice(this, start, end)

                                    case 'base64':
                                        return base64Slice(this, start, end)

                                    case 'ucs2':
                                    case 'ucs-2':
                                    case 'utf16le':
                                    case 'utf-16le':
                                        return utf16leSlice(this, start, end)

                                    default:
                                        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                                        encoding = (encoding + '').toLowerCase();
                                        loweredCase = true;
                                }
                            }
                        }

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
                        Buffer.prototype._isBuffer = true;

                        function swap (b, n, m) {
                            var i = b[n];
                            b[n] = b[m];
                            b[m] = i;
                        }

                        Buffer.prototype.swap16 = function swap16 () {
                            var len = this.length;
                            if (len % 2 !== 0) {
                                throw new RangeError('Buffer size must be a multiple of 16-bits')
                            }
                            for (var i = 0; i < len; i += 2) {
                                swap(this, i, i + 1);
                            }
                            return this
                        };

                        Buffer.prototype.swap32 = function swap32 () {
                            var len = this.length;
                            if (len % 4 !== 0) {
                                throw new RangeError('Buffer size must be a multiple of 32-bits')
                            }
                            for (var i = 0; i < len; i += 4) {
                                swap(this, i, i + 3);
                                swap(this, i + 1, i + 2);
                            }
                            return this
                        };

                        Buffer.prototype.swap64 = function swap64 () {
                            var len = this.length;
                            if (len % 8 !== 0) {
                                throw new RangeError('Buffer size must be a multiple of 64-bits')
                            }
                            for (var i = 0; i < len; i += 8) {
                                swap(this, i, i + 7);
                                swap(this, i + 1, i + 6);
                                swap(this, i + 2, i + 5);
                                swap(this, i + 3, i + 4);
                            }
                            return this
                        };

                        Buffer.prototype.toString = function toString () {
                            var length = this.length | 0;
                            if (length === 0) return ''
                            if (arguments.length === 0) return utf8Slice(this, 0, length)
                            return slowToString.apply(this, arguments)
                        };

                        Buffer.prototype.equals = function equals (b) {
                            if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
                            if (this === b) return true
                            return Buffer.compare(this, b) === 0
                        };

                        Buffer.prototype.inspect = function inspect () {
                            var str = '';
                            var max = exports.INSPECT_MAX_BYTES;
                            if (this.length > 0) {
                                str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
                                if (this.length > max) str += ' ... ';
                            }
                            return '<Buffer ' + str + '>'
                        };

                        Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
                            if (!Buffer.isBuffer(target)) {
                                throw new TypeError('Argument must be a Buffer')
                            }

                            if (start === undefined) {
                                start = 0;
                            }
                            if (end === undefined) {
                                end = target ? target.length : 0;
                            }
                            if (thisStart === undefined) {
                                thisStart = 0;
                            }
                            if (thisEnd === undefined) {
                                thisEnd = this.length;
                            }

                            if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                                throw new RangeError('out of range index')
                            }

                            if (thisStart >= thisEnd && start >= end) {
                                return 0
                            }
                            if (thisStart >= thisEnd) {
                                return -1
                            }
                            if (start >= end) {
                                return 1
                            }

                            start >>>= 0;
                            end >>>= 0;
                            thisStart >>>= 0;
                            thisEnd >>>= 0;

                            if (this === target) return 0

                            var x = thisEnd - thisStart;
                            var y = end - start;
                            var len = Math.min(x, y);

                            var thisCopy = this.slice(thisStart, thisEnd);
                            var targetCopy = target.slice(start, end);

                            for (var i = 0; i < len; ++i) {
                                if (thisCopy[i] !== targetCopy[i]) {
                                    x = thisCopy[i];
                                    y = targetCopy[i];
                                    break
                                }
                            }

                            if (x < y) return -1
                            if (y < x) return 1
                            return 0
                        };

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
                        function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
                            // Empty buffer means no match
                            if (buffer.length === 0) return -1

                            // Normalize byteOffset
                            if (typeof byteOffset === 'string') {
                                encoding = byteOffset;
                                byteOffset = 0;
                            } else if (byteOffset > 0x7fffffff) {
                                byteOffset = 0x7fffffff;
                            } else if (byteOffset < -0x80000000) {
                                byteOffset = -0x80000000;
                            }
                            byteOffset = +byteOffset;  // Coerce to Number.
                            if (isNaN(byteOffset)) {
                                // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
                                byteOffset = dir ? 0 : (buffer.length - 1);
                            }

                            // Normalize byteOffset: negative offsets start from the end of the buffer
                            if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
                            if (byteOffset >= buffer.length) {
                                if (dir) return -1
                                else byteOffset = buffer.length - 1;
                            } else if (byteOffset < 0) {
                                if (dir) byteOffset = 0;
                                else return -1
                            }

                            // Normalize val
                            if (typeof val === 'string') {
                                val = Buffer.from(val, encoding);
                            }

                            // Finally, search either indexOf (if dir is true) or lastIndexOf
                            if (Buffer.isBuffer(val)) {
                                // Special case: looking for empty string/buffer always fails
                                if (val.length === 0) {
                                    return -1
                                }
                                return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
                            } else if (typeof val === 'number') {
                                val = val & 0xFF; // Search for a byte value [0-255]
                                if (Buffer.TYPED_ARRAY_SUPPORT &&
                                    typeof Uint8Array.prototype.indexOf === 'function') {
                                    if (dir) {
                                        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
                                    } else {
                                        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
                                    }
                                }
                                return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
                            }

                            throw new TypeError('val must be string, number or Buffer')
                        }

                        function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
                            var indexSize = 1;
                            var arrLength = arr.length;
                            var valLength = val.length;

                            if (encoding !== undefined) {
                                encoding = String(encoding).toLowerCase();
                                if (encoding === 'ucs2' || encoding === 'ucs-2' ||
                                    encoding === 'utf16le' || encoding === 'utf-16le') {
                                    if (arr.length < 2 || val.length < 2) {
                                        return -1
                                    }
                                    indexSize = 2;
                                    arrLength /= 2;
                                    valLength /= 2;
                                    byteOffset /= 2;
                                }
                            }

                            function read (buf, i) {
                                if (indexSize === 1) {
                                    return buf[i]
                                } else {
                                    return buf.readUInt16BE(i * indexSize)
                                }
                            }

                            var i;
                            if (dir) {
                                var foundIndex = -1;
                                for (i = byteOffset; i < arrLength; i++) {
                                    if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                                        if (foundIndex === -1) foundIndex = i;
                                        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
                                    } else {
                                        if (foundIndex !== -1) i -= i - foundIndex;
                                        foundIndex = -1;
                                    }
                                }
                            } else {
                                if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
                                for (i = byteOffset; i >= 0; i--) {
                                    var found = true;
                                    for (var j = 0; j < valLength; j++) {
                                        if (read(arr, i + j) !== read(val, j)) {
                                            found = false;
                                            break
                                        }
                                    }
                                    if (found) return i
                                }
                            }

                            return -1
                        }

                        Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
                            return this.indexOf(val, byteOffset, encoding) !== -1
                        };

                        Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
                            return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
                        };

                        Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
                            return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
                        };

                        function hexWrite (buf, string, offset, length) {
                            offset = Number(offset) || 0;
                            var remaining = buf.length - offset;
                            if (!length) {
                                length = remaining;
                            } else {
                                length = Number(length);
                                if (length > remaining) {
                                    length = remaining;
                                }
                            }

                            // must be an even number of digits
                            var strLen = string.length;
                            if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

                            if (length > strLen / 2) {
                                length = strLen / 2;
                            }
                            for (var i = 0; i < length; ++i) {
                                var parsed = parseInt(string.substr(i * 2, 2), 16);
                                if (isNaN(parsed)) return i
                                buf[offset + i] = parsed;
                            }
                            return i
                        }

                        function utf8Write (buf, string, offset, length) {
                            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
                        }

                        function asciiWrite (buf, string, offset, length) {
                            return blitBuffer(asciiToBytes(string), buf, offset, length)
                        }

                        function latin1Write (buf, string, offset, length) {
                            return asciiWrite(buf, string, offset, length)
                        }

                        function base64Write (buf, string, offset, length) {
                            return blitBuffer(base64ToBytes(string), buf, offset, length)
                        }

                        function ucs2Write (buf, string, offset, length) {
                            return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
                        }

                        Buffer.prototype.write = function write (string, offset, length, encoding) {
                            // Buffer#write(string)
                            if (offset === undefined) {
                                encoding = 'utf8';
                                length = this.length;
                                offset = 0;
                                // Buffer#write(string, encoding)
                            } else if (length === undefined && typeof offset === 'string') {
                                encoding = offset;
                                length = this.length;
                                offset = 0;
                                // Buffer#write(string, offset[, length][, encoding])
                            } else if (isFinite(offset)) {
                                offset = offset | 0;
                                if (isFinite(length)) {
                                    length = length | 0;
                                    if (encoding === undefined) encoding = 'utf8';
                                } else {
                                    encoding = length;
                                    length = undefined;
                                }
                                // legacy write(string, encoding, offset, length) - remove in v0.13
                            } else {
                                throw new Error(
                                    'Buffer.write(string, encoding, offset[, length]) is no longer supported'
                                )
                            }

                            var remaining = this.length - offset;
                            if (length === undefined || length > remaining) length = remaining;

                            if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
                                throw new RangeError('Attempt to write outside buffer bounds')
                            }

                            if (!encoding) encoding = 'utf8';

                            var loweredCase = false;
                            for (;;) {
                                switch (encoding) {
                                    case 'hex':
                                        return hexWrite(this, string, offset, length)

                                    case 'utf8':
                                    case 'utf-8':
                                        return utf8Write(this, string, offset, length)

                                    case 'ascii':
                                        return asciiWrite(this, string, offset, length)

                                    case 'latin1':
                                    case 'binary':
                                        return latin1Write(this, string, offset, length)

                                    case 'base64':
                                        // Warning: maxLength not taken into account in base64Write
                                        return base64Write(this, string, offset, length)

                                    case 'ucs2':
                                    case 'ucs-2':
                                    case 'utf16le':
                                    case 'utf-16le':
                                        return ucs2Write(this, string, offset, length)

                                    default:
                                        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                                        encoding = ('' + encoding).toLowerCase();
                                        loweredCase = true;
                                }
                            }
                        };

                        Buffer.prototype.toJSON = function toJSON () {
                            return {
                                type: 'Buffer',
                                data: Array.prototype.slice.call(this._arr || this, 0)
                            }
                        };

                        function base64Slice (buf, start, end) {
                            if (start === 0 && end === buf.length) {
                                return base64.fromByteArray(buf)
                            } else {
                                return base64.fromByteArray(buf.slice(start, end))
                            }
                        }

                        function utf8Slice (buf, start, end) {
                            end = Math.min(buf.length, end);
                            var res = [];

                            var i = start;
                            while (i < end) {
                                var firstByte = buf[i];
                                var codePoint = null;
                                var bytesPerSequence = (firstByte > 0xEF) ? 4
                                    : (firstByte > 0xDF) ? 3
                                        : (firstByte > 0xBF) ? 2
                                            : 1;

                                if (i + bytesPerSequence <= end) {
                                    var secondByte, thirdByte, fourthByte, tempCodePoint;

                                    switch (bytesPerSequence) {
                                        case 1:
                                            if (firstByte < 0x80) {
                                                codePoint = firstByte;
                                            }
                                            break
                                        case 2:
                                            secondByte = buf[i + 1];
                                            if ((secondByte & 0xC0) === 0x80) {
                                                tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
                                                if (tempCodePoint > 0x7F) {
                                                    codePoint = tempCodePoint;
                                                }
                                            }
                                            break
                                        case 3:
                                            secondByte = buf[i + 1];
                                            thirdByte = buf[i + 2];
                                            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                                                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
                                                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                                                    codePoint = tempCodePoint;
                                                }
                                            }
                                            break
                                        case 4:
                                            secondByte = buf[i + 1];
                                            thirdByte = buf[i + 2];
                                            fourthByte = buf[i + 3];
                                            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                                                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
                                                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                                                    codePoint = tempCodePoint;
                                                }
                                            }
                                    }
                                }

                                if (codePoint === null) {
                                    // we did not generate a valid codePoint so insert a
                                    // replacement char (U+FFFD) and advance only 1 byte
                                    codePoint = 0xFFFD;
                                    bytesPerSequence = 1;
                                } else if (codePoint > 0xFFFF) {
                                    // encode to utf16 (surrogate pair dance)
                                    codePoint -= 0x10000;
                                    res.push(codePoint >>> 10 & 0x3FF | 0xD800);
                                    codePoint = 0xDC00 | codePoint & 0x3FF;
                                }

                                res.push(codePoint);
                                i += bytesPerSequence;
                            }

                            return decodeCodePointsArray(res)
                        }

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
                        var MAX_ARGUMENTS_LENGTH = 0x1000;

                        function decodeCodePointsArray (codePoints) {
                            var len = codePoints.length;
                            if (len <= MAX_ARGUMENTS_LENGTH) {
                                return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
                            }

                            // Decode in chunks to avoid "call stack size exceeded".
                            var res = '';
                            var i = 0;
                            while (i < len) {
                                res += String.fromCharCode.apply(
                                    String,
                                    codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
                                );
                            }
                            return res
                        }

                        function asciiSlice (buf, start, end) {
                            var ret = '';
                            end = Math.min(buf.length, end);

                            for (var i = start; i < end; ++i) {
                                ret += String.fromCharCode(buf[i] & 0x7F);
                            }
                            return ret
                        }

                        function latin1Slice (buf, start, end) {
                            var ret = '';
                            end = Math.min(buf.length, end);

                            for (var i = start; i < end; ++i) {
                                ret += String.fromCharCode(buf[i]);
                            }
                            return ret
                        }

                        function hexSlice (buf, start, end) {
                            var len = buf.length;

                            if (!start || start < 0) start = 0;
                            if (!end || end < 0 || end > len) end = len;

                            var out = '';
                            for (var i = start; i < end; ++i) {
                                out += toHex(buf[i]);
                            }
                            return out
                        }

                        function utf16leSlice (buf, start, end) {
                            var bytes = buf.slice(start, end);
                            var res = '';
                            for (var i = 0; i < bytes.length; i += 2) {
                                res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
                            }
                            return res
                        }

                        Buffer.prototype.slice = function slice (start, end) {
                            var len = this.length;
                            start = ~~start;
                            end = end === undefined ? len : ~~end;

                            if (start < 0) {
                                start += len;
                                if (start < 0) start = 0;
                            } else if (start > len) {
                                start = len;
                            }

                            if (end < 0) {
                                end += len;
                                if (end < 0) end = 0;
                            } else if (end > len) {
                                end = len;
                            }

                            if (end < start) end = start;

                            var newBuf;
                            if (Buffer.TYPED_ARRAY_SUPPORT) {
                                newBuf = this.subarray(start, end);
                                newBuf.__proto__ = Buffer.prototype;
                            } else {
                                var sliceLen = end - start;
                                newBuf = new Buffer(sliceLen, undefined);
                                for (var i = 0; i < sliceLen; ++i) {
                                    newBuf[i] = this[i + start];
                                }
                            }

                            return newBuf
                        };

                        /*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
                        function checkOffset (offset, ext, length) {
                            if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
                            if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
                        }

                        Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
                            offset = offset | 0;
                            byteLength = byteLength | 0;
                            if (!noAssert) checkOffset(offset, byteLength, this.length);

                            var val = this[offset];
                            var mul = 1;
                            var i = 0;
                            while (++i < byteLength && (mul *= 0x100)) {
                                val += this[offset + i] * mul;
                            }

                            return val
                        };

                        Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
                            offset = offset | 0;
                            byteLength = byteLength | 0;
                            if (!noAssert) {
                                checkOffset(offset, byteLength, this.length);
                            }

                            var val = this[offset + --byteLength];
                            var mul = 1;
                            while (byteLength > 0 && (mul *= 0x100)) {
                                val += this[offset + --byteLength] * mul;
                            }

                            return val
                        };

                        Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
                            if (!noAssert) checkOffset(offset, 1, this.length);
                            return this[offset]
                        };

                        Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
                            if (!noAssert) checkOffset(offset, 2, this.length);
                            return this[offset] | (this[offset + 1] << 8)
                        };

                        Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
                            if (!noAssert) checkOffset(offset, 2, this.length);
                            return (this[offset] << 8) | this[offset + 1]
                        };

                        Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
                            if (!noAssert) checkOffset(offset, 4, this.length);

                            return ((this[offset]) |
                                    (this[offset + 1] << 8) |
                                    (this[offset + 2] << 16)) +
                                (this[offset + 3] * 0x1000000)
                        };

                        Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
                            if (!noAssert) checkOffset(offset, 4, this.length);

                            return (this[offset] * 0x1000000) +
                                ((this[offset + 1] << 16) |
                                    (this[offset + 2] << 8) |
                                    this[offset + 3])
                        };

                        Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
                            offset = offset | 0;
                            byteLength = byteLength | 0;
                            if (!noAssert) checkOffset(offset, byteLength, this.length);

                            var val = this[offset];
                            var mul = 1;
                            var i = 0;
                            while (++i < byteLength && (mul *= 0x100)) {
                                val += this[offset + i] * mul;
                            }
                            mul *= 0x80;

                            if (val >= mul) val -= Math.pow(2, 8 * byteLength);

                            return val
                        };

                        Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
                            offset = offset | 0;
                            byteLength = byteLength | 0;
                            if (!noAssert) checkOffset(offset, byteLength, this.length);

                            var i = byteLength;
                            var mul = 1;
                            var val = this[offset + --i];
                            while (i > 0 && (mul *= 0x100)) {
                                val += this[offset + --i] * mul;
                            }
                            mul *= 0x80;

                            if (val >= mul) val -= Math.pow(2, 8 * byteLength);

                            return val
                        };

                        Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
                            if (!noAssert) checkOffset(offset, 1, this.length);
                            if (!(this[offset] & 0x80)) return (this[offset])
                            return ((0xff - this[offset] + 1) * -1)
                        };

                        Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
                            if (!noAssert) checkOffset(offset, 2, this.length);
                            var val = this[offset] | (this[offset + 1] << 8);
                            return (val & 0x8000) ? val | 0xFFFF0000 : val
                        };

                        Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
                            if (!noAssert) checkOffset(offset, 2, this.length);
                            var val = this[offset + 1] | (this[offset] << 8);
                            return (val & 0x8000) ? val | 0xFFFF0000 : val
                        };

                        Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
                            if (!noAssert) checkOffset(offset, 4, this.length);

                            return (this[offset]) |
                                (this[offset + 1] << 8) |
                                (this[offset + 2] << 16) |
                                (this[offset + 3] << 24)
                        };

                        Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
                            if (!noAssert) checkOffset(offset, 4, this.length);

                            return (this[offset] << 24) |
                                (this[offset + 1] << 16) |
                                (this[offset + 2] << 8) |
                                (this[offset + 3])
                        };

                        Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
                            if (!noAssert) checkOffset(offset, 4, this.length);
                            return ieee754.read(this, offset, true, 23, 4)
                        };

                        Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
                            if (!noAssert) checkOffset(offset, 4, this.length);
                            return ieee754.read(this, offset, false, 23, 4)
                        };

                        Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
                            if (!noAssert) checkOffset(offset, 8, this.length);
                            return ieee754.read(this, offset, true, 52, 8)
                        };

                        Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
                            if (!noAssert) checkOffset(offset, 8, this.length);
                            return ieee754.read(this, offset, false, 52, 8)
                        };

                        function checkInt (buf, value, offset, ext, max, min) {
                            if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
                            if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
                            if (offset + ext > buf.length) throw new RangeError('Index out of range')
                        }

                        Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
                            value = +value;
                            offset = offset | 0;
                            byteLength = byteLength | 0;
                            if (!noAssert) {
                                var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                                checkInt(this, value, offset, byteLength, maxBytes, 0);
                            }

                            var mul = 1;
                            var i = 0;
                            this[offset] = value & 0xFF;
                            while (++i < byteLength && (mul *= 0x100)) {
                                this[offset + i] = (value / mul) & 0xFF;
                            }

                            return offset + byteLength
                        };

                        Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
                            value = +value;
                            offset = offset | 0;
                            byteLength = byteLength | 0;
                            if (!noAssert) {
                                var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                                checkInt(this, value, offset, byteLength, maxBytes, 0);
                            }

                            var i = byteLength - 1;
                            var mul = 1;
                            this[offset + i] = value & 0xFF;
                            while (--i >= 0 && (mul *= 0x100)) {
                                this[offset + i] = (value / mul) & 0xFF;
                            }

                            return offset + byteLength
                        };

                        Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
                            value = +value;
                            offset = offset | 0;
                            if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
                            if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
                            this[offset] = (value & 0xff);
                            return offset + 1
                        };

                        function objectWriteUInt16 (buf, value, offset, littleEndian) {
                            if (value < 0) value = 0xffff + value + 1;
                            for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
                                buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
                                    (littleEndian ? i : 1 - i) * 8;
                            }
                        }

                        Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
                            value = +value;
                            offset = offset | 0;
                            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
                            if (Buffer.TYPED_ARRAY_SUPPORT) {
                                this[offset] = (value & 0xff);
                                this[offset + 1] = (value >>> 8);
                            } else {
                                objectWriteUInt16(this, value, offset, true);
                            }
                            return offset + 2
                        };

                        Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
                            value = +value;
                            offset = offset | 0;
                            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
                            if (Buffer.TYPED_ARRAY_SUPPORT) {
                                this[offset] = (value >>> 8);
                                this[offset + 1] = (value & 0xff);
                            } else {
                                objectWriteUInt16(this, value, offset, false);
                            }
                            return offset + 2
                        };

                        function objectWriteUInt32 (buf, value, offset, littleEndian) {
                            if (value < 0) value = 0xffffffff + value + 1;
                            for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
                                buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
                            }
                        }

                        Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
                            value = +value;
                            offset = offset | 0;
                            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
                            if (Buffer.TYPED_ARRAY_SUPPORT) {
                                this[offset + 3] = (value >>> 24);
                                this[offset + 2] = (value >>> 16);
                                this[offset + 1] = (value >>> 8);
                                this[offset] = (value & 0xff);
                            } else {
                                objectWriteUInt32(this, value, offset, true);
                            }
                            return offset + 4
                        };

                        Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
                            value = +value;
                            offset = offset | 0;
                            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
                            if (Buffer.TYPED_ARRAY_SUPPORT) {
                                this[offset] = (value >>> 24);
                                this[offset + 1] = (value >>> 16);
                                this[offset + 2] = (value >>> 8);
                                this[offset + 3] = (value & 0xff);
                            } else {
                                objectWriteUInt32(this, value, offset, false);
                            }
                            return offset + 4
                        };

                        Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
                            value = +value;
                            offset = offset | 0;
                            if (!noAssert) {
                                var limit = Math.pow(2, 8 * byteLength - 1);

                                checkInt(this, value, offset, byteLength, limit - 1, -limit);
                            }

                            var i = 0;
                            var mul = 1;
                            var sub = 0;
                            this[offset] = value & 0xFF;
                            while (++i < byteLength && (mul *= 0x100)) {
                                if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                                    sub = 1;
                                }
                                this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
                            }

                            return offset + byteLength
                        };

                        Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
                            value = +value;
                            offset = offset | 0;
                            if (!noAssert) {
                                var limit = Math.pow(2, 8 * byteLength - 1);

                                checkInt(this, value, offset, byteLength, limit - 1, -limit);
                            }

                            var i = byteLength - 1;
                            var mul = 1;
                            var sub = 0;
                            this[offset + i] = value & 0xFF;
                            while (--i >= 0 && (mul *= 0x100)) {
                                if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                                    sub = 1;
                                }
                                this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
                            }

                            return offset + byteLength
                        };

                        Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
                            value = +value;
                            offset = offset | 0;
                            if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
                            if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
                            if (value < 0) value = 0xff + value + 1;
                            this[offset] = (value & 0xff);
                            return offset + 1
                        };

                        Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
                            value = +value;
                            offset = offset | 0;
                            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
                            if (Buffer.TYPED_ARRAY_SUPPORT) {
                                this[offset] = (value & 0xff);
                                this[offset + 1] = (value >>> 8);
                            } else {
                                objectWriteUInt16(this, value, offset, true);
                            }
                            return offset + 2
                        };

                        Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
                            value = +value;
                            offset = offset | 0;
                            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
                            if (Buffer.TYPED_ARRAY_SUPPORT) {
                                this[offset] = (value >>> 8);
                                this[offset + 1] = (value & 0xff);
                            } else {
                                objectWriteUInt16(this, value, offset, false);
                            }
                            return offset + 2
                        };

                        Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
                            value = +value;
                            offset = offset | 0;
                            if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
                            if (Buffer.TYPED_ARRAY_SUPPORT) {
                                this[offset] = (value & 0xff);
                                this[offset + 1] = (value >>> 8);
                                this[offset + 2] = (value >>> 16);
                                this[offset + 3] = (value >>> 24);
                            } else {
                                objectWriteUInt32(this, value, offset, true);
                            }
                            return offset + 4
                        };

                        Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
                            value = +value;
                            offset = offset | 0;
                            if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
                            if (value < 0) value = 0xffffffff + value + 1;
                            if (Buffer.TYPED_ARRAY_SUPPORT) {
                                this[offset] = (value >>> 24);
                                this[offset + 1] = (value >>> 16);
                                this[offset + 2] = (value >>> 8);
                                this[offset + 3] = (value & 0xff);
                            } else {
                                objectWriteUInt32(this, value, offset, false);
                            }
                            return offset + 4
                        };

                        function checkIEEE754 (buf, value, offset, ext, max, min) {
                            if (offset + ext > buf.length) throw new RangeError('Index out of range')
                            if (offset < 0) throw new RangeError('Index out of range')
                        }

                        function writeFloat (buf, value, offset, littleEndian, noAssert) {
                            if (!noAssert) {
                                checkIEEE754(buf, value, offset, 4);
                            }
                            ieee754.write(buf, value, offset, littleEndian, 23, 4);
                            return offset + 4
                        }

                        Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
                            return writeFloat(this, value, offset, true, noAssert)
                        };

                        Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
                            return writeFloat(this, value, offset, false, noAssert)
                        };

                        function writeDouble (buf, value, offset, littleEndian, noAssert) {
                            if (!noAssert) {
                                checkIEEE754(buf, value, offset, 8);
                            }
                            ieee754.write(buf, value, offset, littleEndian, 52, 8);
                            return offset + 8
                        }

                        Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
                            return writeDouble(this, value, offset, true, noAssert)
                        };

                        Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
                            return writeDouble(this, value, offset, false, noAssert)
                        };

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
                        Buffer.prototype.copy = function copy (target, targetStart, start, end) {
                            if (!start) start = 0;
                            if (!end && end !== 0) end = this.length;
                            if (targetStart >= target.length) targetStart = target.length;
                            if (!targetStart) targetStart = 0;
                            if (end > 0 && end < start) end = start;

                            // Copy 0 bytes; we're done
                            if (end === start) return 0
                            if (target.length === 0 || this.length === 0) return 0

                            // Fatal error conditions
                            if (targetStart < 0) {
                                throw new RangeError('targetStart out of bounds')
                            }
                            if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
                            if (end < 0) throw new RangeError('sourceEnd out of bounds')

                            // Are we oob?
                            if (end > this.length) end = this.length;
                            if (target.length - targetStart < end - start) {
                                end = target.length - targetStart + start;
                            }

                            var len = end - start;
                            var i;

                            if (this === target && start < targetStart && targetStart < end) {
                                // descending copy from end
                                for (i = len - 1; i >= 0; --i) {
                                    target[i + targetStart] = this[i + start];
                                }
                            } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
                                // ascending copy from start
                                for (i = 0; i < len; ++i) {
                                    target[i + targetStart] = this[i + start];
                                }
                            } else {
                                Uint8Array.prototype.set.call(
                                    target,
                                    this.subarray(start, start + len),
                                    targetStart
                                );
                            }

                            return len
                        };

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
                        Buffer.prototype.fill = function fill (val, start, end, encoding) {
                            // Handle string cases:
                            if (typeof val === 'string') {
                                if (typeof start === 'string') {
                                    encoding = start;
                                    start = 0;
                                    end = this.length;
                                } else if (typeof end === 'string') {
                                    encoding = end;
                                    end = this.length;
                                }
                                if (val.length === 1) {
                                    var code = val.charCodeAt(0);
                                    if (code < 256) {
                                        val = code;
                                    }
                                }
                                if (encoding !== undefined && typeof encoding !== 'string') {
                                    throw new TypeError('encoding must be a string')
                                }
                                if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
                                    throw new TypeError('Unknown encoding: ' + encoding)
                                }
                            } else if (typeof val === 'number') {
                                val = val & 255;
                            }

                            // Invalid ranges are not set to a default, so can range check early.
                            if (start < 0 || this.length < start || this.length < end) {
                                throw new RangeError('Out of range index')
                            }

                            if (end <= start) {
                                return this
                            }

                            start = start >>> 0;
                            end = end === undefined ? this.length : end >>> 0;

                            if (!val) val = 0;

                            var i;
                            if (typeof val === 'number') {
                                for (i = start; i < end; ++i) {
                                    this[i] = val;
                                }
                            } else {
                                var bytes = Buffer.isBuffer(val)
                                    ? val
                                    : utf8ToBytes(new Buffer(val, encoding).toString());
                                var len = bytes.length;
                                for (i = 0; i < end - start; ++i) {
                                    this[i + start] = bytes[i % len];
                                }
                            }

                            return this
                        };

// HELPER FUNCTIONS
// ================

                        var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

                        function base64clean (str) {
                            // Node strips out invalid characters like \n and \t from the string, base64-js does not
                            str = stringtrim(str).replace(INVALID_BASE64_RE, '');
                            // Node converts strings with length < 2 to ''
                            if (str.length < 2) return ''
                            // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
                            while (str.length % 4 !== 0) {
                                str = str + '=';
                            }
                            return str
                        }

                        function stringtrim (str) {
                            if (str.trim) return str.trim()
                            return str.replace(/^\s+|\s+$/g, '')
                        }

                        function toHex (n) {
                            if (n < 16) return '0' + n.toString(16)
                            return n.toString(16)
                        }

                        function utf8ToBytes (string, units) {
                            units = units || Infinity;
                            var codePoint;
                            var length = string.length;
                            var leadSurrogate = null;
                            var bytes = [];

                            for (var i = 0; i < length; ++i) {
                                codePoint = string.charCodeAt(i);

                                // is surrogate component
                                if (codePoint > 0xD7FF && codePoint < 0xE000) {
                                    // last char was a lead
                                    if (!leadSurrogate) {
                                        // no lead yet
                                        if (codePoint > 0xDBFF) {
                                            // unexpected trail
                                            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                                            continue
                                        } else if (i + 1 === length) {
                                            // unpaired lead
                                            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                                            continue
                                        }

                                        // valid lead
                                        leadSurrogate = codePoint;

                                        continue
                                    }

                                    // 2 leads in a row
                                    if (codePoint < 0xDC00) {
                                        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                                        leadSurrogate = codePoint;
                                        continue
                                    }

                                    // valid surrogate pair
                                    codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
                                } else if (leadSurrogate) {
                                    // valid bmp char, but last char was a lead
                                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                                }

                                leadSurrogate = null;

                                // encode utf8
                                if (codePoint < 0x80) {
                                    if ((units -= 1) < 0) break
                                    bytes.push(codePoint);
                                } else if (codePoint < 0x800) {
                                    if ((units -= 2) < 0) break
                                    bytes.push(
                                        codePoint >> 0x6 | 0xC0,
                                        codePoint & 0x3F | 0x80
                                    );
                                } else if (codePoint < 0x10000) {
                                    if ((units -= 3) < 0) break
                                    bytes.push(
                                        codePoint >> 0xC | 0xE0,
                                        codePoint >> 0x6 & 0x3F | 0x80,
                                        codePoint & 0x3F | 0x80
                                    );
                                } else if (codePoint < 0x110000) {
                                    if ((units -= 4) < 0) break
                                    bytes.push(
                                        codePoint >> 0x12 | 0xF0,
                                        codePoint >> 0xC & 0x3F | 0x80,
                                        codePoint >> 0x6 & 0x3F | 0x80,
                                        codePoint & 0x3F | 0x80
                                    );
                                } else {
                                    throw new Error('Invalid code point')
                                }
                            }

                            return bytes
                        }

                        function asciiToBytes (str) {
                            var byteArray = [];
                            for (var i = 0; i < str.length; ++i) {
                                // Node's code seems to be doing this and not & 0x7F..
                                byteArray.push(str.charCodeAt(i) & 0xFF);
                            }
                            return byteArray
                        }

                        function utf16leToBytes (str, units) {
                            var c, hi, lo;
                            var byteArray = [];
                            for (var i = 0; i < str.length; ++i) {
                                if ((units -= 2) < 0) break

                                c = str.charCodeAt(i);
                                hi = c >> 8;
                                lo = c % 256;
                                byteArray.push(lo);
                                byteArray.push(hi);
                            }

                            return byteArray
                        }

                        function base64ToBytes (str) {
                            return base64.toByteArray(base64clean(str))
                        }

                        function blitBuffer (src, dst, offset, length) {
                            for (var i = 0; i < length; ++i) {
                                if ((i + offset >= dst.length) || (i >= src.length)) break
                                dst[i + offset] = src[i];
                            }
                            return i
                        }

                        function isnan (val) {
                            return val !== val // eslint-disable-line no-self-compare
                        }

                        /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)));

                    /***/ }),
                /* 4 */
                /***/ (function(module, exports, __webpack_require__) {


// Load modules

                    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

                    var Hoek = __webpack_require__(0);
                    var Ref = __webpack_require__(1);

                    exports.schema = function (Joi, config) {

                        if (config !== undefined && config !== null && (typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object') {

                            if (config.isJoi) {
                                return config;
                            }

                            if (Array.isArray(config)) {
                                return Joi.alternatives().try(config);
                            }

                            if (config instanceof RegExp) {
                                return Joi.string().regex(config);
                            }

                            if (config instanceof Date) {
                                return Joi.date().valid(config);
                            }

                            return Joi.object().keys(config);
                        }

                        if (typeof config === 'string') {
                            return Joi.string().valid(config);
                        }

                        if (typeof config === 'number') {
                            return Joi.number().valid(config);
                        }

                        if (typeof config === 'boolean') {
                            return Joi.boolean().valid(config);
                        }

                        if (Ref.isRef(config)) {
                            return Joi.valid(config);
                        }

                        Hoek.assert(config === null, 'Invalid schema content:', config);

                        return Joi.valid(null);
                    };

                    exports.ref = function (id) {

                        return Ref.isRef(id) ? id : Ref.create(id);
                    };

                    /***/ }),
                /* 5 */
                /***/ (function(module, exports) {

                    var g;

// This works in non-strict mode
                    g = (function() {
                        return this;
                    })();

                    try {
                        // This works if eval is allowed (see CSP)
                        g = g || Function("return this")() || (1,eval)("this");
                    } catch(e) {
                        // This works if the window reference is available
                        if(typeof window === "object")
                            g = window;
                    }

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

                    module.exports = g;


                    /***/ }),
                /* 6 */
                /***/ (function(module, exports, __webpack_require__) {


// Load modules

                    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

                    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

                    var Hoek = __webpack_require__(0);
                    var Language = __webpack_require__(20);

// Declare internals

                    var internals = {
                        annotations: Symbol('joi-annotations')
                    };

                    internals.stringify = function (value, wrapArrays) {

                        var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);

                        if (value === null) {
                            return 'null';
                        }

                        if (type === 'string') {
                            return value;
                        }

                        if (value instanceof exports.Err || type === 'function' || type === 'symbol') {
                            return value.toString();
                        }

                        if (type === 'object') {
                            if (Array.isArray(value)) {
                                var partial = '';

                                for (var i = 0; i < value.length; ++i) {
                                    partial = partial + (partial.length ? ', ' : '') + internals.stringify(value[i], wrapArrays);
                                }

                                return wrapArrays ? '[' + partial + ']' : partial;
                            }

                            return value.toString();
                        }

                        return JSON.stringify(value);
                    };

                    exports.Err = function () {
                        function _class(type, context, state, options, flags, message, template) {
                            _classCallCheck(this, _class);

                            this.isJoi = true;
                            this.type = type;
                            this.context = context || {};
                            this.context.key = state.path[state.path.length - 1];
                            this.context.label = state.key;
                            this.path = state.path;
                            this.options = options;
                            this.flags = flags;
                            this.message = message;
                            this.template = template;

                            var localized = this.options.language;

                            if (this.flags.label) {
                                this.context.label = this.flags.label;
                            } else if (localized && ( // language can be null for arrays exclusion check
                                this.context.label === '' || this.context.label === null)) {
                                this.context.label = localized.root || Language.errors.root;
                            }
                        }

                        _class.prototype.toString = function toString() {
                            var _this = this;

                            if (this.message) {
                                return this.message;
                            }

                            var format = void 0;

                            if (this.template) {
                                format = this.template;
                            }

                            var localized = this.options.language;

                            format = format || Hoek.reach(localized, this.type) || Hoek.reach(Language.errors, this.type);

                            if (format === undefined) {
                                return 'Error code "' + this.type + '" is not defined, your custom type is missing the correct language definition';
                            }

                            var wrapArrays = Hoek.reach(localized, 'messages.wrapArrays');
                            if (typeof wrapArrays !== 'boolean') {
                                wrapArrays = Language.errors.messages.wrapArrays;
                            }

                            if (format === null) {
                                var childrenString = internals.stringify(this.context.reason, wrapArrays);
                                if (wrapArrays) {
                                    return childrenString.slice(1, -1);
                                }
                                return childrenString;
                            }

                            var hasKey = /\{\{\!?label\}\}/.test(format);
                            var skipKey = format.length > 2 && format[0] === '!' && format[1] === '!';

                            if (skipKey) {
                                format = format.slice(2);
                            }

                            if (!hasKey && !skipKey) {
                                var localizedKey = Hoek.reach(localized, 'key');
                                if (typeof localizedKey === 'string') {
                                    format = localizedKey + format;
                                } else {
                                    format = Hoek.reach(Language.errors, 'key') + format;
                                }
                            }

                            return format.replace(/\{\{(\!?)([^}]+)\}\}/g, function ($0, isSecure, name) {

                                var value = Hoek.reach(_this.context, name);
                                var normalized = internals.stringify(value, wrapArrays);
                                return isSecure && _this.options.escapeHtml ? Hoek.escapeHtml(normalized) : normalized;
                            });
                        };

                        return _class;
                    }();

                    exports.create = function (type, context, state, options, flags, message, template) {

                        return new exports.Err(type, context, state, options, flags, message, template);
                    };

                    exports.process = function (errors, object) {

                        if (!errors || !errors.length) {
                            return null;
                        }

                        // Construct error

                        var message = '';
                        var details = [];

                        var processErrors = function processErrors(localErrors, parent) {

                            for (var i = 0; i < localErrors.length; ++i) {
                                var item = localErrors[i];

                                if (item instanceof Error) {
                                    return item;
                                }

                                if (item.flags.error && typeof item.flags.error !== 'function') {
                                    return item.flags.error;
                                }

                                var itemMessage = void 0;
                                if (parent === undefined) {
                                    itemMessage = item.toString();
                                    message = message + (message ? '. ' : '') + itemMessage;
                                }

                                // Do not push intermediate errors, we're only interested in leafs

                                if (item.context.reason && item.context.reason.length) {
                                    var _override = processErrors(item.context.reason, item.path);
                                    if (_override) {
                                        return _override;
                                    }
                                } else {
                                    details.push({
                                        message: itemMessage || item.toString(),
                                        path: item.path,
                                        type: item.type,
                                        context: item.context
                                    });
                                }
                            }
                        };

                        var override = processErrors(errors);
                        if (override) {
                            return override;
                        }

                        var error = new Error(message);
                        error.isJoi = true;
                        error.name = 'ValidationError';
                        error.details = details;
                        error._object = object;
                        error.annotate = internals.annotate;
                        return error;
                    };

// Inspired by json-stringify-safe
                    internals.safeStringify = function (obj, spaces) {

                        return JSON.stringify(obj, internals.serializer(), spaces);
                    };

                    internals.serializer = function () {

                        var keys = [];
                        var stack = [];

                        var cycleReplacer = function cycleReplacer(key, value) {

                            if (stack[0] === value) {
                                return '[Circular ~]';
                            }

                            return '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']';
                        };

                        return function (key, value) {

                            if (stack.length > 0) {
                                var thisPos = stack.indexOf(this);
                                if (~thisPos) {
                                    stack.length = thisPos + 1;
                                    keys.length = thisPos + 1;
                                    keys[thisPos] = key;
                                } else {
                                    stack.push(this);
                                    keys.push(key);
                                }

                                if (~stack.indexOf(value)) {
                                    value = cycleReplacer.call(this, key, value);
                                }
                            } else {
                                stack.push(value);
                            }

                            if (value) {
                                var annotations = value[internals.annotations];
                                if (annotations) {
                                    if (Array.isArray(value)) {
                                        var annotated = [];

                                        for (var i = 0; i < value.length; ++i) {
                                            if (annotations.errors[i]) {
                                                annotated.push('_$idx$_' + annotations.errors[i].sort().join(', ') + '_$end$_');
                                            }
                                            annotated.push(value[i]);
                                        }

                                        value = annotated;
                                    } else {
                                        var errorKeys = Object.keys(annotations.errors);
                                        for (var _i = 0; _i < errorKeys.length; ++_i) {
                                            var errorKey = errorKeys[_i];
                                            value[errorKey + '_$key$_' + annotations.errors[errorKey].sort().join(', ') + '_$end$_'] = value[errorKey];
                                            value[errorKey] = undefined;
                                        }

                                        var missingKeys = Object.keys(annotations.missing);
                                        for (var _i2 = 0; _i2 < missingKeys.length; ++_i2) {
                                            var missingKey = missingKeys[_i2];
                                            value['_$miss$_' + missingKey + '|' + annotations.missing[missingKey] + '_$end$_'] = '__missing__';
                                        }
                                    }

                                    return value;
                                }
                            }

                            if (value === Infinity || value === -Infinity || Number.isNaN(value) || typeof value === 'function' || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'symbol') {
                                return '[' + value.toString() + ']';
                            }

                            return value;
                        };
                    };

                    internals.annotate = function (stripColorCodes) {

                        var redFgEscape = stripColorCodes ? '' : '\x1B[31m';
                        var redBgEscape = stripColorCodes ? '' : '\x1B[41m';
                        var endColor = stripColorCodes ? '' : '\x1B[0m';

                        if (_typeof(this._object) !== 'object') {
                            return this.details[0].message;
                        }

                        var obj = Hoek.clone(this._object || {});

                        for (var i = this.details.length - 1; i >= 0; --i) {
                            // Reverse order to process deepest child first
                            var pos = i + 1;
                            var error = this.details[i];
                            var path = error.path;
                            var ref = obj;
                            for (var j = 0;; ++j) {
                                var seg = path[j];

                                if (ref.isImmutable) {
                                    ref = ref.clone(); // joi schemas are not cloned by hoek, we have to take this extra step
                                }

                                if (j + 1 < path.length && ref[seg] && typeof ref[seg] !== 'string') {

                                    ref = ref[seg];
                                } else {
                                    var refAnnotations = ref[internals.annotations] = ref[internals.annotations] || { errors: {}, missing: {} };
                                    var value = ref[seg];
                                    var cacheKey = seg || error.context.label;

                                    if (value !== undefined) {
                                        refAnnotations.errors[cacheKey] = refAnnotations.errors[cacheKey] || [];
                                        refAnnotations.errors[cacheKey].push(pos);
                                    } else {
                                        refAnnotations.missing[cacheKey] = pos;
                                    }

                                    break;
                                }
                            }
                        }

                        var replacers = {
                            key: /_\$key\$_([, \d]+)_\$end\$_\"/g,
                            missing: /\"_\$miss\$_([^\|]+)\|(\d+)_\$end\$_\"\: \"__missing__\"/g,
                            arrayIndex: /\s*\"_\$idx\$_([, \d]+)_\$end\$_\",?\n(.*)/g,
                            specials: /"\[(NaN|Symbol.*|-?Infinity|function.*|\(.*)\]"/g
                        };

                        var message = internals.safeStringify(obj, 2).replace(replacers.key, function ($0, $1) {
                            return '" ' + redFgEscape + '[' + $1 + ']' + endColor;
                        }).replace(replacers.missing, function ($0, $1, $2) {
                            return redBgEscape + '"' + $1 + '"' + endColor + redFgEscape + ' [' + $2 + ']: -- missing --' + endColor;
                        }).replace(replacers.arrayIndex, function ($0, $1, $2) {
                            return '\n' + $2 + ' ' + redFgEscape + '[' + $1 + ']' + endColor;
                        }).replace(replacers.specials, function ($0, $1) {
                            return $1;
                        });

                        message = message + '\n' + redFgEscape;

                        for (var _i3 = 0; _i3 < this.details.length; ++_i3) {
                            var _pos = _i3 + 1;
                            message = message + '\n[' + _pos + '] ' + this.details[_i3].message;
                        }

                        message = message + endColor;

                        return message;
                    };

                    /***/ }),
                /* 7 */
                /***/ (function(module, exports) {

// shim for using process in browser
                    var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

                    var cachedSetTimeout;
                    var cachedClearTimeout;

                    function defaultSetTimout() {
                        throw new Error('setTimeout has not been defined');
                    }
                    function defaultClearTimeout () {
                        throw new Error('clearTimeout has not been defined');
                    }
                    (function () {
                        try {
                            if (typeof setTimeout === 'function') {
                                cachedSetTimeout = setTimeout;
                            } else {
                                cachedSetTimeout = defaultSetTimout;
                            }
                        } catch (e) {
                            cachedSetTimeout = defaultSetTimout;
                        }
                        try {
                            if (typeof clearTimeout === 'function') {
                                cachedClearTimeout = clearTimeout;
                            } else {
                                cachedClearTimeout = defaultClearTimeout;
                            }
                        } catch (e) {
                            cachedClearTimeout = defaultClearTimeout;
                        }
                    } ());
                    function runTimeout(fun) {
                        if (cachedSetTimeout === setTimeout) {
                            //normal enviroments in sane situations
                            return setTimeout(fun, 0);
                        }
                        // if setTimeout wasn't available but was latter defined
                        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                            cachedSetTimeout = setTimeout;
                            return setTimeout(fun, 0);
                        }
                        try {
                            // when when somebody has screwed with setTimeout but no I.E. maddness
                            return cachedSetTimeout(fun, 0);
                        } catch(e){
                            try {
                                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                                return cachedSetTimeout.call(null, fun, 0);
                            } catch(e){
                                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                                return cachedSetTimeout.call(this, fun, 0);
                            }
                        }


                    }
                    function runClearTimeout(marker) {
                        if (cachedClearTimeout === clearTimeout) {
                            //normal enviroments in sane situations
                            return clearTimeout(marker);
                        }
                        // if clearTimeout wasn't available but was latter defined
                        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                            cachedClearTimeout = clearTimeout;
                            return clearTimeout(marker);
                        }
                        try {
                            // when when somebody has screwed with setTimeout but no I.E. maddness
                            return cachedClearTimeout(marker);
                        } catch (e){
                            try {
                                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                                return cachedClearTimeout.call(null, marker);
                            } catch (e){
                                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                                return cachedClearTimeout.call(this, marker);
                            }
                        }



                    }
                    var queue = [];
                    var draining = false;
                    var currentQueue;
                    var queueIndex = -1;

                    function cleanUpNextTick() {
                        if (!draining || !currentQueue) {
                            return;
                        }
                        draining = false;
                        if (currentQueue.length) {
                            queue = currentQueue.concat(queue);
                        } else {
                            queueIndex = -1;
                        }
                        if (queue.length) {
                            drainQueue();
                        }
                    }

                    function drainQueue() {
                        if (draining) {
                            return;
                        }
                        var timeout = runTimeout(cleanUpNextTick);
                        draining = true;

                        var len = queue.length;
                        while(len) {
                            currentQueue = queue;
                            queue = [];
                            while (++queueIndex < len) {
                                if (currentQueue) {
                                    currentQueue[queueIndex].run();
                                }
                            }
                            queueIndex = -1;
                            len = queue.length;
                        }
                        currentQueue = null;
                        draining = false;
                        runClearTimeout(timeout);
                    }

                    process.nextTick = function (fun) {
                        var args = new Array(arguments.length - 1);
                        if (arguments.length > 1) {
                            for (var i = 1; i < arguments.length; i++) {
                                args[i - 1] = arguments[i];
                            }
                        }
                        queue.push(new Item(fun, args));
                        if (queue.length === 1 && !draining) {
                            runTimeout(drainQueue);
                        }
                    };

// v8 likes predictible objects
                    function Item(fun, array) {
                        this.fun = fun;
                        this.array = array;
                    }
                    Item.prototype.run = function () {
                        this.fun.apply(null, this.array);
                    };
                    process.title = 'browser';
                    process.browser = true;
                    process.env = {};
                    process.argv = [];
                    process.version = ''; // empty string to avoid regexp issues
                    process.versions = {};

                    function noop() {}

                    process.on = noop;
                    process.addListener = noop;
                    process.once = noop;
                    process.off = noop;
                    process.removeListener = noop;
                    process.removeAllListeners = noop;
                    process.emit = noop;
                    process.prependListener = noop;
                    process.prependOnceListener = noop;

                    process.listeners = function (name) { return [] };

                    process.binding = function (name) {
                        throw new Error('process.binding is not supported');
                    };

                    process.cwd = function () { return '/' };
                    process.chdir = function (dir) {
                        throw new Error('process.chdir is not supported');
                    };
                    process.umask = function() { return 0; };


                    /***/ }),
                /* 8 */
                /***/ (function(module, exports, __webpack_require__) {


// Load modules

                    var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

                    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

                    function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

                    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

                    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

                    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

                    function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

                    var Hoek = __webpack_require__(0);
                    var Any = __webpack_require__(2);
                    var Cast = __webpack_require__(4);
                    var Errors = __webpack_require__(6);
                    var Lazy = __webpack_require__(26);
                    var Ref = __webpack_require__(1);
                    var Settings = __webpack_require__(11);

// Declare internals

                    var internals = {
                        alternatives: __webpack_require__(10),
                        array: __webpack_require__(22),
                        boolean: __webpack_require__(24),
                        binary: __webpack_require__(23),
                        date: __webpack_require__(12),
                        func: __webpack_require__(25),
                        number: __webpack_require__(27),
                        object: __webpack_require__(13),
                        string: __webpack_require__(28)
                    };

                    internals.callWithDefaults = function (schema, args) {
                        var _schema;

                        Hoek.assert(this, 'Must be invoked on a Joi instance.');

                        if (this._defaults) {
                            schema = this._defaults(schema);
                        }

                        schema._currentJoi = this;

                        return (_schema = schema)._init.apply(_schema, _toConsumableArray(args));
                    };

                    internals.root = function () {

                        var any = new Any();

                        var root = any.clone();
                        Any.prototype._currentJoi = root;
                        root._currentJoi = root;

                        root.any = function () {
                            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                                args[_key] = arguments[_key];
                            }

                            Hoek.assert(args.length === 0, 'Joi.any() does not allow arguments.');

                            return internals.callWithDefaults.call(this, any, args);
                        };

                        root.alternatives = root.alt = function () {
                            for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                                args[_key2] = arguments[_key2];
                            }

                            return internals.callWithDefaults.call(this, internals.alternatives, args);
                        };

                        root.array = function () {
                            for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                                args[_key3] = arguments[_key3];
                            }

                            Hoek.assert(args.length === 0, 'Joi.array() does not allow arguments.');

                            return internals.callWithDefaults.call(this, internals.array, args);
                        };

                        root.boolean = root.bool = function () {
                            for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                                args[_key4] = arguments[_key4];
                            }

                            Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');

                            return internals.callWithDefaults.call(this, internals.boolean, args);
                        };

                        root.binary = function () {
                            for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
                                args[_key5] = arguments[_key5];
                            }

                            Hoek.assert(args.length === 0, 'Joi.binary() does not allow arguments.');

                            return internals.callWithDefaults.call(this, internals.binary, args);
                        };

                        root.date = function () {
                            for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
                                args[_key6] = arguments[_key6];
                            }

                            Hoek.assert(args.length === 0, 'Joi.date() does not allow arguments.');

                            return internals.callWithDefaults.call(this, internals.date, args);
                        };

                        root.func = function () {
                            for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
                                args[_key7] = arguments[_key7];
                            }

                            Hoek.assert(args.length === 0, 'Joi.func() does not allow arguments.');

                            return internals.callWithDefaults.call(this, internals.func, args);
                        };

                        root.number = function () {
                            for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
                                args[_key8] = arguments[_key8];
                            }

                            Hoek.assert(args.length === 0, 'Joi.number() does not allow arguments.');

                            return internals.callWithDefaults.call(this, internals.number, args);
                        };

                        root.object = function () {
                            for (var _len9 = arguments.length, args = Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
                                args[_key9] = arguments[_key9];
                            }

                            return internals.callWithDefaults.call(this, internals.object, args);
                        };

                        root.string = function () {
                            for (var _len10 = arguments.length, args = Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
                                args[_key10] = arguments[_key10];
                            }

                            Hoek.assert(args.length === 0, 'Joi.string() does not allow arguments.');

                            return internals.callWithDefaults.call(this, internals.string, args);
                        };

                        root.ref = function () {

                            return Ref.create.apply(Ref, arguments);
                        };

                        root.isRef = function (ref) {

                            return Ref.isRef(ref);
                        };

                        root.validate = function (value) /*, [schema], [options], callback */{
                            var _ref;

                            var last = (_ref = (arguments.length <= 1 ? 0 : arguments.length - 1) - 1 + 1, arguments.length <= _ref ? undefined : arguments[_ref]);
                            var callback = typeof last === 'function' ? last : null;

                            var count = (arguments.length <= 1 ? 0 : arguments.length - 1) - (callback ? 1 : 0);
                            if (count === 0) {
                                return any.validate(value, callback);
                            }

                            var options = count === 2 ? arguments.length <= 2 ? undefined : arguments[2] : {};
                            var schema = root.compile(arguments.length <= 1 ? undefined : arguments[1]);

                            return schema._validateWithOptions(value, options, callback);
                        };

                        root.describe = function () {

                            var schema = arguments.length ? root.compile(arguments.length <= 0 ? undefined : arguments[0]) : any;
                            return schema.describe();
                        };

                        root.compile = function (schema) {

                            try {
                                return Cast.schema(this, schema);
                            } catch (err) {
                                if (err.hasOwnProperty('path')) {
                                    err.message = err.message + '(' + err.path + ')';
                                }
                                throw err;
                            }
                        };

                        root.assert = function (value, schema, message) {

                            root.attempt(value, schema, message);
                        };

                        root.attempt = function (value, schema, message) {

                            var result = root.validate(value, schema);
                            var error = result.error;
                            if (error) {
                                if (!message) {
                                    if (typeof error.annotate === 'function') {
                                        error.message = error.annotate();
                                    }
                                    throw error;
                                }

                                if (!(message instanceof Error)) {
                                    if (typeof error.annotate === 'function') {
                                        error.message = message + ' ' + error.annotate();
                                    }
                                    throw error;
                                }

                                throw message;
                            }

                            return result.value;
                        };

                        root.reach = function (schema, path) {

                            Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');
                            Hoek.assert(Array.isArray(path) || typeof path === 'string', 'path must be a string or an array of strings');

                            var reach = function reach(sourceSchema, schemaPath) {

                                if (!schemaPath.length) {
                                    return sourceSchema;
                                }

                                var children = sourceSchema._inner.children;
                                if (!children) {
                                    return;
                                }

                                var key = schemaPath.shift();
                                for (var i = 0; i < children.length; ++i) {
                                    var child = children[i];
                                    if (child.key === key) {
                                        return reach(child.schema, schemaPath);
                                    }
                                }
                            };

                            var schemaPath = typeof path === 'string' ? path ? path.split('.') : [] : path.slice();

                            return reach(schema, schemaPath);
                        };

                        root.lazy = function (fn) {

                            return Lazy.set(fn);
                        };

                        root.defaults = function (fn) {
                            var _this = this;

                            Hoek.assert(typeof fn === 'function', 'Defaults must be a function');

                            var joi = Object.create(this.any());
                            joi = fn(joi);

                            Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');

                            _extends(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults

                            joi._defaults = function (schema) {

                                if (_this._defaults) {
                                    schema = _this._defaults(schema);
                                    Hoek.assert(schema instanceof _this.constructor, 'defaults() must return a schema');
                                }

                                schema = fn(schema);
                                Hoek.assert(schema instanceof _this.constructor, 'defaults() must return a schema');
                                return schema;
                            };

                            return joi;
                        };

                        root.extend = function () {
                            var _this2 = this;

                            for (var _len11 = arguments.length, args = Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
                                args[_key11] = arguments[_key11];
                            }

                            var extensions = Hoek.flatten(args);
                            Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');

                            this.assert(extensions, root.extensionsSchema);

                            var joi = Object.create(this.any());
                            _extends(joi, this);

                            var _loop = function _loop(i) {
                                var extension = extensions[i];

                                if (typeof extension === 'function') {
                                    extension = extension(joi);
                                }

                                _this2.assert(extension, root.extensionSchema);

                                var base = (extension.base || _this2.any()).clone(); // Cloning because we're going to override language afterwards
                                var ctor = base.constructor;
                                var type = function (_ctor) {
                                    _inherits(type, _ctor);

                                    // eslint-disable-line no-loop-func

                                    function type() {
                                        _classCallCheck(this, type);

                                        var _this3 = _possibleConstructorReturn(this, _ctor.call(this));

                                        if (extension.base) {
                                            _extends(_this3, base);
                                        }

                                        _this3._type = extension.name;

                                        if (extension.language) {
                                            _this3._settings = Settings.concat(_this3._settings, {
                                                language: _defineProperty({}, extension.name, extension.language)
                                            });
                                        }
                                        return _this3;
                                    }

                                    return type;
                                }(ctor);

                                if (extension.coerce) {
                                    type.prototype._coerce = function (value, state, options) {

                                        if (ctor.prototype._coerce) {
                                            var baseRet = ctor.prototype._coerce.call(this, value, state, options);

                                            if (baseRet.errors) {
                                                return baseRet;
                                            }

                                            value = baseRet.value;
                                        }

                                        var ret = extension.coerce.call(this, value, state, options);
                                        if (ret instanceof Errors.Err) {
                                            return { value: value, errors: ret };
                                        }

                                        return { value: ret };
                                    };
                                }
                                if (extension.pre) {
                                    type.prototype._base = function (value, state, options) {

                                        if (ctor.prototype._base) {
                                            var baseRet = ctor.prototype._base.call(this, value, state, options);

                                            if (baseRet.errors) {
                                                return baseRet;
                                            }

                                            value = baseRet.value;
                                        }

                                        var ret = extension.pre.call(this, value, state, options);
                                        if (ret instanceof Errors.Err) {
                                            return { value: value, errors: ret };
                                        }

                                        return { value: ret };
                                    };
                                }

                                if (extension.rules) {
                                    var _loop2 = function _loop2(j) {
                                        var rule = extension.rules[j];
                                        var ruleArgs = rule.params ? rule.params instanceof Any ? rule.params._inner.children.map(function (k) {
                                            return k.key;
                                        }) : Object.keys(rule.params) : [];
                                        var validateArgs = rule.params ? Cast.schema(_this2, rule.params) : null;

                                        type.prototype[rule.name] = function () {
                                            for (var _len12 = arguments.length, rArgs = Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
                                                rArgs[_key12] = arguments[_key12];
                                            }

                                            // eslint-disable-line no-loop-func

                                            if (rArgs.length > ruleArgs.length) {
                                                throw new Error('Unexpected number of arguments');
                                            }

                                            var hasRef = false;
                                            var arg = {};

                                            for (var k = 0; k < ruleArgs.length; ++k) {
                                                arg[ruleArgs[k]] = rArgs[k];
                                                if (!hasRef && Ref.isRef(rArgs[k])) {
                                                    hasRef = true;
                                                }
                                            }

                                            if (validateArgs) {
                                                arg = joi.attempt(arg, validateArgs);
                                            }

                                            var schema = void 0;
                                            if (rule.validate) {
                                                var validate = function validate(value, state, options) {

                                                    return rule.validate.call(this, arg, value, state, options);
                                                };

                                                schema = this._test(rule.name, arg, validate, {
                                                    description: rule.description,
                                                    hasRef: hasRef
                                                });
                                            } else {
                                                schema = this.clone();
                                            }

                                            if (rule.setup) {
                                                var newSchema = rule.setup.call(schema, arg);
                                                if (newSchema !== undefined) {
                                                    Hoek.assert(newSchema instanceof Any, 'Setup of extension Joi.' + this._type + '().' + rule.name + '() must return undefined or a Joi object');
                                                    schema = newSchema;
                                                }
                                            }

                                            return schema;
                                        };
                                    };

                                    for (var j = 0; j < extension.rules.length; ++j) {
                                        _loop2(j);
                                    }
                                }

                                if (extension.describe) {
                                    type.prototype.describe = function () {

                                        var description = ctor.prototype.describe.call(this);
                                        return extension.describe.call(this, description);
                                    };
                                }

                                var instance = new type();
                                joi[extension.name] = function () {
                                    for (var _len13 = arguments.length, extArgs = Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
                                        extArgs[_key13] = arguments[_key13];
                                    }

                                    return internals.callWithDefaults.call(this, instance, extArgs);
                                };
                            };

                            for (var i = 0; i < extensions.length; ++i) {
                                _loop(i);
                            }

                            return joi;
                        };

                        root.extensionSchema = internals.object.keys({
                            base: internals.object.type(Any, 'Joi object'),
                            name: internals.string.required(),
                            coerce: internals.func.arity(3),
                            pre: internals.func.arity(3),
                            language: internals.object,
                            describe: internals.func.arity(1),
                            rules: internals.array.items(internals.object.keys({
                                name: internals.string.required(),
                                setup: internals.func.arity(1),
                                validate: internals.func.arity(4),
                                params: [internals.object.pattern(/.*/, internals.object.type(Any, 'Joi object')), internals.object.type(internals.object.constructor, 'Joi object')],
                                description: [internals.string, internals.func.arity(1)]
                            }).or('setup', 'validate'))
                        }).strict();

                        root.extensionsSchema = internals.array.items([internals.object, internals.func.arity(1)]).strict();

                        root.version = __webpack_require__(36).version;

                        return root;
                    };

                    module.exports = internals.root();

                    /***/ }),
                /* 9 */
                /***/ (function(module, exports, __webpack_require__) {
                    /* WEBPACK VAR INJECTION */(function(Buffer) {

                        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

                        function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

                        function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

                        var Ref = __webpack_require__(1);

                        var internals = {};

                        internals.extendedCheckForValue = function (value, insensitive) {

                            var valueType = typeof value === 'undefined' ? 'undefined' : _typeof(value);

                            if (valueType === 'object') {
                                if (value instanceof Date) {
                                    return function (item) {

                                        return item instanceof Date && value.getTime() === item.getTime();
                                    };
                                }
                                if (Buffer.isBuffer(value)) {
                                    return function (item) {

                                        return Buffer.isBuffer(item) && value.length === item.length && value.toString('binary') === item.toString('binary');
                                    };
                                }
                            } else if (insensitive && valueType === 'string') {
                                var lowercaseValue = value.toLowerCase();
                                return function (item) {

                                    return typeof item === 'string' && lowercaseValue === item.toLowerCase();
                                };
                            }

                            return null;
                        };

                        module.exports = function () {
                            function InternalSet(from) {
                                _classCallCheck(this, InternalSet);

                                this._set = new Set(from);
                                this._hasRef = false;
                            }

                            InternalSet.prototype.add = function add(value, refs) {

                                var isRef = Ref.isRef(value);
                                if (!isRef && this.has(value, null, null, false)) {

                                    return this;
                                }

                                if (refs !== undefined) {
                                    // If it's a merge, we don't have any refs
                                    Ref.push(refs, value);
                                }

                                this._set.add(value);

                                this._hasRef |= isRef;

                                return this;
                            };

                            InternalSet.prototype.merge = function merge(add, remove) {
                                var _iteratorNormalCompletion = true;
                                var _didIteratorError = false;
                                var _iteratorError = undefined;

                                try {

                                    for (var _iterator = add._set[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                        var item = _step.value;

                                        this.add(item);
                                    }
                                } catch (err) {
                                    _didIteratorError = true;
                                    _iteratorError = err;
                                } finally {
                                    try {
                                        if (!_iteratorNormalCompletion && _iterator.return) {
                                            _iterator.return();
                                        }
                                    } finally {
                                        if (_didIteratorError) {
                                            throw _iteratorError;
                                        }
                                    }
                                }

                                var _iteratorNormalCompletion2 = true;
                                var _didIteratorError2 = false;
                                var _iteratorError2 = undefined;

                                try {
                                    for (var _iterator2 = remove._set[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                        var _item = _step2.value;

                                        this.remove(_item);
                                    }
                                } catch (err) {
                                    _didIteratorError2 = true;
                                    _iteratorError2 = err;
                                } finally {
                                    try {
                                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                            _iterator2.return();
                                        }
                                    } finally {
                                        if (_didIteratorError2) {
                                            throw _iteratorError2;
                                        }
                                    }
                                }

                                return this;
                            };

                            InternalSet.prototype.remove = function remove(value) {

                                this._set.delete(value);
                                return this;
                            };

                            InternalSet.prototype.has = function has(value, state, options, insensitive) {

                                if (!this._set.size) {
                                    return false;
                                }

                                var hasValue = this._set.has(value);
                                if (hasValue) {
                                    return hasValue;
                                }

                                var extendedCheck = internals.extendedCheckForValue(value, insensitive);
                                if (!extendedCheck) {
                                    if (state && this._hasRef) {
                                        var _iteratorNormalCompletion3 = true;
                                        var _didIteratorError3 = false;
                                        var _iteratorError3 = undefined;

                                        try {
                                            for (var _iterator3 = this._set[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                                                var item = _step3.value;

                                                if (Ref.isRef(item)) {
                                                    item = item(state.reference || state.parent, options);
                                                    if (value === item || Array.isArray(item) && item.includes(value)) {
                                                        return true;
                                                    }
                                                }
                                            }
                                        } catch (err) {
                                            _didIteratorError3 = true;
                                            _iteratorError3 = err;
                                        } finally {
                                            try {
                                                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                                                    _iterator3.return();
                                                }
                                            } finally {
                                                if (_didIteratorError3) {
                                                    throw _iteratorError3;
                                                }
                                            }
                                        }
                                    }

                                    return false;
                                }

                                return this._has(value, state, options, extendedCheck);
                            };

                            InternalSet.prototype._has = function _has(value, state, options, check) {

                                var checkRef = !!(state && this._hasRef);

                                var isReallyEqual = function isReallyEqual(item) {

                                    if (value === item) {
                                        return true;
                                    }

                                    return check(item);
                                };

                                var _iteratorNormalCompletion4 = true;
                                var _didIteratorError4 = false;
                                var _iteratorError4 = undefined;

                                try {
                                    for (var _iterator4 = this._set[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                                        var item = _step4.value;

                                        if (checkRef && Ref.isRef(item)) {
                                            // Only resolve references if there is a state, otherwise it's a merge
                                            item = item(state.reference || state.parent, options);

                                            if (Array.isArray(item)) {
                                                if (item.find(isReallyEqual)) {
                                                    return true;
                                                }
                                                continue;
                                            }
                                        }

                                        if (isReallyEqual(item)) {
                                            return true;
                                        }
                                    }
                                } catch (err) {
                                    _didIteratorError4 = true;
                                    _iteratorError4 = err;
                                } finally {
                                    try {
                                        if (!_iteratorNormalCompletion4 && _iterator4.return) {
                                            _iterator4.return();
                                        }
                                    } finally {
                                        if (_didIteratorError4) {
                                            throw _iteratorError4;
                                        }
                                    }
                                }

                                return false;
                            };

                            InternalSet.prototype.values = function values(options) {

                                if (options && options.stripUndefined) {
                                    var values = [];

                                    var _iteratorNormalCompletion5 = true;
                                    var _didIteratorError5 = false;
                                    var _iteratorError5 = undefined;

                                    try {
                                        for (var _iterator5 = this._set[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                                            var item = _step5.value;

                                            if (item !== undefined) {
                                                values.push(item);
                                            }
                                        }
                                    } catch (err) {
                                        _didIteratorError5 = true;
                                        _iteratorError5 = err;
                                    } finally {
                                        try {
                                            if (!_iteratorNormalCompletion5 && _iterator5.return) {
                                                _iterator5.return();
                                            }
                                        } finally {
                                            if (_didIteratorError5) {
                                                throw _iteratorError5;
                                            }
                                        }
                                    }

                                    return values;
                                }

                                return Array.from(this._set);
                            };

                            InternalSet.prototype.slice = function slice() {

                                var set = new InternalSet(this._set);
                                set._hasRef = this._hasRef;
                                return set;
                            };

                            InternalSet.prototype.concat = function concat(source) {

                                var set = new InternalSet([].concat(_toConsumableArray(this._set), _toConsumableArray(source._set)));
                                set._hasRef = !!(this._hasRef | source._hasRef);
                                return set;
                            };

                            return InternalSet;
                        }();
                        /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).Buffer));

                    /***/ }),
                /* 10 */
                /***/ (function(module, exports, __webpack_require__) {


// Load modules

                    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

                    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

                    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

                    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

                    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

                    var Hoek = __webpack_require__(0);
                    var Any = __webpack_require__(2);
                    var Cast = __webpack_require__(4);
                    var Ref = __webpack_require__(1);

// Declare internals

                    var internals = {};

                    internals.Alternatives = function (_Any) {
                        _inherits(_class, _Any);

                        function _class() {
                            _classCallCheck(this, _class);

                            var _this = _possibleConstructorReturn(this, _Any.call(this));

                            _this._type = 'alternatives';
                            _this._invalids.remove(null);
                            _this._inner.matches = [];
                            return _this;
                        }

                        _class.prototype._init = function _init() {

                            return arguments.length ? this.try.apply(this, arguments) : this;
                        };

                        _class.prototype._base = function _base(value, state, options) {

                            var errors = [];
                            var il = this._inner.matches.length;
                            var baseType = this._baseType;

                            for (var i = 0; i < il; ++i) {
                                var item = this._inner.matches[i];
                                if (!item.schema) {
                                    var schema = item.peek || item.is;
                                    var input = item.is ? item.ref(state.reference || state.parent, options) : value;
                                    var failed = schema._validate(input, null, options, state.parent).errors;

                                    if (failed) {
                                        if (item.otherwise) {
                                            return item.otherwise._validate(value, state, options);
                                        }
                                    } else if (item.then) {
                                        return item.then._validate(value, state, options);
                                    }

                                    if (i === il - 1 && baseType) {
                                        return baseType._validate(value, state, options);
                                    }

                                    continue;
                                }

                                var result = item.schema._validate(value, state, options);
                                if (!result.errors) {
                                    // Found a valid match
                                    return result;
                                }

                                errors = errors.concat(result.errors);
                            }

                            if (errors.length) {
                                return { errors: this.createError('alternatives.child', { reason: errors }, state, options) };
                            }

                            return { errors: this.createError('alternatives.base', null, state, options) };
                        };

                        _class.prototype.try = function _try() {
                            for (var _len = arguments.length, schemas = Array(_len), _key = 0; _key < _len; _key++) {
                                schemas[_key] = arguments[_key];
                            }

                            schemas = Hoek.flatten(schemas);
                            Hoek.assert(schemas.length, 'Cannot add other alternatives without at least one schema');

                            var obj = this.clone();

                            for (var i = 0; i < schemas.length; ++i) {
                                var cast = Cast.schema(this._currentJoi, schemas[i]);
                                if (cast._refs.length) {
                                    obj._refs = obj._refs.concat(cast._refs);
                                }
                                obj._inner.matches.push({ schema: cast });
                            }

                            return obj;
                        };

                        _class.prototype.when = function when(condition, options) {

                            var schemaCondition = false;
                            Hoek.assert(Ref.isRef(condition) || typeof condition === 'string' || (schemaCondition = condition instanceof Any), 'Invalid condition:', condition);
                            Hoek.assert(options, 'Missing options');
                            Hoek.assert((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object', 'Invalid options');
                            if (schemaCondition) {
                                Hoek.assert(!options.hasOwnProperty('is'), '"is" can not be used with a schema condition');
                            } else {
                                Hoek.assert(options.hasOwnProperty('is'), 'Missing "is" directive');
                            }
                            Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of "then" or "otherwise"');

                            var obj = this.clone();
                            var is = void 0;
                            if (!schemaCondition) {
                                is = Cast.schema(this._currentJoi, options.is);

                                if (options.is === null || !(Ref.isRef(options.is) || options.is instanceof Any)) {

                                    // Only apply required if this wasn't already a schema or a ref, we'll suppose people know what they're doing
                                    is = is.required();
                                }
                            }

                            var item = {
                                ref: schemaCondition ? null : Cast.ref(condition),
                                peek: schemaCondition ? condition : null,
                                is: is,
                                then: options.then !== undefined ? Cast.schema(this._currentJoi, options.then) : undefined,
                                otherwise: options.otherwise !== undefined ? Cast.schema(this._currentJoi, options.otherwise) : undefined
                            };

                            if (obj._baseType) {

                                item.then = item.then && obj._baseType.concat(item.then);
                                item.otherwise = item.otherwise && obj._baseType.concat(item.otherwise);
                            }

                            if (!schemaCondition) {
                                Ref.push(obj._refs, item.ref);
                                obj._refs = obj._refs.concat(item.is._refs);
                            }

                            if (item.then && item.then._refs) {
                                obj._refs = obj._refs.concat(item.then._refs);
                            }

                            if (item.otherwise && item.otherwise._refs) {
                                obj._refs = obj._refs.concat(item.otherwise._refs);
                            }

                            obj._inner.matches.push(item);

                            return obj;
                        };

                        _class.prototype.describe = function describe() {

                            var description = Any.prototype.describe.call(this);
                            var alternatives = [];
                            for (var i = 0; i < this._inner.matches.length; ++i) {
                                var item = this._inner.matches[i];
                                if (item.schema) {

                                    // try()

                                    alternatives.push(item.schema.describe());
                                } else {

                                    // when()

                                    var when = item.is ? {
                                        ref: item.ref.toString(),
                                        is: item.is.describe()
                                    } : {
                                        peek: item.peek.describe()
                                    };

                                    if (item.then) {
                                        when.then = item.then.describe();
                                    }

                                    if (item.otherwise) {
                                        when.otherwise = item.otherwise.describe();
                                    }

                                    alternatives.push(when);
                                }
                            }

                            description.alternatives = alternatives;
                            return description;
                        };

                        return _class;
                    }(Any);

                    module.exports = new internals.Alternatives();

                    /***/ }),
                /* 11 */
                /***/ (function(module, exports, __webpack_require__) {


// Load modules

                    var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

                    var Hoek = __webpack_require__(0);

                    exports.concat = function (target, source) {

                        if (!source) {
                            return target;
                        }

                        var obj = _extends({}, target);

                        var sKeys = Object.keys(source);
                        for (var i = 0; i < sKeys.length; ++i) {
                            var key = sKeys[i];
                            if (key !== 'language' || !obj.hasOwnProperty(key)) {

                                obj[key] = source[key];
                            } else {
                                obj[key] = Hoek.applyToDefaults(obj[key], source[key]);
                            }
                        }

                        return obj;
                    };

                    /***/ }),
                /* 12 */
                /***/ (function(module, exports, __webpack_require__) {


// Load modules

                    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

                    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

                    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

                    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

                    var Any = __webpack_require__(2);
                    var Ref = __webpack_require__(1);
                    var Hoek = __webpack_require__(0);

// Declare internals

                    var internals = {};

                    internals.isoDate = /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/;
                    internals.invalidDate = new Date('');
                    internals.isIsoDate = function () {

                        var isoString = internals.isoDate.toString();

                        return function (date) {

                            return date && date.toString() === isoString;
                        };
                    }();

                    internals.Date = function (_Any) {
                        _inherits(_class, _Any);

                        function _class() {
                            _classCallCheck(this, _class);

                            var _this = _possibleConstructorReturn(this, _Any.call(this));

                            _this._type = 'date';
                            return _this;
                        }

                        _class.prototype._base = function _base(value, state, options) {

                            var result = {
                                value: options.convert && internals.Date.toDate(value, this._flags.format, this._flags.timestamp, this._flags.multiplier) || value
                            };

                            if (result.value instanceof Date && !isNaN(result.value.getTime())) {
                                result.errors = null;
                            } else if (!options.convert) {
                                result.errors = this.createError('date.strict', null, state, options);
                            } else {
                                var type = void 0;
                                if (internals.isIsoDate(this._flags.format)) {
                                    type = 'isoDate';
                                } else if (this._flags.timestamp) {
                                    type = 'timestamp.' + this._flags.timestamp;
                                } else {
                                    type = 'base';
                                }

                                result.errors = this.createError('date.' + type, null, state, options);
                            }

                            return result;
                        };

                        _class.toDate = function toDate(value, format, timestamp, multiplier) {

                            if (value instanceof Date) {
                                return value;
                            }

                            if (typeof value === 'string' || typeof value === 'number' && !isNaN(value) && isFinite(value)) {

                                if (typeof value === 'string' && /^[+-]?\d+(\.\d+)?$/.test(value)) {

                                    value = parseFloat(value);
                                }

                                var date = void 0;
                                if (format && internals.isIsoDate(format)) {
                                    date = format.test(value) ? new Date(value) : internals.invalidDate;
                                } else if (timestamp && multiplier) {
                                    date = /^\s*$/.test(value) ? internals.invalidDate : new Date(value * multiplier);
                                } else {
                                    date = new Date(value);
                                }

                                if (!isNaN(date.getTime())) {
                                    return date;
                                }
                            }

                            return null;
                        };

                        _class.prototype.iso = function iso() {

                            if (this._flags.format === internals.isoDate) {
                                return this;
                            }

                            var obj = this.clone();
                            obj._flags.format = internals.isoDate;
                            return obj;
                        };

                        _class.prototype.timestamp = function timestamp() {
                            var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'javascript';


                            var allowed = ['javascript', 'unix'];
                            Hoek.assert(allowed.includes(type), '"type" must be one of "' + allowed.join('", "') + '"');

                            if (this._flags.timestamp === type) {
                                return this;
                            }

                            var obj = this.clone();
                            obj._flags.timestamp = type;
                            obj._flags.multiplier = type === 'unix' ? 1000 : 1;
                            return obj;
                        };

                        _class.prototype._isIsoDate = function _isIsoDate(value) {

                            return internals.isoDate.test(value);
                        };

                        return _class;
                    }(Any);

                    internals.compare = function (type, compare) {

                        return function (date) {

                            var isNow = date === 'now';
                            var isRef = Ref.isRef(date);

                            if (!isNow && !isRef) {
                                date = internals.Date.toDate(date);
                            }

                            Hoek.assert(date, 'Invalid date format');

                            return this._test(type, date, function (value, state, options) {

                                var compareTo = void 0;
                                if (isNow) {
                                    compareTo = Date.now();
                                } else if (isRef) {
                                    compareTo = internals.Date.toDate(date(state.reference || state.parent, options));

                                    if (!compareTo) {
                                        return this.createError('date.ref', { ref: date.key }, state, options);
                                    }

                                    compareTo = compareTo.getTime();
                                } else {
                                    compareTo = date.getTime();
                                }

                                if (compare(value.getTime(), compareTo)) {
                                    return value;
                                }

                                return this.createError('date.' + type, { limit: new Date(compareTo) }, state, options);
                            });
                        };
                    };

                    internals.Date.prototype.min = internals.compare('min', function (value, date) {
                        return value >= date;
                    });
                    internals.Date.prototype.max = internals.compare('max', function (value, date) {
                        return value <= date;
                    });
                    internals.Date.prototype.greater = internals.compare('greater', function (value, date) {
                        return value > date;
                    });
                    internals.Date.prototype.less = internals.compare('less', function (value, date) {
                        return value < date;
                    });

                    module.exports = new internals.Date();

                    /***/ }),
                /* 13 */
                /***/ (function(module, exports, __webpack_require__) {


// Load modules

                    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

                    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

                    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

                    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

                    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

                    var Hoek = __webpack_require__(0);
                    var Topo = __webpack_require__(31);
                    var Any = __webpack_require__(2);
                    var Errors = __webpack_require__(6);
                    var Cast = __webpack_require__(4);

// Declare internals

                    var internals = {};

                    internals.Object = function (_Any) {
                        _inherits(_class, _Any);

                        function _class() {
                            _classCallCheck(this, _class);

                            var _this = _possibleConstructorReturn(this, _Any.call(this));

                            _this._type = 'object';
                            _this._inner.children = null;
                            _this._inner.renames = [];
                            _this._inner.dependencies = [];
                            _this._inner.patterns = [];
                            return _this;
                        }

                        _class.prototype._init = function _init() {

                            return arguments.length ? this.keys.apply(this, arguments) : this;
                        };

                        _class.prototype._base = function _base(value, state, options) {

                            var target = value;
                            var errors = [];
                            var finish = function finish() {

                                return {
                                    value: target,
                                    errors: errors.length ? errors : null
                                };
                            };

                            if (typeof value === 'string' && options.convert) {

                                value = internals.safeParse(value);
                            }

                            var type = this._flags.func ? 'function' : 'object';
                            if (!value || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== type || Array.isArray(value)) {

                                errors.push(this.createError(type + '.base', null, state, options));
                                return finish();
                            }

                            // Skip if there are no other rules to test

                            if (!this._inner.renames.length && !this._inner.dependencies.length && !this._inner.children && // null allows any keys
                                !this._inner.patterns.length) {

                                target = value;
                                return finish();
                            }

                            // Ensure target is a local copy (parsed) or shallow copy

                            if (target === value) {
                                if (type === 'object') {
                                    target = Object.create(Object.getPrototypeOf(value));
                                } else {
                                    target = function target() {
                                        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                                            args[_key] = arguments[_key];
                                        }

                                        return value.apply(this, args);
                                    };

                                    target.prototype = Hoek.clone(value.prototype);
                                }

                                var valueKeys = Object.keys(value);
                                for (var i = 0; i < valueKeys.length; ++i) {
                                    target[valueKeys[i]] = value[valueKeys[i]];
                                }
                            } else {
                                target = value;
                            }

                            // Rename keys

                            var renamed = {};
                            for (var _i = 0; _i < this._inner.renames.length; ++_i) {
                                var rename = this._inner.renames[_i];

                                if (rename.isRegExp) {
                                    var targetKeys = Object.keys(target);
                                    var matchedTargetKeys = [];

                                    for (var j = 0; j < targetKeys.length; ++j) {
                                        if (rename.from.test(targetKeys[j])) {
                                            matchedTargetKeys.push(targetKeys[j]);
                                        }
                                    }

                                    var allUndefined = matchedTargetKeys.every(function (key) {
                                        return target[key] === undefined;
                                    });
                                    if (rename.options.ignoreUndefined && allUndefined) {
                                        continue;
                                    }

                                    if (!rename.options.multiple && renamed[rename.to]) {

                                        errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));
                                        if (options.abortEarly) {
                                            return finish();
                                        }
                                    }

                                    if (Object.prototype.hasOwnProperty.call(target, rename.to) && !rename.options.override && !renamed[rename.to]) {

                                        errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));
                                        if (options.abortEarly) {
                                            return finish();
                                        }
                                    }

                                    if (allUndefined) {
                                        delete target[rename.to];
                                    } else {
                                        target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];
                                    }

                                    renamed[rename.to] = true;

                                    if (!rename.options.alias) {
                                        for (var _j = 0; _j < matchedTargetKeys.length; ++_j) {
                                            delete target[matchedTargetKeys[_j]];
                                        }
                                    }
                                } else {
                                    if (rename.options.ignoreUndefined && target[rename.from] === undefined) {
                                        continue;
                                    }

                                    if (!rename.options.multiple && renamed[rename.to]) {

                                        errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));
                                        if (options.abortEarly) {
                                            return finish();
                                        }
                                    }

                                    if (Object.prototype.hasOwnProperty.call(target, rename.to) && !rename.options.override && !renamed[rename.to]) {

                                        errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));
                                        if (options.abortEarly) {
                                            return finish();
                                        }
                                    }

                                    if (target[rename.from] === undefined) {
                                        delete target[rename.to];
                                    } else {
                                        target[rename.to] = target[rename.from];
                                    }

                                    renamed[rename.to] = true;

                                    if (!rename.options.alias) {
                                        delete target[rename.from];
                                    }
                                }
                            }

                            // Validate schema

                            if (!this._inner.children && // null allows any keys
                                !this._inner.patterns.length && !this._inner.dependencies.length) {

                                return finish();
                            }

                            var unprocessed = new Set(Object.keys(target));

                            if (this._inner.children) {
                                var stripProps = [];

                                for (var _i2 = 0; _i2 < this._inner.children.length; ++_i2) {
                                    var child = this._inner.children[_i2];
                                    var key = child.key;
                                    var item = target[key];

                                    unprocessed.delete(key);

                                    var localState = { key: key, path: state.path.concat(key), parent: target, reference: state.reference };
                                    var result = child.schema._validate(item, localState, options);
                                    if (result.errors) {
                                        errors.push(this.createError('object.child', { key: key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));

                                        if (options.abortEarly) {
                                            return finish();
                                        }
                                    } else {
                                        if (child.schema._flags.strip || result.value === undefined && result.value !== item) {
                                            stripProps.push(key);
                                            target[key] = result.finalValue;
                                        } else if (result.value !== undefined) {
                                            target[key] = result.value;
                                        }
                                    }
                                }

                                for (var _i3 = 0; _i3 < stripProps.length; ++_i3) {
                                    delete target[stripProps[_i3]];
                                }
                            }

                            // Unknown keys

                            if (unprocessed.size && this._inner.patterns.length) {
                                var _iteratorNormalCompletion = true;
                                var _didIteratorError = false;
                                var _iteratorError = undefined;

                                try {

                                    for (var _iterator = unprocessed[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                        var _key2 = _step.value;

                                        var _localState = {
                                            key: _key2,
                                            path: state.path.concat(_key2),
                                            parent: target,
                                            reference: state.reference
                                        };
                                        var _item = target[_key2];

                                        for (var _i4 = 0; _i4 < this._inner.patterns.length; ++_i4) {
                                            var pattern = this._inner.patterns[_i4];

                                            if (pattern.regex ? pattern.regex.test(_key2) : !pattern.schema.validate(_key2).error) {

                                                unprocessed.delete(_key2);

                                                var _result = pattern.rule._validate(_item, _localState, options);
                                                if (_result.errors) {
                                                    errors.push(this.createError('object.child', {
                                                        key: _key2,
                                                        child: pattern.rule._getLabel(_key2),
                                                        reason: _result.errors
                                                    }, _localState, options));

                                                    if (options.abortEarly) {
                                                        return finish();
                                                    }
                                                }

                                                target[_key2] = _result.value;
                                            }
                                        }
                                    }
                                } catch (err) {
                                    _didIteratorError = true;
                                    _iteratorError = err;
                                } finally {
                                    try {
                                        if (!_iteratorNormalCompletion && _iterator.return) {
                                            _iterator.return();
                                        }
                                    } finally {
                                        if (_didIteratorError) {
                                            throw _iteratorError;
                                        }
                                    }
                                }
                            }

                            if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {
                                if (options.stripUnknown && this._flags.allowUnknown !== true || options.skipFunctions) {

                                    var stripUnknown = options.stripUnknown ? options.stripUnknown === true ? true : !!options.stripUnknown.objects : false;

                                    var _iteratorNormalCompletion2 = true;
                                    var _didIteratorError2 = false;
                                    var _iteratorError2 = undefined;

                                    try {
                                        for (var _iterator2 = unprocessed[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                            var _key3 = _step2.value;

                                            if (stripUnknown) {
                                                delete target[_key3];
                                                unprocessed.delete(_key3);
                                            } else if (typeof target[_key3] === 'function') {
                                                unprocessed.delete(_key3);
                                            }
                                        }
                                    } catch (err) {
                                        _didIteratorError2 = true;
                                        _iteratorError2 = err;
                                    } finally {
                                        try {
                                            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                                _iterator2.return();
                                            }
                                        } finally {
                                            if (_didIteratorError2) {
                                                throw _iteratorError2;
                                            }
                                        }
                                    }
                                }

                                if (this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown) {
                                    var _iteratorNormalCompletion3 = true;
                                    var _didIteratorError3 = false;
                                    var _iteratorError3 = undefined;

                                    try {

                                        for (var _iterator3 = unprocessed[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                                            var unprocessedKey = _step3.value;

                                            errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {
                                                key: unprocessedKey,
                                                path: state.path.concat(unprocessedKey)
                                            }, options, {}));
                                        }
                                    } catch (err) {
                                        _didIteratorError3 = true;
                                        _iteratorError3 = err;
                                    } finally {
                                        try {
                                            if (!_iteratorNormalCompletion3 && _iterator3.return) {
                                                _iterator3.return();
                                            }
                                        } finally {
                                            if (_didIteratorError3) {
                                                throw _iteratorError3;
                                            }
                                        }
                                    }
                                }
                            }

                            // Validate dependencies

                            for (var _i5 = 0; _i5 < this._inner.dependencies.length; ++_i5) {
                                var dep = this._inner.dependencies[_i5];
                                var err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);
                                if (err instanceof Errors.Err) {
                                    errors.push(err);
                                    if (options.abortEarly) {
                                        return finish();
                                    }
                                }
                            }

                            return finish();
                        };

                        _class.prototype.keys = function keys(schema) {

                            Hoek.assert(schema === null || schema === undefined || (typeof schema === 'undefined' ? 'undefined' : _typeof(schema)) === 'object', 'Object schema must be a valid object');
                            Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');

                            var obj = this.clone();

                            if (!schema) {
                                obj._inner.children = null;
                                return obj;
                            }

                            var children = Object.keys(schema);

                            if (!children.length) {
                                obj._inner.children = [];
                                return obj;
                            }

                            var topo = new Topo();
                            if (obj._inner.children) {
                                for (var i = 0; i < obj._inner.children.length; ++i) {
                                    var child = obj._inner.children[i];

                                    // Only add the key if we are not going to replace it later
                                    if (!children.includes(child.key)) {
                                        topo.add(child, { after: child._refs, group: child.key });
                                    }
                                }
                            }

                            for (var _i6 = 0; _i6 < children.length; ++_i6) {
                                var key = children[_i6];
                                var _child = schema[key];
                                try {
                                    var cast = Cast.schema(this._currentJoi, _child);
                                    topo.add({ key: key, schema: cast }, { after: cast._refs, group: key });
                                } catch (castErr) {
                                    if (castErr.hasOwnProperty('path')) {
                                        castErr.path = key + '.' + castErr.path;
                                    } else {
                                        castErr.path = key;
                                    }
                                    throw castErr;
                                }
                            }

                            obj._inner.children = topo.nodes;

                            return obj;
                        };

                        _class.prototype.append = function append(schema) {
                            // Skip any changes
                            if (schema === null || schema === undefined || Object.keys(schema).length === 0) {
                                return this;
                            }

                            return this.keys(schema);
                        };

                        _class.prototype.unknown = function unknown(allow) {

                            var value = allow !== false;

                            if (this._flags.allowUnknown === value) {
                                return this;
                            }

                            var obj = this.clone();
                            obj._flags.allowUnknown = value;
                            return obj;
                        };

                        _class.prototype.length = function length(limit) {

                            Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');

                            return this._test('length', limit, function (value, state, options) {

                                if (Object.keys(value).length === limit) {
                                    return value;
                                }

                                return this.createError('object.length', { limit: limit }, state, options);
                            });
                        };

                        _class.prototype.min = function min(limit) {

                            Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');

                            return this._test('min', limit, function (value, state, options) {

                                if (Object.keys(value).length >= limit) {
                                    return value;
                                }

                                return this.createError('object.min', { limit: limit }, state, options);
                            });
                        };

                        _class.prototype.max = function max(limit) {

                            Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');

                            return this._test('max', limit, function (value, state, options) {

                                if (Object.keys(value).length <= limit) {
                                    return value;
                                }

                                return this.createError('object.max', { limit: limit }, state, options);
                            });
                        };

                        _class.prototype.pattern = function pattern(_pattern, schema) {

                            var isRegExp = _pattern instanceof RegExp;
                            Hoek.assert(isRegExp || _pattern instanceof Any, 'pattern must be a regex or schema');
                            Hoek.assert(schema !== undefined, 'Invalid rule');

                            if (isRegExp) {
                                _pattern = new RegExp(_pattern.source, _pattern.ignoreCase ? 'i' : undefined); // Future version should break this and forbid unsupported regex flags
                            }

                            try {
                                schema = Cast.schema(this._currentJoi, schema);
                            } catch (castErr) {
                                if (castErr.hasOwnProperty('path')) {
                                    castErr.message = castErr.message + '(' + castErr.path + ')';
                                }

                                throw castErr;
                            }

                            var obj = this.clone();
                            if (isRegExp) {
                                obj._inner.patterns.push({ regex: _pattern, rule: schema });
                            } else {
                                obj._inner.patterns.push({ schema: _pattern, rule: schema });
                            }
                            return obj;
                        };

                        _class.prototype.schema = function schema() {

                            return this._test('schema', null, function (value, state, options) {

                                if (value instanceof Any) {
                                    return value;
                                }

                                return this.createError('object.schema', null, state, options);
                            });
                        };

                        _class.prototype.with = function _with(key, peers) {

                            Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');

                            return this._dependency('with', key, peers);
                        };

                        _class.prototype.without = function without(key, peers) {

                            Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');

                            return this._dependency('without', key, peers);
                        };

                        _class.prototype.xor = function xor() {
                            for (var _len2 = arguments.length, peers = Array(_len2), _key4 = 0; _key4 < _len2; _key4++) {
                                peers[_key4] = arguments[_key4];
                            }

                            peers = Hoek.flatten(peers);
                            return this._dependency('xor', null, peers);
                        };

                        _class.prototype.or = function or() {
                            for (var _len3 = arguments.length, peers = Array(_len3), _key5 = 0; _key5 < _len3; _key5++) {
                                peers[_key5] = arguments[_key5];
                            }

                            peers = Hoek.flatten(peers);
                            return this._dependency('or', null, peers);
                        };

                        _class.prototype.and = function and() {
                            for (var _len4 = arguments.length, peers = Array(_len4), _key6 = 0; _key6 < _len4; _key6++) {
                                peers[_key6] = arguments[_key6];
                            }

                            peers = Hoek.flatten(peers);
                            return this._dependency('and', null, peers);
                        };

                        _class.prototype.nand = function nand() {
                            for (var _len5 = arguments.length, peers = Array(_len5), _key7 = 0; _key7 < _len5; _key7++) {
                                peers[_key7] = arguments[_key7];
                            }

                            peers = Hoek.flatten(peers);
                            return this._dependency('nand', null, peers);
                        };

                        _class.prototype.requiredKeys = function requiredKeys() {
                            for (var _len6 = arguments.length, children = Array(_len6), _key8 = 0; _key8 < _len6; _key8++) {
                                children[_key8] = arguments[_key8];
                            }

                            children = Hoek.flatten(children);
                            return this.applyFunctionToChildren(children, 'required');
                        };

                        _class.prototype.optionalKeys = function optionalKeys() {
                            for (var _len7 = arguments.length, children = Array(_len7), _key9 = 0; _key9 < _len7; _key9++) {
                                children[_key9] = arguments[_key9];
                            }

                            children = Hoek.flatten(children);
                            return this.applyFunctionToChildren(children, 'optional');
                        };

                        _class.prototype.forbiddenKeys = function forbiddenKeys() {
                            for (var _len8 = arguments.length, children = Array(_len8), _key10 = 0; _key10 < _len8; _key10++) {
                                children[_key10] = arguments[_key10];
                            }

                            children = Hoek.flatten(children);
                            return this.applyFunctionToChildren(children, 'forbidden');
                        };

                        _class.prototype.rename = function rename(from, to, options) {

                            Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');
                            Hoek.assert(typeof to === 'string', 'Rename missing the to argument');
                            Hoek.assert(to !== from, 'Cannot rename key to same name:', from);

                            for (var i = 0; i < this._inner.renames.length; ++i) {
                                Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');
                            }

                            var obj = this.clone();

                            obj._inner.renames.push({
                                from: from,
                                to: to,
                                options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),
                                isRegExp: from instanceof RegExp
                            });

                            return obj;
                        };

                        _class.prototype.applyFunctionToChildren = function applyFunctionToChildren(children, fn, args, root) {

                            children = [].concat(children);
                            Hoek.assert(children.length > 0, 'expected at least one children');

                            var groupedChildren = internals.groupChildren(children);
                            var obj = void 0;

                            if ('' in groupedChildren) {
                                obj = this[fn].apply(this, args);
                                delete groupedChildren[''];
                            } else {
                                obj = this.clone();
                            }

                            if (obj._inner.children) {
                                root = root ? root + '.' : '';

                                for (var i = 0; i < obj._inner.children.length; ++i) {
                                    var child = obj._inner.children[i];
                                    var group = groupedChildren[child.key];

                                    if (group) {
                                        obj._inner.children[i] = {
                                            key: child.key,
                                            _refs: child._refs,
                                            schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)
                                        };

                                        delete groupedChildren[child.key];
                                    }
                                }
                            }

                            var remaining = Object.keys(groupedChildren);
                            Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));

                            return obj;
                        };

                        _class.prototype._dependency = function _dependency(type, key, peers) {

                            peers = [].concat(peers);
                            for (var i = 0; i < peers.length; ++i) {
                                Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');
                            }

                            var obj = this.clone();
                            obj._inner.dependencies.push({ type: type, key: key, peers: peers });
                            return obj;
                        };

                        _class.prototype.describe = function describe(shallow) {

                            var description = Any.prototype.describe.call(this);

                            if (description.rules) {
                                for (var i = 0; i < description.rules.length; ++i) {
                                    var rule = description.rules[i];
                                    // Coverage off for future-proof descriptions, only object().assert() is use right now
                                    if ( /* $lab:coverage:off$ */rule.arg && _typeof(rule.arg) === 'object' && rule.arg.schema && rule.arg.ref /* $lab:coverage:on$ */) {
                                        rule.arg = {
                                            schema: rule.arg.schema.describe(),
                                            ref: rule.arg.ref.toString()
                                        };
                                    }
                                }
                            }

                            if (this._inner.children && !shallow) {

                                description.children = {};
                                for (var _i7 = 0; _i7 < this._inner.children.length; ++_i7) {
                                    var child = this._inner.children[_i7];
                                    description.children[child.key] = child.schema.describe();
                                }
                            }

                            if (this._inner.dependencies.length) {
                                description.dependencies = Hoek.clone(this._inner.dependencies);
                            }

                            if (this._inner.patterns.length) {
                                description.patterns = [];

                                for (var _i8 = 0; _i8 < this._inner.patterns.length; ++_i8) {
                                    var pattern = this._inner.patterns[_i8];
                                    if (pattern.regex) {
                                        description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });
                                    } else {
                                        description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });
                                    }
                                }
                            }

                            if (this._inner.renames.length > 0) {
                                description.renames = Hoek.clone(this._inner.renames);
                            }

                            return description;
                        };

                        _class.prototype.assert = function assert(ref, schema, message) {

                            ref = Cast.ref(ref);
                            Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');
                            message = message || 'pass the assertion test';

                            try {
                                schema = Cast.schema(this._currentJoi, schema);
                            } catch (castErr) {
                                if (castErr.hasOwnProperty('path')) {
                                    castErr.message = castErr.message + '(' + castErr.path + ')';
                                }

                                throw castErr;
                            }

                            var key = ref.path[ref.path.length - 1];
                            var path = ref.path.join('.');

                            return this._test('assert', { schema: schema, ref: ref }, function (value, state, options) {

                                var result = schema._validate(ref(value), null, options, value);
                                if (!result.errors) {
                                    return value;
                                }

                                var localState = Hoek.merge({}, state);
                                localState.key = key;
                                localState.path = ref.path;
                                return this.createError('object.assert', { ref: path, message: message }, localState, options);
                            });
                        };

                        _class.prototype.type = function type(constructor) {
                            var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : constructor.name;


                            Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');
                            var typeData = {
                                name: name,
                                ctor: constructor
                            };

                            return this._test('type', typeData, function (value, state, options) {

                                if (value instanceof constructor) {
                                    return value;
                                }

                                return this.createError('object.type', { type: typeData.name }, state, options);
                            });
                        };

                        return _class;
                    }(Any);

                    internals.safeParse = function (value) {

                        try {
                            return JSON.parse(value);
                        } catch (parseErr) {}

                        return value;
                    };

                    internals.renameDefaults = {
                        alias: false, // Keep old value in place
                        multiple: false, // Allow renaming multiple keys into the same target
                        override: false // Overrides an existing key
                    };

                    internals.groupChildren = function (children) {

                        children.sort();

                        var grouped = {};

                        for (var i = 0; i < children.length; ++i) {
                            var child = children[i];
                            Hoek.assert(typeof child === 'string', 'children must be strings');
                            var group = child.split('.')[0];
                            var childGroup = grouped[group] = grouped[group] || [];
                            childGroup.push(child.substring(group.length + 1));
                        }

                        return grouped;
                    };

                    internals.keysToLabels = function (schema, keys) {

                        var children = schema._inner.children;

                        if (!children) {
                            return keys;
                        }

                        var findLabel = function findLabel(key) {

                            var matchingChild = children.find(function (child) {
                                return child.key === key;
                            });
                            return matchingChild ? matchingChild.schema._getLabel(key) : key;
                        };

                        if (Array.isArray(keys)) {
                            return keys.map(findLabel);
                        }

                        return findLabel(keys);
                    };

                    internals.with = function (value, peers, parent, state, options) {

                        if (value === undefined) {
                            return value;
                        }

                        for (var i = 0; i < peers.length; ++i) {
                            var peer = peers[i];
                            if (!Object.prototype.hasOwnProperty.call(parent, peer) || parent[peer] === undefined) {

                                return this.createError('object.with', {
                                    main: state.key,
                                    mainWithLabel: internals.keysToLabels(this, state.key),
                                    peer: peer,
                                    peerWithLabel: internals.keysToLabels(this, peer)
                                }, state, options);
                            }
                        }

                        return value;
                    };

                    internals.without = function (value, peers, parent, state, options) {

                        if (value === undefined) {
                            return value;
                        }

                        for (var i = 0; i < peers.length; ++i) {
                            var peer = peers[i];
                            if (Object.prototype.hasOwnProperty.call(parent, peer) && parent[peer] !== undefined) {

                                return this.createError('object.without', {
                                    main: state.key,
                                    mainWithLabel: internals.keysToLabels(this, state.key),
                                    peer: peer,
                                    peerWithLabel: internals.keysToLabels(this, peer)
                                }, state, options);
                            }
                        }

                        return value;
                    };

                    internals.xor = function (value, peers, parent, state, options) {

                        var present = [];
                        for (var i = 0; i < peers.length; ++i) {
                            var peer = peers[i];
                            if (Object.prototype.hasOwnProperty.call(parent, peer) && parent[peer] !== undefined) {

                                present.push(peer);
                            }
                        }

                        if (present.length === 1) {
                            return value;
                        }

                        var context = { peers: peers, peersWithLabels: internals.keysToLabels(this, peers) };

                        if (present.length === 0) {
                            return this.createError('object.missing', context, state, options);
                        }

                        return this.createError('object.xor', context, state, options);
                    };

                    internals.or = function (value, peers, parent, state, options) {

                        for (var i = 0; i < peers.length; ++i) {
                            var peer = peers[i];
                            if (Object.prototype.hasOwnProperty.call(parent, peer) && parent[peer] !== undefined) {
                                return value;
                            }
                        }

                        return this.createError('object.missing', {
                            peers: peers,
                            peersWithLabels: internals.keysToLabels(this, peers)
                        }, state, options);
                    };

                    internals.and = function (value, peers, parent, state, options) {

                        var missing = [];
                        var present = [];
                        var count = peers.length;
                        for (var i = 0; i < count; ++i) {
                            var peer = peers[i];
                            if (!Object.prototype.hasOwnProperty.call(parent, peer) || parent[peer] === undefined) {

                                missing.push(peer);
                            } else {
                                present.push(peer);
                            }
                        }

                        var aon = missing.length === count || present.length === count;

                        if (!aon) {

                            return this.createError('object.and', {
                                present: present,
                                presentWithLabels: internals.keysToLabels(this, present),
                                missing: missing,
                                missingWithLabels: internals.keysToLabels(this, missing)
                            }, state, options);
                        }
                    };

                    internals.nand = function (value, peers, parent, state, options) {

                        var present = [];
                        for (var i = 0; i < peers.length; ++i) {
                            var peer = peers[i];
                            if (Object.prototype.hasOwnProperty.call(parent, peer) && parent[peer] !== undefined) {

                                present.push(peer);
                            }
                        }

                        var values = Hoek.clone(peers);
                        var main = values.splice(0, 1)[0];
                        var allPresent = present.length === peers.length;
                        return allPresent ? this.createError('object.nand', {
                            main: main,
                            mainWithLabel: internals.keysToLabels(this, main),
                            peers: values,
                            peersWithLabels: internals.keysToLabels(this, values)
                        }, state, options) : null;
                    };

                    module.exports = new internals.Object();

                    /***/ }),
                /* 14 */
                /***/ (function(module, exports, __webpack_require__) {


// Load modules


// Delcare internals

                    var internals = {
                        rfc3986: {}
                    };

                    internals.generate = function () {

                        /**
                         * elements separated by forward slash ("/") are alternatives.
                         */
                        var or = '|';

                        /**
                         * Rule to support zero-padded addresses.
                         */
                        var zeroPad = '0?';

                        /**
                         * DIGIT = %x30-39 ; 0-9
                         */
                        var digit = '0-9';
                        var digitOnly = '[' + digit + ']';

                        /**
                         * ALPHA = %x41-5A / %x61-7A   ; A-Z / a-z
                         */
                        var alpha = 'a-zA-Z';
                        var alphaOnly = '[' + alpha + ']';

                        /**
                         * IPv4
                         * cidr       = DIGIT                ; 0-9
                         *            / %x31-32 DIGIT         ; 10-29
                         *            / "3" %x30-32           ; 30-32
                         */
                        internals.rfc3986.ipv4Cidr = digitOnly + or + '[1-2]' + digitOnly + or + '3' + '[0-2]';

                        /**
                         * IPv6
                         * cidr       = DIGIT                 ; 0-9
                         *            / %x31-39 DIGIT         ; 10-99
                         *            / "1" %x0-1 DIGIT       ; 100-119
                         *            / "12" %x0-8            ; 120-128
                         */
                        internals.rfc3986.ipv6Cidr = '(?:' + zeroPad + zeroPad + digitOnly + or + zeroPad + '[1-9]' + digitOnly + or + '1' + '[01]' + digitOnly + or + '12[0-8])';

                        /**
                         * HEXDIG = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
                         */
                        var hexDigit = digit + 'A-Fa-f';
                        var hexDigitOnly = '[' + hexDigit + ']';

                        /**
                         * unreserved = ALPHA / DIGIT / "-" / "." / "_" / "~"
                         */
                        var unreserved = alpha + digit + '-\\._~';

                        /**
                         * sub-delims = "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
                         */
                        var subDelims = '!\\$&\'\\(\\)\\*\\+,;=';

                        /**
                         * pct-encoded = "%" HEXDIG HEXDIG
                         */
                        var pctEncoded = '%' + hexDigit;

                        /**
                         * pchar = unreserved / pct-encoded / sub-delims / ":" / "@"
                         */
                        var pchar = unreserved + pctEncoded + subDelims + ':@';
                        var pcharOnly = '[' + pchar + ']';

                        /**
                         * dec-octet   = DIGIT                 ; 0-9
                         *            / %x31-39 DIGIT         ; 10-99
                         *            / "1" 2DIGIT            ; 100-199
                         *            / "2" %x30-34 DIGIT     ; 200-249
                         *            / "25" %x30-35          ; 250-255
                         */
                        var decOctect = '(?:' + zeroPad + zeroPad + digitOnly + or + zeroPad + '[1-9]' + digitOnly + or + '1' + digitOnly + digitOnly + or + '2' + '[0-4]' + digitOnly + or + '25' + '[0-5])';

                        /**
                         * IPv4address = dec-octet "." dec-octet "." dec-octet "." dec-octet
                         */
                        internals.rfc3986.IPv4address = '(?:' + decOctect + '\\.){3}' + decOctect;

                        /**
                         * h16 = 1*4HEXDIG ; 16 bits of address represented in hexadecimal
                         * ls32 = ( h16 ":" h16 ) / IPv4address ; least-significant 32 bits of address
                         * IPv6address =                            6( h16 ":" ) ls32
                         *             /                       "::" 5( h16 ":" ) ls32
                         *             / [               h16 ] "::" 4( h16 ":" ) ls32
                         *             / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
                         *             / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
                         *             / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
                         *             / [ *4( h16 ":" ) h16 ] "::"              ls32
                         *             / [ *5( h16 ":" ) h16 ] "::"              h16
                         *             / [ *6( h16 ":" ) h16 ] "::"
                         */
                        var h16 = hexDigitOnly + '{1,4}';
                        var ls32 = '(?:' + h16 + ':' + h16 + '|' + internals.rfc3986.IPv4address + ')';
                        var IPv6SixHex = '(?:' + h16 + ':){6}' + ls32;
                        var IPv6FiveHex = '::(?:' + h16 + ':){5}' + ls32;
                        var IPv6FourHex = '(?:' + h16 + ')?::(?:' + h16 + ':){4}' + ls32;
                        var IPv6ThreeHex = '(?:(?:' + h16 + ':){0,1}' + h16 + ')?::(?:' + h16 + ':){3}' + ls32;
                        var IPv6TwoHex = '(?:(?:' + h16 + ':){0,2}' + h16 + ')?::(?:' + h16 + ':){2}' + ls32;
                        var IPv6OneHex = '(?:(?:' + h16 + ':){0,3}' + h16 + ')?::' + h16 + ':' + ls32;
                        var IPv6NoneHex = '(?:(?:' + h16 + ':){0,4}' + h16 + ')?::' + ls32;
                        var IPv6NoneHex2 = '(?:(?:' + h16 + ':){0,5}' + h16 + ')?::' + h16;
                        var IPv6NoneHex3 = '(?:(?:' + h16 + ':){0,6}' + h16 + ')?::';
                        internals.rfc3986.IPv6address = '(?:' + IPv6SixHex + or + IPv6FiveHex + or + IPv6FourHex + or + IPv6ThreeHex + or + IPv6TwoHex + or + IPv6OneHex + or + IPv6NoneHex + or + IPv6NoneHex2 + or + IPv6NoneHex3 + ')';

                        /**
                         * IPvFuture = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )
                         */
                        internals.rfc3986.IPvFuture = 'v' + hexDigitOnly + '+\\.[' + unreserved + subDelims + ':]+';

                        /**
                         * scheme = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
                         */
                        internals.rfc3986.scheme = alphaOnly + '[' + alpha + digit + '+-\\.]*';

                        /**
                         * userinfo = *( unreserved / pct-encoded / sub-delims / ":" )
                         */
                        var userinfo = '[' + unreserved + pctEncoded + subDelims + ':]*';

                        /**
                         * IP-literal = "[" ( IPv6address / IPvFuture  ) "]"
                         */
                        var IPLiteral = '\\[(?:' + internals.rfc3986.IPv6address + or + internals.rfc3986.IPvFuture + ')\\]';

                        /**
                         * reg-name = *( unreserved / pct-encoded / sub-delims )
                         */
                        var regName = '[' + unreserved + pctEncoded + subDelims + ']{0,255}';

                        /**
                         * host = IP-literal / IPv4address / reg-name
                         */
                        var host = '(?:' + IPLiteral + or + internals.rfc3986.IPv4address + or + regName + ')';

                        /**
                         * port = *DIGIT
                         */
                        var port = digitOnly + '*';

                        /**
                         * authority   = [ userinfo "@" ] host [ ":" port ]
                         */
                        var authority = '(?:' + userinfo + '@)?' + host + '(?::' + port + ')?';

                        /**
                         * segment       = *pchar
                         * segment-nz    = 1*pchar
                         * path          = path-abempty    ; begins with "/" or is empty
                         *               / path-absolute   ; begins with "/" but not "//"
                         *               / path-noscheme   ; begins with a non-colon segment
                         *               / path-rootless   ; begins with a segment
                         *               / path-empty      ; zero characters
                         * path-abempty  = *( "/" segment )
                         * path-absolute = "/" [ segment-nz *( "/" segment ) ]
                         * path-rootless = segment-nz *( "/" segment )
                         */
                        var segment = pcharOnly + '*';
                        var segmentNz = pcharOnly + '+';
                        var segmentNzNc = '[' + unreserved + pctEncoded + subDelims + '@' + ']+';
                        var pathEmpty = '';
                        var pathAbEmpty = '(?:\\/' + segment + ')*';
                        var pathAbsolute = '\\/(?:' + segmentNz + pathAbEmpty + ')?';
                        var pathRootless = segmentNz + pathAbEmpty;
                        var pathNoScheme = segmentNzNc + pathAbEmpty;

                        /**
                         * hier-part = "//" authority path
                         */
                        internals.rfc3986.hierPart = '(?:' + '(?:\\/\\/' + authority + pathAbEmpty + ')' + or + pathAbsolute + or + pathRootless + ')';

                        /**
                         * relative-part = "//" authority path-abempty
                         *                 / path-absolute
                         *                 / path-noscheme
                         *                 / path-empty
                         */
                        internals.rfc3986.relativeRef = '(?:' + '(?:\\/\\/' + authority + pathAbEmpty + ')' + or + pathAbsolute + or + pathNoScheme + or + pathEmpty + ')';

                        /**
                         * query = *( pchar / "/" / "?" )
                         */
                        internals.rfc3986.query = '[' + pchar + '\\/\\?]*(?=#|$)'; //Finish matching either at the fragment part or end of the line.

                        /**
                         * fragment = *( pchar / "/" / "?" )
                         */
                        internals.rfc3986.fragment = '[' + pchar + '\\/\\?]*';
                    };

                    internals.generate();

                    module.exports = internals.rfc3986;

                    /***/ }),
                /* 15 */
                /***/ (function(module, exports) {



                    /***/ }),
                /* 16 */
                /***/ (function(module, exports, __webpack_require__) {

                    /* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

                        var formatRegExp = /%[sdj%]/g;
                        exports.format = function(f) {
                            if (!isString(f)) {
                                var objects = [];
                                for (var i = 0; i < arguments.length; i++) {
                                    objects.push(inspect(arguments[i]));
                                }
                                return objects.join(' ');
                            }

                            var i = 1;
                            var args = arguments;
                            var len = args.length;
                            var str = String(f).replace(formatRegExp, function(x) {
                                if (x === '%%') return '%';
                                if (i >= len) return x;
                                switch (x) {
                                    case '%s': return String(args[i++]);
                                    case '%d': return Number(args[i++]);
                                    case '%j':
                                        try {
                                            return JSON.stringify(args[i++]);
                                        } catch (_) {
                                            return '[Circular]';
                                        }
                                    default:
                                        return x;
                                }
                            });
                            for (var x = args[i]; i < len; x = args[++i]) {
                                if (isNull(x) || !isObject(x)) {
                                    str += ' ' + x;
                                } else {
                                    str += ' ' + inspect(x);
                                }
                            }
                            return str;
                        };


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
                        exports.deprecate = function(fn, msg) {
                            // Allow for deprecating things in the process of starting up.
                            if (isUndefined(global.process)) {
                                return function() {
                                    return exports.deprecate(fn, msg).apply(this, arguments);
                                };
                            }

                            if (process.noDeprecation === true) {
                                return fn;
                            }

                            var warned = false;
                            function deprecated() {
                                if (!warned) {
                                    if (process.throwDeprecation) {
                                        throw new Error(msg);
                                    } else if (process.traceDeprecation) {
                                        console.trace(msg);
                                    } else {
                                        console.error(msg);
                                    }
                                    warned = true;
                                }
                                return fn.apply(this, arguments);
                            }

                            return deprecated;
                        };


                        var debugs = {};
                        var debugEnviron;
                        exports.debuglog = function(set) {
                            if (isUndefined(debugEnviron))
                                debugEnviron = process.env.NODE_DEBUG || '';
                            set = set.toUpperCase();
                            if (!debugs[set]) {
                                if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
                                    var pid = process.pid;
                                    debugs[set] = function() {
                                        var msg = exports.format.apply(exports, arguments);
                                        console.error('%s %d: %s', set, pid, msg);
                                    };
                                } else {
                                    debugs[set] = function() {};
                                }
                            }
                            return debugs[set];
                        };


                        /**
                         * Echos the value of a value. Trys to print the value out
                         * in the best way possible given the different types.
                         *
                         * @param {Object} obj The object to print out.
                         * @param {Object} opts Optional options object that alters the output.
                         */
                        /* legacy: obj, showHidden, depth, colors*/
                        function inspect(obj, opts) {
                            // default options
                            var ctx = {
                                seen: [],
                                stylize: stylizeNoColor
                            };
                            // legacy...
                            if (arguments.length >= 3) ctx.depth = arguments[2];
                            if (arguments.length >= 4) ctx.colors = arguments[3];
                            if (isBoolean(opts)) {
                                // legacy...
                                ctx.showHidden = opts;
                            } else if (opts) {
                                // got an "options" object
                                exports._extend(ctx, opts);
                            }
                            // set default options
                            if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
                            if (isUndefined(ctx.depth)) ctx.depth = 2;
                            if (isUndefined(ctx.colors)) ctx.colors = false;
                            if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
                            if (ctx.colors) ctx.stylize = stylizeWithColor;
                            return formatValue(ctx, obj, ctx.depth);
                        }
                        exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
                        inspect.colors = {
                            'bold' : [1, 22],
                            'italic' : [3, 23],
                            'underline' : [4, 24],
                            'inverse' : [7, 27],
                            'white' : [37, 39],
                            'grey' : [90, 39],
                            'black' : [30, 39],
                            'blue' : [34, 39],
                            'cyan' : [36, 39],
                            'green' : [32, 39],
                            'magenta' : [35, 39],
                            'red' : [31, 39],
                            'yellow' : [33, 39]
                        };

// Don't use 'blue' not visible on cmd.exe
                        inspect.styles = {
                            'special': 'cyan',
                            'number': 'yellow',
                            'boolean': 'yellow',
                            'undefined': 'grey',
                            'null': 'bold',
                            'string': 'green',
                            'date': 'magenta',
                            // "name": intentionally not styling
                            'regexp': 'red'
                        };


                        function stylizeWithColor(str, styleType) {
                            var style = inspect.styles[styleType];

                            if (style) {
                                return '\u001b[' + inspect.colors[style][0] + 'm' + str +
                                    '\u001b[' + inspect.colors[style][1] + 'm';
                            } else {
                                return str;
                            }
                        }


                        function stylizeNoColor(str, styleType) {
                            return str;
                        }


                        function arrayToHash(array) {
                            var hash = {};

                            array.forEach(function(val, idx) {
                                hash[val] = true;
                            });

                            return hash;
                        }


                        function formatValue(ctx, value, recurseTimes) {
                            // Provide a hook for user-specified inspect functions.
                            // Check that value is an object with an inspect function on it
                            if (ctx.customInspect &&
                                value &&
                                isFunction(value.inspect) &&
                                // Filter out the util module, it's inspect function is special
                                value.inspect !== exports.inspect &&
                                // Also filter out any prototype objects using the circular check.
                                !(value.constructor && value.constructor.prototype === value)) {
                                var ret = value.inspect(recurseTimes, ctx);
                                if (!isString(ret)) {
                                    ret = formatValue(ctx, ret, recurseTimes);
                                }
                                return ret;
                            }

                            // Primitive types cannot have properties
                            var primitive = formatPrimitive(ctx, value);
                            if (primitive) {
                                return primitive;
                            }

                            // Look up the keys of the object.
                            var keys = Object.keys(value);
                            var visibleKeys = arrayToHash(keys);

                            if (ctx.showHidden) {
                                keys = Object.getOwnPropertyNames(value);
                            }

                            // IE doesn't make error fields non-enumerable
                            // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
                            if (isError(value)
                                && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
                                return formatError(value);
                            }

                            // Some type of object without properties can be shortcutted.
                            if (keys.length === 0) {
                                if (isFunction(value)) {
                                    var name = value.name ? ': ' + value.name : '';
                                    return ctx.stylize('[Function' + name + ']', 'special');
                                }
                                if (isRegExp(value)) {
                                    return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                                }
                                if (isDate(value)) {
                                    return ctx.stylize(Date.prototype.toString.call(value), 'date');
                                }
                                if (isError(value)) {
                                    return formatError(value);
                                }
                            }

                            var base = '', array = false, braces = ['{', '}'];

                            // Make Array say that they are Array
                            if (isArray(value)) {
                                array = true;
                                braces = ['[', ']'];
                            }

                            // Make functions say that they are functions
                            if (isFunction(value)) {
                                var n = value.name ? ': ' + value.name : '';
                                base = ' [Function' + n + ']';
                            }

                            // Make RegExps say that they are RegExps
                            if (isRegExp(value)) {
                                base = ' ' + RegExp.prototype.toString.call(value);
                            }

                            // Make dates with properties first say the date
                            if (isDate(value)) {
                                base = ' ' + Date.prototype.toUTCString.call(value);
                            }

                            // Make error with message first say the error
                            if (isError(value)) {
                                base = ' ' + formatError(value);
                            }

                            if (keys.length === 0 && (!array || value.length == 0)) {
                                return braces[0] + base + braces[1];
                            }

                            if (recurseTimes < 0) {
                                if (isRegExp(value)) {
                                    return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                                } else {
                                    return ctx.stylize('[Object]', 'special');
                                }
                            }

                            ctx.seen.push(value);

                            var output;
                            if (array) {
                                output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
                            } else {
                                output = keys.map(function(key) {
                                    return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                                });
                            }

                            ctx.seen.pop();

                            return reduceToSingleString(output, base, braces);
                        }


                        function formatPrimitive(ctx, value) {
                            if (isUndefined(value))
                                return ctx.stylize('undefined', 'undefined');
                            if (isString(value)) {
                                var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                    .replace(/'/g, "\\'")
                                    .replace(/\\"/g, '"') + '\'';
                                return ctx.stylize(simple, 'string');
                            }
                            if (isNumber(value))
                                return ctx.stylize('' + value, 'number');
                            if (isBoolean(value))
                                return ctx.stylize('' + value, 'boolean');
                            // For some reason typeof null is "object", so special case here.
                            if (isNull(value))
                                return ctx.stylize('null', 'null');
                        }


                        function formatError(value) {
                            return '[' + Error.prototype.toString.call(value) + ']';
                        }


                        function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
                            var output = [];
                            for (var i = 0, l = value.length; i < l; ++i) {
                                if (hasOwnProperty(value, String(i))) {
                                    output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                                        String(i), true));
                                } else {
                                    output.push('');
                                }
                            }
                            keys.forEach(function(key) {
                                if (!key.match(/^\d+$/)) {
                                    output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                                        key, true));
                                }
                            });
                            return output;
                        }


                        function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
                            var name, str, desc;
                            desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
                            if (desc.get) {
                                if (desc.set) {
                                    str = ctx.stylize('[Getter/Setter]', 'special');
                                } else {
                                    str = ctx.stylize('[Getter]', 'special');
                                }
                            } else {
                                if (desc.set) {
                                    str = ctx.stylize('[Setter]', 'special');
                                }
                            }
                            if (!hasOwnProperty(visibleKeys, key)) {
                                name = '[' + key + ']';
                            }
                            if (!str) {
                                if (ctx.seen.indexOf(desc.value) < 0) {
                                    if (isNull(recurseTimes)) {
                                        str = formatValue(ctx, desc.value, null);
                                    } else {
                                        str = formatValue(ctx, desc.value, recurseTimes - 1);
                                    }
                                    if (str.indexOf('\n') > -1) {
                                        if (array) {
                                            str = str.split('\n').map(function(line) {
                                                return '  ' + line;
                                            }).join('\n').substr(2);
                                        } else {
                                            str = '\n' + str.split('\n').map(function(line) {
                                                return '   ' + line;
                                            }).join('\n');
                                        }
                                    }
                                } else {
                                    str = ctx.stylize('[Circular]', 'special');
                                }
                            }
                            if (isUndefined(name)) {
                                if (array && key.match(/^\d+$/)) {
                                    return str;
                                }
                                name = JSON.stringify('' + key);
                                if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                                    name = name.substr(1, name.length - 2);
                                    name = ctx.stylize(name, 'name');
                                } else {
                                    name = name.replace(/'/g, "\\'")
                                        .replace(/\\"/g, '"')
                                        .replace(/(^"|"$)/g, "'");
                                    name = ctx.stylize(name, 'string');
                                }
                            }

                            return name + ': ' + str;
                        }


                        function reduceToSingleString(output, base, braces) {
                            var length = output.reduce(function(prev, cur) {
                                if (cur.indexOf('\n') >= 0) ;
                                return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
                            }, 0);

                            if (length > 60) {
                                return braces[0] +
                                    (base === '' ? '' : base + '\n ') +
                                    ' ' +
                                    output.join(',\n  ') +
                                    ' ' +
                                    braces[1];
                            }

                            return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
                        }


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
                        function isArray(ar) {
                            return Array.isArray(ar);
                        }
                        exports.isArray = isArray;

                        function isBoolean(arg) {
                            return typeof arg === 'boolean';
                        }
                        exports.isBoolean = isBoolean;

                        function isNull(arg) {
                            return arg === null;
                        }
                        exports.isNull = isNull;

                        function isNullOrUndefined(arg) {
                            return arg == null;
                        }
                        exports.isNullOrUndefined = isNullOrUndefined;

                        function isNumber(arg) {
                            return typeof arg === 'number';
                        }
                        exports.isNumber = isNumber;

                        function isString(arg) {
                            return typeof arg === 'string';
                        }
                        exports.isString = isString;

                        function isSymbol(arg) {
                            return typeof arg === 'symbol';
                        }
                        exports.isSymbol = isSymbol;

                        function isUndefined(arg) {
                            return arg === void 0;
                        }
                        exports.isUndefined = isUndefined;

                        function isRegExp(re) {
                            return isObject(re) && objectToString(re) === '[object RegExp]';
                        }
                        exports.isRegExp = isRegExp;

                        function isObject(arg) {
                            return typeof arg === 'object' && arg !== null;
                        }
                        exports.isObject = isObject;

                        function isDate(d) {
                            return isObject(d) && objectToString(d) === '[object Date]';
                        }
                        exports.isDate = isDate;

                        function isError(e) {
                            return isObject(e) &&
                                (objectToString(e) === '[object Error]' || e instanceof Error);
                        }
                        exports.isError = isError;

                        function isFunction(arg) {
                            return typeof arg === 'function';
                        }
                        exports.isFunction = isFunction;

                        function isPrimitive(arg) {
                            return arg === null ||
                                typeof arg === 'boolean' ||
                                typeof arg === 'number' ||
                                typeof arg === 'string' ||
                                typeof arg === 'symbol' ||  // ES6 symbol
                                typeof arg === 'undefined';
                        }
                        exports.isPrimitive = isPrimitive;

                        exports.isBuffer = __webpack_require__(40);

                        function objectToString(o) {
                            return Object.prototype.toString.call(o);
                        }


                        function pad(n) {
                            return n < 10 ? '0' + n.toString(10) : n.toString(10);
                        }


                        var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
                            'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
                        function timestamp() {
                            var d = new Date();
                            var time = [pad(d.getHours()),
                                pad(d.getMinutes()),
                                pad(d.getSeconds())].join(':');
                            return [d.getDate(), months[d.getMonth()], time].join(' ');
                        }


// log is just a thin wrapper to console.log that prepends a timestamp
                        exports.log = function() {
                            console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
                        };


                        /**
                         * Inherit the prototype methods from one constructor into another.
                         *
                         * The Function.prototype.inherits from lang.js rewritten as a standalone
                         * function (not on Function.prototype). NOTE: If this file is to be loaded
                         * during bootstrapping this function needs to be rewritten using some native
                         * functions as prototype setup using normal JavaScript does not work as
                         * expected during bootstrapping (see mirror.js in r114903).
                         *
                         * @param {function} ctor Constructor function which needs to inherit the
                         *     prototype.
                         * @param {function} superCtor Constructor function to inherit prototype from.
                         */
                        exports.inherits = __webpack_require__(39);

                        exports._extend = function(origin, add) {
                            // Don't do anything if add isn't an object
                            if (!add || !isObject(add)) return origin;

                            var keys = Object.keys(add);
                            var i = keys.length;
                            while (i--) {
                                origin[keys[i]] = add[keys[i]];
                            }
                            return origin;
                        };

                        function hasOwnProperty(obj, prop) {
                            return Object.prototype.hasOwnProperty.call(obj, prop);
                        }

                        /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5), __webpack_require__(7)));

                    /***/ }),
                /* 17 */
                /***/ (function(module, exports, __webpack_require__) {
                    /* WEBPACK VAR INJECTION */(function(global) {

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

                        /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
                        function compare(a, b) {
                            if (a === b) {
                                return 0;
                            }

                            var x = a.length;
                            var y = b.length;

                            for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                                if (a[i] !== b[i]) {
                                    x = a[i];
                                    y = b[i];
                                    break;
                                }
                            }

                            if (x < y) {
                                return -1;
                            }
                            if (y < x) {
                                return 1;
                            }
                            return 0;
                        }
                        function isBuffer(b) {
                            if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
                                return global.Buffer.isBuffer(b);
                            }
                            return !!(b != null && b._isBuffer);
                        }

// based on node assert, original notice:

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

                        var util = __webpack_require__(16);
                        var hasOwn = Object.prototype.hasOwnProperty;
                        var pSlice = Array.prototype.slice;
                        var functionsHaveNames = (function () {
                            return function foo() {}.name === 'foo';
                        }());
                        function pToString (obj) {
                            return Object.prototype.toString.call(obj);
                        }
                        function isView(arrbuf) {
                            if (isBuffer(arrbuf)) {
                                return false;
                            }
                            if (typeof global.ArrayBuffer !== 'function') {
                                return false;
                            }
                            if (typeof ArrayBuffer.isView === 'function') {
                                return ArrayBuffer.isView(arrbuf);
                            }
                            if (!arrbuf) {
                                return false;
                            }
                            if (arrbuf instanceof DataView) {
                                return true;
                            }
                            if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
                                return true;
                            }
                            return false;
                        }
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

                        var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

                        var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
                        function getName(func) {
                            if (!util.isFunction(func)) {
                                return;
                            }
                            if (functionsHaveNames) {
                                return func.name;
                            }
                            var str = func.toString();
                            var match = str.match(regex);
                            return match && match[1];
                        }
                        assert.AssertionError = function AssertionError(options) {
                            this.name = 'AssertionError';
                            this.actual = options.actual;
                            this.expected = options.expected;
                            this.operator = options.operator;
                            if (options.message) {
                                this.message = options.message;
                                this.generatedMessage = false;
                            } else {
                                this.message = getMessage(this);
                                this.generatedMessage = true;
                            }
                            var stackStartFunction = options.stackStartFunction || fail;
                            if (Error.captureStackTrace) {
                                Error.captureStackTrace(this, stackStartFunction);
                            } else {
                                // non v8 browsers so we can have a stacktrace
                                var err = new Error();
                                if (err.stack) {
                                    var out = err.stack;

                                    // try to strip useless frames
                                    var fn_name = getName(stackStartFunction);
                                    var idx = out.indexOf('\n' + fn_name);
                                    if (idx >= 0) {
                                        // once we have located the function frame
                                        // we need to strip out everything before it (and its line)
                                        var next_line = out.indexOf('\n', idx + 1);
                                        out = out.substring(next_line + 1);
                                    }

                                    this.stack = out;
                                }
                            }
                        };

// assert.AssertionError instanceof Error
                        util.inherits(assert.AssertionError, Error);

                        function truncate(s, n) {
                            if (typeof s === 'string') {
                                return s.length < n ? s : s.slice(0, n);
                            } else {
                                return s;
                            }
                        }
                        function inspect(something) {
                            if (functionsHaveNames || !util.isFunction(something)) {
                                return util.inspect(something);
                            }
                            var rawname = getName(something);
                            var name = rawname ? ': ' + rawname : '';
                            return '[Function' +  name + ']';
                        }
                        function getMessage(self) {
                            return truncate(inspect(self.actual), 128) + ' ' +
                                self.operator + ' ' +
                                truncate(inspect(self.expected), 128);
                        }

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

                        function fail(actual, expected, message, operator, stackStartFunction) {
                            throw new assert.AssertionError({
                                message: message,
                                actual: actual,
                                expected: expected,
                                operator: operator,
                                stackStartFunction: stackStartFunction
                            });
                        }

// EXTENSION! allows for well behaved errors defined elsewhere.
                        assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

                        function ok(value, message) {
                            if (!value) fail(value, true, message, '==', assert.ok);
                        }
                        assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

                        assert.equal = function equal(actual, expected, message) {
                            if (actual != expected) fail(actual, expected, message, '==', assert.equal);
                        };

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

                        assert.notEqual = function notEqual(actual, expected, message) {
                            if (actual == expected) {
                                fail(actual, expected, message, '!=', assert.notEqual);
                            }
                        };

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

                        assert.deepEqual = function deepEqual(actual, expected, message) {
                            if (!_deepEqual(actual, expected, false)) {
                                fail(actual, expected, message, 'deepEqual', assert.deepEqual);
                            }
                        };

                        assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
                            if (!_deepEqual(actual, expected, true)) {
                                fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
                            }
                        };

                        function _deepEqual(actual, expected, strict, memos) {
                            // 7.1. All identical values are equivalent, as determined by ===.
                            if (actual === expected) {
                                return true;
                            } else if (isBuffer(actual) && isBuffer(expected)) {
                                return compare(actual, expected) === 0;

                                // 7.2. If the expected value is a Date object, the actual value is
                                // equivalent if it is also a Date object that refers to the same time.
                            } else if (util.isDate(actual) && util.isDate(expected)) {
                                return actual.getTime() === expected.getTime();

                                // 7.3 If the expected value is a RegExp object, the actual value is
                                // equivalent if it is also a RegExp object with the same source and
                                // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
                            } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
                                return actual.source === expected.source &&
                                    actual.global === expected.global &&
                                    actual.multiline === expected.multiline &&
                                    actual.lastIndex === expected.lastIndex &&
                                    actual.ignoreCase === expected.ignoreCase;

                                // 7.4. Other pairs that do not both pass typeof value == 'object',
                                // equivalence is determined by ==.
                            } else if ((actual === null || typeof actual !== 'object') &&
                                (expected === null || typeof expected !== 'object')) {
                                return strict ? actual === expected : actual == expected;

                                // If both values are instances of typed arrays, wrap their underlying
                                // ArrayBuffers in a Buffer each to increase performance
                                // This optimization requires the arrays to have the same type as checked by
                                // Object.prototype.toString (aka pToString). Never perform binary
                                // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
                                // bit patterns are not identical.
                            } else if (isView(actual) && isView(expected) &&
                                pToString(actual) === pToString(expected) &&
                                !(actual instanceof Float32Array ||
                                    actual instanceof Float64Array)) {
                                return compare(new Uint8Array(actual.buffer),
                                    new Uint8Array(expected.buffer)) === 0;

                                // 7.5 For all other Object pairs, including Array objects, equivalence is
                                // determined by having the same number of owned properties (as verified
                                // with Object.prototype.hasOwnProperty.call), the same set of keys
                                // (although not necessarily the same order), equivalent values for every
                                // corresponding key, and an identical 'prototype' property. Note: this
                                // accounts for both named and indexed properties on Arrays.
                            } else if (isBuffer(actual) !== isBuffer(expected)) {
                                return false;
                            } else {
                                memos = memos || {actual: [], expected: []};

                                var actualIndex = memos.actual.indexOf(actual);
                                if (actualIndex !== -1) {
                                    if (actualIndex === memos.expected.indexOf(expected)) {
                                        return true;
                                    }
                                }

                                memos.actual.push(actual);
                                memos.expected.push(expected);

                                return objEquiv(actual, expected, strict, memos);
                            }
                        }

                        function isArguments(object) {
                            return Object.prototype.toString.call(object) == '[object Arguments]';
                        }

                        function objEquiv(a, b, strict, actualVisitedObjects) {
                            if (a === null || a === undefined || b === null || b === undefined)
                                return false;
                            // if one is a primitive, the other must be same
                            if (util.isPrimitive(a) || util.isPrimitive(b))
                                return a === b;
                            if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
                                return false;
                            var aIsArgs = isArguments(a);
                            var bIsArgs = isArguments(b);
                            if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
                                return false;
                            if (aIsArgs) {
                                a = pSlice.call(a);
                                b = pSlice.call(b);
                                return _deepEqual(a, b, strict);
                            }
                            var ka = objectKeys(a);
                            var kb = objectKeys(b);
                            var key, i;
                            // having the same number of owned properties (keys incorporates
                            // hasOwnProperty)
                            if (ka.length !== kb.length)
                                return false;
                            //the same set of keys (although not necessarily the same order),
                            ka.sort();
                            kb.sort();
                            //~~~cheap key test
                            for (i = ka.length - 1; i >= 0; i--) {
                                if (ka[i] !== kb[i])
                                    return false;
                            }
                            //equivalent values for every corresponding key, and
                            //~~~possibly expensive deep test
                            for (i = ka.length - 1; i >= 0; i--) {
                                key = ka[i];
                                if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
                                    return false;
                            }
                            return true;
                        }

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

                        assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
                            if (_deepEqual(actual, expected, false)) {
                                fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
                            }
                        };

                        assert.notDeepStrictEqual = notDeepStrictEqual;
                        function notDeepStrictEqual(actual, expected, message) {
                            if (_deepEqual(actual, expected, true)) {
                                fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
                            }
                        }


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

                        assert.strictEqual = function strictEqual(actual, expected, message) {
                            if (actual !== expected) {
                                fail(actual, expected, message, '===', assert.strictEqual);
                            }
                        };

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

                        assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
                            if (actual === expected) {
                                fail(actual, expected, message, '!==', assert.notStrictEqual);
                            }
                        };

                        function expectedException(actual, expected) {
                            if (!actual || !expected) {
                                return false;
                            }

                            if (Object.prototype.toString.call(expected) == '[object RegExp]') {
                                return expected.test(actual);
                            }

                            try {
                                if (actual instanceof expected) {
                                    return true;
                                }
                            } catch (e) {
                                // Ignore.  The instanceof check doesn't work for arrow functions.
                            }

                            if (Error.isPrototypeOf(expected)) {
                                return false;
                            }

                            return expected.call({}, actual) === true;
                        }

                        function _tryBlock(block) {
                            var error;
                            try {
                                block();
                            } catch (e) {
                                error = e;
                            }
                            return error;
                        }

                        function _throws(shouldThrow, block, expected, message) {
                            var actual;

                            if (typeof block !== 'function') {
                                throw new TypeError('"block" argument must be a function');
                            }

                            if (typeof expected === 'string') {
                                message = expected;
                                expected = null;
                            }

                            actual = _tryBlock(block);

                            message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
                                (message ? ' ' + message : '.');

                            if (shouldThrow && !actual) {
                                fail(actual, expected, 'Missing expected exception' + message);
                            }

                            var userProvidedMessage = typeof message === 'string';
                            var isUnwantedException = !shouldThrow && util.isError(actual);
                            var isUnexpectedException = !shouldThrow && actual && !expected;

                            if ((isUnwantedException &&
                                    userProvidedMessage &&
                                    expectedException(actual, expected)) ||
                                isUnexpectedException) {
                                fail(actual, expected, 'Got unwanted exception' + message);
                            }

                            if ((shouldThrow && actual && expected &&
                                !expectedException(actual, expected)) || (!shouldThrow && actual)) {
                                throw actual;
                            }
                        }

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

                        assert.throws = function(block, /*optional*/error, /*optional*/message) {
                            _throws(true, block, error, message);
                        };

// EXTENSION! This is annoying to write outside this module.
                        assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
                            _throws(false, block, error, message);
                        };

                        assert.ifError = function(err) { if (err) throw err; };

                        var objectKeys = Object.keys || function (obj) {
                            var keys = [];
                            for (var key in obj) {
                                if (hasOwn.call(obj, key)) keys.push(key);
                            }
                            return keys;
                        };

                        /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)));

                    /***/ }),
                /* 18 */
                /***/ (function(module, exports, __webpack_require__) {
                    /* WEBPACK VAR INJECTION */(function(Buffer) {

// Declare internals

                        var internals = {};

                        exports.escapeJavaScript = function (input) {

                            if (!input) {
                                return '';
                            }

                            var escaped = '';

                            for (var i = 0; i < input.length; ++i) {

                                var charCode = input.charCodeAt(i);

                                if (internals.isSafe(charCode)) {
                                    escaped += input[i];
                                } else {
                                    escaped += internals.escapeJavaScriptChar(charCode);
                                }
                            }

                            return escaped;
                        };

                        exports.escapeHtml = function (input) {

                            if (!input) {
                                return '';
                            }

                            var escaped = '';

                            for (var i = 0; i < input.length; ++i) {

                                var charCode = input.charCodeAt(i);

                                if (internals.isSafe(charCode)) {
                                    escaped += input[i];
                                } else {
                                    escaped += internals.escapeHtmlChar(charCode);
                                }
                            }

                            return escaped;
                        };

                        exports.escapeJson = function (input) {

                            if (!input) {
                                return '';
                            }

                            var lessThan = 0x3C;
                            var greaterThan = 0x3E;
                            var andSymbol = 0x26;
                            var lineSeperator = 0x2028;

                            // replace method
                            var charCode = void 0;
                            return input.replace(/[<>&\u2028\u2029]/g, function (match) {

                                charCode = match.charCodeAt(0);

                                if (charCode === lessThan) {
                                    return '\\u003c';
                                } else if (charCode === greaterThan) {
                                    return '\\u003e';
                                } else if (charCode === andSymbol) {
                                    return '\\u0026';
                                } else if (charCode === lineSeperator) {
                                    return '\\u2028';
                                }
                                return '\\u2029';
                            });
                        };

                        internals.escapeJavaScriptChar = function (charCode) {

                            if (charCode >= 256) {
                                return '\\u' + internals.padLeft('' + charCode, 4);
                            }

                            var hexValue = Buffer.from(String.fromCharCode(charCode), 'ascii').toString('hex');
                            return '\\x' + internals.padLeft(hexValue, 2);
                        };

                        internals.escapeHtmlChar = function (charCode) {

                            var namedEscape = internals.namedHtml[charCode];
                            if (typeof namedEscape !== 'undefined') {
                                return namedEscape;
                            }

                            if (charCode >= 256) {
                                return '&#' + charCode + ';';
                            }

                            var hexValue = Buffer.from(String.fromCharCode(charCode), 'ascii').toString('hex');
                            return '&#x' + internals.padLeft(hexValue, 2) + ';';
                        };

                        internals.padLeft = function (str, len) {

                            while (str.length < len) {
                                str = '0' + str;
                            }

                            return str;
                        };

                        internals.isSafe = function (charCode) {

                            return typeof internals.safeCharCodes[charCode] !== 'undefined';
                        };

                        internals.namedHtml = {
                            '38': '&amp;',
                            '60': '&lt;',
                            '62': '&gt;',
                            '34': '&quot;',
                            '160': '&nbsp;',
                            '162': '&cent;',
                            '163': '&pound;',
                            '164': '&curren;',
                            '169': '&copy;',
                            '174': '&reg;'
                        };

                        internals.safeCharCodes = function () {

                            var safe = {};

                            for (var i = 32; i < 123; ++i) {

                                if (i >= 97 || // a-z
                                    i >= 65 && i <= 90 || // A-Z
                                    i >= 48 && i <= 57 || // 0-9
                                    i === 32 || // space
                                    i === 46 || // .
                                    i === 44 || // ,
                                    i === 45 || // -
                                    i === 58 || // :
                                    i === 95) {
                                    // _

                                    safe[i] = null;
                                }
                            }

                            return safe;
                        }();
                        /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).Buffer));

                    /***/ }),
                /* 19 */
                /***/ (function(module, exports, __webpack_require__) {
                    /* WEBPACK VAR INJECTION */(function(Buffer) {

// Load modules

                        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

                        var Punycode = __webpack_require__(38);

// Declare internals

                        var internals = {
                            hasOwn: Object.prototype.hasOwnProperty,
                            indexOf: Array.prototype.indexOf,
                            defaultThreshold: 16,
                            maxIPv6Groups: 8,

                            categories: {
                                valid: 1,
                                dnsWarn: 7,
                                rfc5321: 15,
                                cfws: 31,
                                deprecated: 63,
                                rfc5322: 127,
                                error: 255
                            },

                            diagnoses: {

                                // Address is valid

                                valid: 0,

                                // Address is valid for SMTP but has unusual elements

                                rfc5321TLD: 9,
                                rfc5321TLDNumeric: 10,
                                rfc5321QuotedString: 11,
                                rfc5321AddressLiteral: 12,

                                // Address is valid for message, but must be modified for envelope

                                cfwsComment: 17,
                                cfwsFWS: 18,

                                // Address contains non-ASCII when the allowUnicode option is false
                                // Has to be > internals.defaultThreshold so that it's rejected
                                // without an explicit errorLevel:
                                undesiredNonAscii: 25,

                                // Address contains deprecated elements, but may still be valid in some contexts

                                deprecatedLocalPart: 33,
                                deprecatedFWS: 34,
                                deprecatedQTEXT: 35,
                                deprecatedQP: 36,
                                deprecatedComment: 37,
                                deprecatedCTEXT: 38,
                                deprecatedIPv6: 39,
                                deprecatedCFWSNearAt: 49,

                                // Address is only valid according to broad definition in RFC 5322, but is otherwise invalid

                                rfc5322Domain: 65,
                                rfc5322TooLong: 66,
                                rfc5322LocalTooLong: 67,
                                rfc5322DomainTooLong: 68,
                                rfc5322LabelTooLong: 69,
                                rfc5322DomainLiteral: 70,
                                rfc5322DomainLiteralOBSDText: 71,
                                rfc5322IPv6GroupCount: 72,
                                rfc5322IPv62x2xColon: 73,
                                rfc5322IPv6BadCharacter: 74,
                                rfc5322IPv6MaxGroups: 75,
                                rfc5322IPv6ColonStart: 76,
                                rfc5322IPv6ColonEnd: 77,

                                // Address is invalid for any purpose

                                errExpectingDTEXT: 129,
                                errNoLocalPart: 130,
                                errNoDomain: 131,
                                errConsecutiveDots: 132,
                                errATEXTAfterCFWS: 133,
                                errATEXTAfterQS: 134,
                                errATEXTAfterDomainLiteral: 135,
                                errExpectingQPair: 136,
                                errExpectingATEXT: 137,
                                errExpectingQTEXT: 138,
                                errExpectingCTEXT: 139,
                                errBackslashEnd: 140,
                                errDotStart: 141,
                                errDotEnd: 142,
                                errDomainHyphenStart: 143,
                                errDomainHyphenEnd: 144,
                                errUnclosedQuotedString: 145,
                                errUnclosedComment: 146,
                                errUnclosedDomainLiteral: 147,
                                errFWSCRLFx2: 148,
                                errFWSCRLFEnd: 149,
                                errCRNoLF: 150,
                                errUnknownTLD: 160,
                                errDomainTooShort: 161
                            },

                            components: {
                                localpart: 0,
                                domain: 1,
                                literal: 2,
                                contextComment: 3,
                                contextFWS: 4,
                                contextQuotedString: 5,
                                contextQuotedPair: 6
                            }
                        };

                        internals.specials = function () {

                            var specials = '()<>[]:;@\\,."'; // US-ASCII visible characters not valid for atext (http://tools.ietf.org/html/rfc5322#section-3.2.3)
                            var lookup = new Array(0x100);
                            lookup.fill(false);

                            for (var i = 0; i < specials.length; ++i) {
                                lookup[specials.codePointAt(i)] = true;
                            }

                            return function (code) {

                                return lookup[code];
                            };
                        }();

                        internals.c0Controls = function () {

                            var lookup = new Array(0x100);
                            lookup.fill(false);

                            // add C0 control characters

                            for (var i = 0; i < 33; ++i) {
                                lookup[i] = true;
                            }

                            return function (code) {

                                return lookup[code];
                            };
                        }();

                        internals.c1Controls = function () {

                            var lookup = new Array(0x100);
                            lookup.fill(false);

                            // add C1 control characters

                            for (var i = 127; i < 160; ++i) {
                                lookup[i] = true;
                            }

                            return function (code) {

                                return lookup[code];
                            };
                        }();

                        internals.regex = {
                            ipV4: /\b(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
                            ipV6: /^[a-fA-F\d]{0,4}$/
                        };

                        internals.normalizeSupportsNul = '\0'.normalize('NFC') === '\0';

// $lab:coverage:off$
                        internals.nulNormalize = function (email) {

                            return email.split('\0').map(function (part) {
                                return part.normalize('NFC');
                            }).join('\0');
                        };
// $lab:coverage:on$


                        internals.normalize = function (email) {

                            // $lab:coverage:off$
                            if (!internals.normalizeSupportsNul && email.indexOf('\0') >= 0) {
                                return internals.nulNormalize(email);
                            }
                            // $lab:coverage:on$

                            return email.normalize('NFC');
                        };

                        internals.checkIpV6 = function (items) {

                            return items.every(function (value) {
                                return internals.regex.ipV6.test(value);
                            });
                        };

                        internals.validDomain = function (tldAtom, options) {

                            if (options.tldBlacklist) {
                                if (Array.isArray(options.tldBlacklist)) {
                                    return internals.indexOf.call(options.tldBlacklist, tldAtom) === -1;
                                }

                                return !internals.hasOwn.call(options.tldBlacklist, tldAtom);
                            }

                            if (Array.isArray(options.tldWhitelist)) {
                                return internals.indexOf.call(options.tldWhitelist, tldAtom) !== -1;
                            }

                            return internals.hasOwn.call(options.tldWhitelist, tldAtom);
                        };

                        /**
                         * Check that an email address conforms to RFCs 5321, 5322, 6530 and others
                         *
                         * We distinguish clearly between a Mailbox as defined by RFC 5321 and an
                         * addr-spec as defined by RFC 5322. Depending on the context, either can be
                         * regarded as a valid email address. The RFC 5321 Mailbox specification is
                         * more restrictive (comments, white space and obsolete forms are not allowed).
                         *
                         * @param {string} email The email address to check. See README for specifics.
                         * @param {Object} options The (optional) options:
                         *   {*} errorLevel Determines the boundary between valid and invalid
                         *     addresses.
                         *   {*} tldBlacklist The set of domains to consider invalid.
                         *   {*} tldWhitelist The set of domains to consider valid.
                         *   {*} allowUnicode Whether to allow non-ASCII characters, defaults to true.
                         *   {*} minDomainAtoms The minimum number of domain atoms which must be present
                         *     for the address to be valid.
                         * @param {function(number|boolean)} callback The (optional) callback handler.
                         * @return {*}
                         */

                        exports.validate = internals.validate = function (email, options, callback) {

                            options = options || {};
                            email = internals.normalize(email);

                            // The callback function is deprecated.
                            // $lab:coverage:off$
                            if (typeof options === 'function') {
                                callback = options;
                                options = {};
                            }

                            if (typeof callback !== 'function') {
                                callback = null;
                            }
                            // $lab:coverage:on$

                            var diagnose = void 0;
                            var threshold = void 0;

                            if (typeof options.errorLevel === 'number') {
                                diagnose = true;
                                threshold = options.errorLevel;
                            } else {
                                diagnose = !!options.errorLevel;
                                threshold = internals.diagnoses.valid;
                            }

                            if (options.tldWhitelist) {
                                if (typeof options.tldWhitelist === 'string') {
                                    options.tldWhitelist = [options.tldWhitelist];
                                } else if (_typeof(options.tldWhitelist) !== 'object') {
                                    throw new TypeError('expected array or object tldWhitelist');
                                }
                            }

                            if (options.tldBlacklist) {
                                if (typeof options.tldBlacklist === 'string') {
                                    options.tldBlacklist = [options.tldBlacklist];
                                } else if (_typeof(options.tldBlacklist) !== 'object') {
                                    throw new TypeError('expected array or object tldBlacklist');
                                }
                            }

                            if (options.minDomainAtoms && (options.minDomainAtoms !== (+options.minDomainAtoms | 0) || options.minDomainAtoms < 0)) {
                                throw new TypeError('expected positive integer minDomainAtoms');
                            }

                            var maxResult = internals.diagnoses.valid;
                            var updateResult = function updateResult(value) {

                                if (value > maxResult) {
                                    maxResult = value;
                                }
                            };

                            var allowUnicode = options.allowUnicode === undefined || !!options.allowUnicode;
                            if (!allowUnicode && /[^\x00-\x7f]/.test(email)) {
                                updateResult(internals.diagnoses.undesiredNonAscii);
                            }

                            var context = {
                                now: internals.components.localpart,
                                prev: internals.components.localpart,
                                stack: [internals.components.localpart]
                            };

                            var prevToken = '';

                            var parseData = {
                                local: '',
                                domain: ''
                            };
                            var atomData = {
                                locals: [''],
                                domains: ['']
                            };

                            var elementCount = 0;
                            var elementLength = 0;
                            var crlfCount = 0;
                            var charCode = void 0;

                            var hyphenFlag = false;
                            var assertEnd = false;

                            var emailLength = email.length;

                            var token = void 0; // Token is used outside the loop, must declare similarly
                            for (var i = 0; i < emailLength; i += token.length) {
                                // Utilize codepoints to account for Unicode surrogate pairs
                                token = String.fromCodePoint(email.codePointAt(i));

                                switch (context.now) {
                                    // Local-part
                                    case internals.components.localpart:
                                        // http://tools.ietf.org/html/rfc5322#section-3.4.1
                                        //   local-part      =   dot-atom / quoted-string / obs-local-part
                                        //
                                        //   dot-atom        =   [CFWS] dot-atom-text [CFWS]
                                        //
                                        //   dot-atom-text   =   1*atext *("." 1*atext)
                                        //
                                        //   quoted-string   =   [CFWS]
                                        //                       DQUOTE *([FWS] qcontent) [FWS] DQUOTE
                                        //                       [CFWS]
                                        //
                                        //   obs-local-part  =   word *("." word)
                                        //
                                        //   word            =   atom / quoted-string
                                        //
                                        //   atom            =   [CFWS] 1*atext [CFWS]
                                        switch (token) {
                                            // Comment
                                            case '(':
                                                if (elementLength === 0) {
                                                    // Comments are OK at the beginning of an element
                                                    updateResult(elementCount === 0 ? internals.diagnoses.cfwsComment : internals.diagnoses.deprecatedComment);
                                                } else {
                                                    updateResult(internals.diagnoses.cfwsComment);
                                                    // Cannot start a comment in an element, should be end
                                                    assertEnd = true;
                                                }

                                                context.stack.push(context.now);
                                                context.now = internals.components.contextComment;
                                                break;

                                            // Next dot-atom element
                                            case '.':
                                                if (elementLength === 0) {
                                                    // Another dot, already?
                                                    updateResult(elementCount === 0 ? internals.diagnoses.errDotStart : internals.diagnoses.errConsecutiveDots);
                                                } else {
                                                    // The entire local-part can be a quoted string for RFC 5321; if one atom is quoted it's an RFC 5322 obsolete form
                                                    if (assertEnd) {
                                                        updateResult(internals.diagnoses.deprecatedLocalPart);
                                                    }

                                                    // CFWS & quoted strings are OK again now we're at the beginning of an element (although they are obsolete forms)
                                                    assertEnd = false;
                                                    elementLength = 0;
                                                    ++elementCount;
                                                    parseData.local += token;
                                                    atomData.locals[elementCount] = '';
                                                }

                                                break;

                                            // Quoted string
                                            case '"':
                                                if (elementLength === 0) {
                                                    // The entire local-part can be a quoted string for RFC 5321; if one atom is quoted it's an RFC 5322 obsolete form
                                                    updateResult(elementCount === 0 ? internals.diagnoses.rfc5321QuotedString : internals.diagnoses.deprecatedLocalPart);

                                                    parseData.local += token;
                                                    atomData.locals[elementCount] += token;
                                                    elementLength += Buffer.byteLength(token, 'utf8');

                                                    // Quoted string must be the entire element
                                                    assertEnd = true;
                                                    context.stack.push(context.now);
                                                    context.now = internals.components.contextQuotedString;
                                                } else {
                                                    updateResult(internals.diagnoses.errExpectingATEXT);
                                                }

                                                break;

                                            // Folding white space
                                            case '\r':
                                                if (emailLength === ++i || email[i] !== '\n') {
                                                    // Fatal error
                                                    updateResult(internals.diagnoses.errCRNoLF);
                                                    break;
                                                }

                                            // Fallthrough

                                            case ' ':
                                            case '\t':
                                                if (elementLength === 0) {
                                                    updateResult(elementCount === 0 ? internals.diagnoses.cfwsFWS : internals.diagnoses.deprecatedFWS);
                                                } else {
                                                    // We can't start FWS in the middle of an element, better be end
                                                    assertEnd = true;
                                                }

                                                context.stack.push(context.now);
                                                context.now = internals.components.contextFWS;
                                                prevToken = token;
                                                break;

                                            case '@':
                                                // At this point we should have a valid local-part
                                                // $lab:coverage:off$
                                                if (context.stack.length !== 1) {
                                                    throw new Error('unexpected item on context stack');
                                                }
                                                // $lab:coverage:on$

                                                if (parseData.local.length === 0) {
                                                    // Fatal error
                                                    updateResult(internals.diagnoses.errNoLocalPart);
                                                } else if (elementLength === 0) {
                                                    // Fatal error
                                                    updateResult(internals.diagnoses.errDotEnd);
                                                }
                                                    // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.1 the maximum total length of a user name or other local-part is 64
                                                //    octets
                                                else if (Buffer.byteLength(parseData.local, 'utf8') > 64) {
                                                    updateResult(internals.diagnoses.rfc5322LocalTooLong);
                                                }
                                                    // http://tools.ietf.org/html/rfc5322#section-3.4.1 comments and folding white space SHOULD NOT be used around "@" in the
                                                    //    addr-spec
                                                    //
                                                    // http://tools.ietf.org/html/rfc2119
                                                    // 4. SHOULD NOT this phrase, or the phrase "NOT RECOMMENDED" mean that there may exist valid reasons in particular
                                                    //    circumstances when the particular behavior is acceptable or even useful, but the full implications should be understood
                                                //    and the case carefully weighed before implementing any behavior described with this label.
                                                else if (context.prev === internals.components.contextComment || context.prev === internals.components.contextFWS) {
                                                    updateResult(internals.diagnoses.deprecatedCFWSNearAt);
                                                }

                                                // Clear everything down for the domain parsing
                                                context.now = internals.components.domain;
                                                context.stack[0] = internals.components.domain;
                                                elementCount = 0;
                                                elementLength = 0;
                                                assertEnd = false; // CFWS can only appear at the end of the element
                                                break;

                                            // ATEXT
                                            default:
                                                // http://tools.ietf.org/html/rfc5322#section-3.2.3
                                                //    atext = ALPHA / DIGIT / ; Printable US-ASCII
                                                //            "!" / "#" /     ;  characters not including
                                                //            "$" / "%" /     ;  specials.  Used for atoms.
                                                //            "&" / "'" /
                                                //            "*" / "+" /
                                                //            "-" / "/" /
                                                //            "=" / "?" /
                                                //            "^" / "_" /
                                                //            "`" / "{" /
                                                //            "|" / "}" /
                                                //            "~"
                                                if (assertEnd) {
                                                    // We have encountered atext where it is no longer valid
                                                    switch (context.prev) {
                                                        case internals.components.contextComment:
                                                        case internals.components.contextFWS:
                                                            updateResult(internals.diagnoses.errATEXTAfterCFWS);
                                                            break;

                                                        case internals.components.contextQuotedString:
                                                            updateResult(internals.diagnoses.errATEXTAfterQS);
                                                            break;

                                                        // $lab:coverage:off$
                                                        default:
                                                            throw new Error('more atext found where none is allowed, but unrecognized prev context: ' + context.prev);
                                                        // $lab:coverage:on$
                                                    }
                                                } else {
                                                    context.prev = context.now;
                                                    charCode = token.codePointAt(0);

                                                    // Especially if charCode == 10
                                                    if (internals.specials(charCode) || internals.c0Controls(charCode) || internals.c1Controls(charCode)) {

                                                        // Fatal error
                                                        updateResult(internals.diagnoses.errExpectingATEXT);
                                                    }

                                                    parseData.local += token;
                                                    atomData.locals[elementCount] += token;
                                                    elementLength += Buffer.byteLength(token, 'utf8');
                                                }
                                        }

                                        break;

                                    case internals.components.domain:
                                        // http://tools.ietf.org/html/rfc5322#section-3.4.1
                                        //   domain          =   dot-atom / domain-literal / obs-domain
                                        //
                                        //   dot-atom        =   [CFWS] dot-atom-text [CFWS]
                                        //
                                        //   dot-atom-text   =   1*atext *("." 1*atext)
                                        //
                                        //   domain-literal  =   [CFWS] "[" *([FWS] dtext) [FWS] "]" [CFWS]
                                        //
                                        //   dtext           =   %d33-90 /          ; Printable US-ASCII
                                        //                       %d94-126 /         ;  characters not including
                                        //                       obs-dtext          ;  "[", "]", or "\"
                                        //
                                        //   obs-domain      =   atom *("." atom)
                                        //
                                        //   atom            =   [CFWS] 1*atext [CFWS]

                                        // http://tools.ietf.org/html/rfc5321#section-4.1.2
                                        //   Mailbox        = Local-part "@" ( Domain / address-literal )
                                        //
                                        //   Domain         = sub-domain *("." sub-domain)
                                        //
                                        //   address-literal  = "[" ( IPv4-address-literal /
                                        //                    IPv6-address-literal /
                                        //                    General-address-literal ) "]"
                                        //                    ; See Section 4.1.3

                                        // http://tools.ietf.org/html/rfc5322#section-3.4.1
                                        //      Note: A liberal syntax for the domain portion of addr-spec is
                                        //      given here.  However, the domain portion contains addressing
                                        //      information specified by and used in other protocols (e.g.,
                                        //      [RFC1034], [RFC1035], [RFC1123], [RFC5321]).  It is therefore
                                        //      incumbent upon implementations to conform to the syntax of
                                        //      addresses for the context in which they are used.
                                        //
                                        // is_email() author's note: it's not clear how to interpret this in
                                        // he context of a general email address validator. The conclusion I
                                        // have reached is this: "addressing information" must comply with
                                        // RFC 5321 (and in turn RFC 1035), anything that is "semantically
                                        // invisible" must comply only with RFC 5322.
                                        switch (token) {
                                            // Comment
                                            case '(':
                                                if (elementLength === 0) {
                                                    // Comments at the start of the domain are deprecated in the text, comments at the start of a subdomain are obs-domain
                                                    // http://tools.ietf.org/html/rfc5322#section-3.4.1
                                                    updateResult(elementCount === 0 ? internals.diagnoses.deprecatedCFWSNearAt : internals.diagnoses.deprecatedComment);
                                                } else {
                                                    // We can't start a comment mid-element, better be at the end
                                                    assertEnd = true;
                                                    updateResult(internals.diagnoses.cfwsComment);
                                                }

                                                context.stack.push(context.now);
                                                context.now = internals.components.contextComment;
                                                break;

                                            // Next dot-atom element
                                            case '.':
                                                var punycodeLength = Punycode.encode(atomData.domains[elementCount]).length;
                                                if (elementLength === 0) {
                                                    // Another dot, already? Fatal error.
                                                    updateResult(elementCount === 0 ? internals.diagnoses.errDotStart : internals.diagnoses.errConsecutiveDots);
                                                } else if (hyphenFlag) {
                                                    // Previous subdomain ended in a hyphen. Fatal error.
                                                    updateResult(internals.diagnoses.errDomainHyphenEnd);
                                                } else if (punycodeLength > 63) {
                                                    // RFC 5890 specifies that domain labels that are encoded using the Punycode algorithm
                                                    // must adhere to the <= 63 octet requirement.
                                                    // This includes string prefixes from the Punycode algorithm.
                                                    //
                                                    // https://tools.ietf.org/html/rfc5890#section-2.3.2.1
                                                    // labels          63 octets or less

                                                    updateResult(internals.diagnoses.rfc5322LabelTooLong);
                                                }

                                                // CFWS is OK again now we're at the beginning of an element (although
                                                // it may be obsolete CFWS)
                                                assertEnd = false;
                                                elementLength = 0;
                                                ++elementCount;
                                                atomData.domains[elementCount] = '';
                                                parseData.domain += token;

                                                break;

                                            // Domain literal
                                            case '[':
                                                if (parseData.domain.length === 0) {
                                                    // Domain literal must be the only component
                                                    assertEnd = true;
                                                    elementLength += Buffer.byteLength(token, 'utf8');
                                                    context.stack.push(context.now);
                                                    context.now = internals.components.literal;
                                                    parseData.domain += token;
                                                    atomData.domains[elementCount] += token;
                                                    parseData.literal = '';
                                                } else {
                                                    // Fatal error
                                                    updateResult(internals.diagnoses.errExpectingATEXT);
                                                }

                                                break;

                                            // Folding white space
                                            case '\r':
                                                if (emailLength === ++i || email[i] !== '\n') {
                                                    // Fatal error
                                                    updateResult(internals.diagnoses.errCRNoLF);
                                                    break;
                                                }

                                            // Fallthrough

                                            case ' ':
                                            case '\t':
                                                if (elementLength === 0) {
                                                    updateResult(elementCount === 0 ? internals.diagnoses.deprecatedCFWSNearAt : internals.diagnoses.deprecatedFWS);
                                                } else {
                                                    // We can't start FWS in the middle of an element, so this better be the end
                                                    updateResult(internals.diagnoses.cfwsFWS);
                                                    assertEnd = true;
                                                }

                                                context.stack.push(context.now);
                                                context.now = internals.components.contextFWS;
                                                prevToken = token;
                                                break;

                                            // This must be ATEXT
                                            default:
                                                // RFC 5322 allows any atext...
                                                // http://tools.ietf.org/html/rfc5322#section-3.2.3
                                                //    atext = ALPHA / DIGIT / ; Printable US-ASCII
                                                //            "!" / "#" /     ;  characters not including
                                                //            "$" / "%" /     ;  specials.  Used for atoms.
                                                //            "&" / "'" /
                                                //            "*" / "+" /
                                                //            "-" / "/" /
                                                //            "=" / "?" /
                                                //            "^" / "_" /
                                                //            "`" / "{" /
                                                //            "|" / "}" /
                                                //            "~"

                                                // But RFC 5321 only allows letter-digit-hyphen to comply with DNS rules
                                                //   (RFCs 1034 & 1123)
                                                // http://tools.ietf.org/html/rfc5321#section-4.1.2
                                                //   sub-domain     = Let-dig [Ldh-str]
                                                //
                                                //   Let-dig        = ALPHA / DIGIT
                                                //
                                                //   Ldh-str        = *( ALPHA / DIGIT / "-" ) Let-dig
                                                //
                                                if (assertEnd) {
                                                    // We have encountered ATEXT where it is no longer valid
                                                    switch (context.prev) {
                                                        case internals.components.contextComment:
                                                        case internals.components.contextFWS:
                                                            updateResult(internals.diagnoses.errATEXTAfterCFWS);
                                                            break;

                                                        case internals.components.literal:
                                                            updateResult(internals.diagnoses.errATEXTAfterDomainLiteral);
                                                            break;

                                                        // $lab:coverage:off$
                                                        default:
                                                            throw new Error('more atext found where none is allowed, but unrecognized prev context: ' + context.prev);
                                                        // $lab:coverage:on$
                                                    }
                                                }

                                                charCode = token.codePointAt(0);
                                                // Assume this token isn't a hyphen unless we discover it is
                                                hyphenFlag = false;

                                                if (internals.specials(charCode) || internals.c0Controls(charCode) || internals.c1Controls(charCode)) {
                                                    // Fatal error
                                                    updateResult(internals.diagnoses.errExpectingATEXT);
                                                } else if (token === '-') {
                                                    if (elementLength === 0) {
                                                        // Hyphens cannot be at the beginning of a subdomain, fatal error
                                                        updateResult(internals.diagnoses.errDomainHyphenStart);
                                                    }

                                                    hyphenFlag = true;
                                                }
                                                // Check if it's a neither a number nor a latin/unicode letter
                                                else if (charCode < 48 || charCode > 122 && charCode < 192 || charCode > 57 && charCode < 65 || charCode > 90 && charCode < 97) {
                                                    // This is not an RFC 5321 subdomain, but still OK by RFC 5322
                                                    updateResult(internals.diagnoses.rfc5322Domain);
                                                }

                                                parseData.domain += token;
                                                atomData.domains[elementCount] += token;
                                                elementLength += Buffer.byteLength(token, 'utf8');
                                        }

                                        break;

                                    // Domain literal
                                    case internals.components.literal:
                                        // http://tools.ietf.org/html/rfc5322#section-3.4.1
                                        //   domain-literal  =   [CFWS] "[" *([FWS] dtext) [FWS] "]" [CFWS]
                                        //
                                        //   dtext           =   %d33-90 /          ; Printable US-ASCII
                                        //                       %d94-126 /         ;  characters not including
                                        //                       obs-dtext          ;  "[", "]", or "\"
                                        //
                                        //   obs-dtext       =   obs-NO-WS-CTL / quoted-pair
                                        switch (token) {
                                            // End of domain literal
                                            case ']':
                                                if (maxResult < internals.categories.deprecated) {
                                                    // Could be a valid RFC 5321 address literal, so let's check

                                                    // http://tools.ietf.org/html/rfc5321#section-4.1.2
                                                    //   address-literal  = "[" ( IPv4-address-literal /
                                                    //                    IPv6-address-literal /
                                                    //                    General-address-literal ) "]"
                                                    //                    ; See Section 4.1.3
                                                    //
                                                    // http://tools.ietf.org/html/rfc5321#section-4.1.3
                                                    //   IPv4-address-literal  = Snum 3("."  Snum)
                                                    //
                                                    //   IPv6-address-literal  = "IPv6:" IPv6-addr
                                                    //
                                                    //   General-address-literal  = Standardized-tag ":" 1*dcontent
                                                    //
                                                    //   Standardized-tag  = Ldh-str
                                                    //                     ; Standardized-tag MUST be specified in a
                                                    //                     ; Standards-Track RFC and registered with IANA
                                                    //
                                                    //   dcontent      = %d33-90 / ; Printable US-ASCII
                                                    //                 %d94-126 ; excl. "[", "\", "]"
                                                    //
                                                    //   Snum          = 1*3DIGIT
                                                    //                 ; representing a decimal integer
                                                    //                 ; value in the range 0 through 255
                                                    //
                                                    //   IPv6-addr     = IPv6-full / IPv6-comp / IPv6v4-full / IPv6v4-comp
                                                    //
                                                    //   IPv6-hex      = 1*4HEXDIG
                                                    //
                                                    //   IPv6-full     = IPv6-hex 7(":" IPv6-hex)
                                                    //
                                                    //   IPv6-comp     = [IPv6-hex *5(":" IPv6-hex)] "::"
                                                    //                 [IPv6-hex *5(":" IPv6-hex)]
                                                    //                 ; The "::" represents at least 2 16-bit groups of
                                                    //                 ; zeros.  No more than 6 groups in addition to the
                                                    //                 ; "::" may be present.
                                                    //
                                                    //   IPv6v4-full   = IPv6-hex 5(":" IPv6-hex) ":" IPv4-address-literal
                                                    //
                                                    //   IPv6v4-comp   = [IPv6-hex *3(":" IPv6-hex)] "::"
                                                    //                 [IPv6-hex *3(":" IPv6-hex) ":"]
                                                    //                 IPv4-address-literal
                                                    //                 ; The "::" represents at least 2 16-bit groups of
                                                    //                 ; zeros.  No more than 4 groups in addition to the
                                                    //                 ; "::" and IPv4-address-literal may be present.

                                                    var index = -1;
                                                    var addressLiteral = parseData.literal;
                                                    var matchesIP = internals.regex.ipV4.exec(addressLiteral);

                                                    // Maybe extract IPv4 part from the end of the address-literal
                                                    if (matchesIP) {
                                                        index = matchesIP.index;
                                                        if (index !== 0) {
                                                            // Convert IPv4 part to IPv6 format for futher testing
                                                            addressLiteral = addressLiteral.slice(0, index) + '0:0';
                                                        }
                                                    }

                                                    if (index === 0) {
                                                        // Nothing there except a valid IPv4 address, so...
                                                        updateResult(internals.diagnoses.rfc5321AddressLiteral);
                                                    } else if (addressLiteral.slice(0, 5).toLowerCase() !== 'ipv6:') {
                                                        updateResult(internals.diagnoses.rfc5322DomainLiteral);
                                                    } else {
                                                        var match = addressLiteral.slice(5);
                                                        var maxGroups = internals.maxIPv6Groups;
                                                        var groups = match.split(':');
                                                        index = match.indexOf('::');

                                                        if (!~index) {
                                                            // Need exactly the right number of groups
                                                            if (groups.length !== maxGroups) {
                                                                updateResult(internals.diagnoses.rfc5322IPv6GroupCount);
                                                            }
                                                        } else if (index !== match.lastIndexOf('::')) {
                                                            updateResult(internals.diagnoses.rfc5322IPv62x2xColon);
                                                        } else {
                                                            if (index === 0 || index === match.length - 2) {
                                                                // RFC 4291 allows :: at the start or end of an address with 7 other groups in addition
                                                                ++maxGroups;
                                                            }

                                                            if (groups.length > maxGroups) {
                                                                updateResult(internals.diagnoses.rfc5322IPv6MaxGroups);
                                                            } else if (groups.length === maxGroups) {
                                                                // Eliding a single "::"
                                                                updateResult(internals.diagnoses.deprecatedIPv6);
                                                            }
                                                        }

                                                        // IPv6 testing strategy
                                                        if (match[0] === ':' && match[1] !== ':') {
                                                            updateResult(internals.diagnoses.rfc5322IPv6ColonStart);
                                                        } else if (match[match.length - 1] === ':' && match[match.length - 2] !== ':') {
                                                            updateResult(internals.diagnoses.rfc5322IPv6ColonEnd);
                                                        } else if (internals.checkIpV6(groups)) {
                                                            updateResult(internals.diagnoses.rfc5321AddressLiteral);
                                                        } else {
                                                            updateResult(internals.diagnoses.rfc5322IPv6BadCharacter);
                                                        }
                                                    }
                                                } else {
                                                    updateResult(internals.diagnoses.rfc5322DomainLiteral);
                                                }

                                                parseData.domain += token;
                                                atomData.domains[elementCount] += token;
                                                elementLength += Buffer.byteLength(token, 'utf8');
                                                context.prev = context.now;
                                                context.now = context.stack.pop();
                                                break;

                                            case '\\':
                                                updateResult(internals.diagnoses.rfc5322DomainLiteralOBSDText);
                                                context.stack.push(context.now);
                                                context.now = internals.components.contextQuotedPair;
                                                break;

                                            // Folding white space
                                            case '\r':
                                                if (emailLength === ++i || email[i] !== '\n') {
                                                    updateResult(internals.diagnoses.errCRNoLF);
                                                    break;
                                                }

                                            // Fallthrough

                                            case ' ':
                                            case '\t':
                                                updateResult(internals.diagnoses.cfwsFWS);

                                                context.stack.push(context.now);
                                                context.now = internals.components.contextFWS;
                                                prevToken = token;
                                                break;

                                            // DTEXT
                                            default:
                                                // http://tools.ietf.org/html/rfc5322#section-3.4.1
                                                //   dtext         =   %d33-90 /  ; Printable US-ASCII
                                                //                     %d94-126 / ;  characters not including
                                                //                     obs-dtext  ;  "[", "]", or "\"
                                                //
                                                //   obs-dtext     =   obs-NO-WS-CTL / quoted-pair
                                                //
                                                //   obs-NO-WS-CTL =   %d1-8 /    ; US-ASCII control
                                                //                     %d11 /     ;  characters that do not
                                                //                     %d12 /     ;  include the carriage
                                                //                     %d14-31 /  ;  return, line feed, and
                                                //                     %d127      ;  white space characters
                                                charCode = token.codePointAt(0);

                                                // '\r', '\n', ' ', and '\t' have already been parsed above
                                                if (charCode !== 127 && internals.c1Controls(charCode) || charCode === 0 || token === '[') {
                                                    // Fatal error
                                                    updateResult(internals.diagnoses.errExpectingDTEXT);
                                                    break;
                                                } else if (internals.c0Controls(charCode) || charCode === 127) {
                                                    updateResult(internals.diagnoses.rfc5322DomainLiteralOBSDText);
                                                }

                                                parseData.literal += token;
                                                parseData.domain += token;
                                                atomData.domains[elementCount] += token;
                                                elementLength += Buffer.byteLength(token, 'utf8');
                                        }

                                        break;

                                    // Quoted string
                                    case internals.components.contextQuotedString:
                                        // http://tools.ietf.org/html/rfc5322#section-3.2.4
                                        //   quoted-string = [CFWS]
                                        //                   DQUOTE *([FWS] qcontent) [FWS] DQUOTE
                                        //                   [CFWS]
                                        //
                                        //   qcontent      = qtext / quoted-pair
                                        switch (token) {
                                            // Quoted pair
                                            case '\\':
                                                context.stack.push(context.now);
                                                context.now = internals.components.contextQuotedPair;
                                                break;

                                            // Folding white space. Spaces are allowed as regular characters inside a quoted string - it's only FWS if we include '\t' or '\r\n'
                                            case '\r':
                                                if (emailLength === ++i || email[i] !== '\n') {
                                                    // Fatal error
                                                    updateResult(internals.diagnoses.errCRNoLF);
                                                    break;
                                                }

                                            // Fallthrough

                                            case '\t':
                                                // http://tools.ietf.org/html/rfc5322#section-3.2.2
                                                //   Runs of FWS, comment, or CFWS that occur between lexical tokens in
                                                //   a structured header field are semantically interpreted as a single
                                                //   space character.

                                                // http://tools.ietf.org/html/rfc5322#section-3.2.4
                                                //   the CRLF in any FWS/CFWS that appears within the quoted-string [is]
                                                //   semantically "invisible" and therefore not part of the
                                                //   quoted-string

                                                parseData.local += ' ';
                                                atomData.locals[elementCount] += ' ';
                                                elementLength += Buffer.byteLength(token, 'utf8');

                                                updateResult(internals.diagnoses.cfwsFWS);
                                                context.stack.push(context.now);
                                                context.now = internals.components.contextFWS;
                                                prevToken = token;
                                                break;

                                            // End of quoted string
                                            case '"':
                                                parseData.local += token;
                                                atomData.locals[elementCount] += token;
                                                elementLength += Buffer.byteLength(token, 'utf8');
                                                context.prev = context.now;
                                                context.now = context.stack.pop();
                                                break;

                                            // QTEXT
                                            default:
                                                // http://tools.ietf.org/html/rfc5322#section-3.2.4
                                                //   qtext          =   %d33 /             ; Printable US-ASCII
                                                //                      %d35-91 /          ;  characters not including
                                                //                      %d93-126 /         ;  "\" or the quote character
                                                //                      obs-qtext
                                                //
                                                //   obs-qtext      =   obs-NO-WS-CTL
                                                //
                                                //   obs-NO-WS-CTL  =   %d1-8 /            ; US-ASCII control
                                                //                      %d11 /             ;  characters that do not
                                                //                      %d12 /             ;  include the carriage
                                                //                      %d14-31 /          ;  return, line feed, and
                                                //                      %d127              ;  white space characters
                                                charCode = token.codePointAt(0);

                                                if (charCode !== 127 && internals.c1Controls(charCode) || charCode === 0 || charCode === 10) {
                                                    updateResult(internals.diagnoses.errExpectingQTEXT);
                                                } else if (internals.c0Controls(charCode) || charCode === 127) {
                                                    updateResult(internals.diagnoses.deprecatedQTEXT);
                                                }

                                                parseData.local += token;
                                                atomData.locals[elementCount] += token;
                                                elementLength += Buffer.byteLength(token, 'utf8');
                                        }

                                        // http://tools.ietf.org/html/rfc5322#section-3.4.1
                                        //   If the string can be represented as a dot-atom (that is, it contains
                                        //   no characters other than atext characters or "." surrounded by atext
                                        //   characters), then the dot-atom form SHOULD be used and the quoted-
                                        //   string form SHOULD NOT be used.

                                        break;
                                    // Quoted pair
                                    case internals.components.contextQuotedPair:
                                        // http://tools.ietf.org/html/rfc5322#section-3.2.1
                                        //   quoted-pair     =   ("\" (VCHAR / WSP)) / obs-qp
                                        //
                                        //   VCHAR           =  %d33-126   ; visible (printing) characters
                                        //   WSP             =  SP / HTAB  ; white space
                                        //
                                        //   obs-qp          =   "\" (%d0 / obs-NO-WS-CTL / LF / CR)
                                        //
                                        //   obs-NO-WS-CTL   =   %d1-8 /   ; US-ASCII control
                                        //                       %d11 /    ;  characters that do not
                                        //                       %d12 /    ;  include the carriage
                                        //                       %d14-31 / ;  return, line feed, and
                                        //                       %d127     ;  white space characters
                                        //
                                        // i.e. obs-qp       =  "\" (%d0-8, %d10-31 / %d127)
                                        charCode = token.codePointAt(0);

                                        if (charCode !== 127 && internals.c1Controls(charCode)) {
                                            // Fatal error
                                            updateResult(internals.diagnoses.errExpectingQPair);
                                        } else if (charCode < 31 && charCode !== 9 || charCode === 127) {
                                            // ' ' and '\t' are allowed
                                            updateResult(internals.diagnoses.deprecatedQP);
                                        }

                                        // At this point we know where this qpair occurred so we could check to see if the character actually needed to be quoted at all.
                                        // http://tools.ietf.org/html/rfc5321#section-4.1.2
                                        //   the sending system SHOULD transmit the form that uses the minimum quoting possible.

                                        context.prev = context.now;
                                        // End of qpair
                                        context.now = context.stack.pop();
                                        var escapeToken = '\\' + token;

                                        switch (context.now) {
                                            case internals.components.contextComment:
                                                break;

                                            case internals.components.contextQuotedString:
                                                parseData.local += escapeToken;
                                                atomData.locals[elementCount] += escapeToken;

                                                // The maximum sizes specified by RFC 5321 are octet counts, so we must include the backslash
                                                elementLength += 2;
                                                break;

                                            case internals.components.literal:
                                                parseData.domain += escapeToken;
                                                atomData.domains[elementCount] += escapeToken;

                                                // The maximum sizes specified by RFC 5321 are octet counts, so we must include the backslash
                                                elementLength += 2;
                                                break;

                                            // $lab:coverage:off$
                                            default:
                                                throw new Error('quoted pair logic invoked in an invalid context: ' + context.now);
                                            // $lab:coverage:on$
                                        }
                                        break;

                                    // Comment
                                    case internals.components.contextComment:
                                        // http://tools.ietf.org/html/rfc5322#section-3.2.2
                                        //   comment  = "(" *([FWS] ccontent) [FWS] ")"
                                        //
                                        //   ccontent = ctext / quoted-pair / comment
                                        switch (token) {
                                            // Nested comment
                                            case '(':
                                                // Nested comments are ok
                                                context.stack.push(context.now);
                                                context.now = internals.components.contextComment;
                                                break;

                                            // End of comment
                                            case ')':
                                                context.prev = context.now;
                                                context.now = context.stack.pop();
                                                break;

                                            // Quoted pair
                                            case '\\':
                                                context.stack.push(context.now);
                                                context.now = internals.components.contextQuotedPair;
                                                break;

                                            // Folding white space
                                            case '\r':
                                                if (emailLength === ++i || email[i] !== '\n') {
                                                    // Fatal error
                                                    updateResult(internals.diagnoses.errCRNoLF);
                                                    break;
                                                }

                                            // Fallthrough

                                            case ' ':
                                            case '\t':
                                                updateResult(internals.diagnoses.cfwsFWS);

                                                context.stack.push(context.now);
                                                context.now = internals.components.contextFWS;
                                                prevToken = token;
                                                break;

                                            // CTEXT
                                            default:
                                                // http://tools.ietf.org/html/rfc5322#section-3.2.3
                                                //   ctext         = %d33-39 /  ; Printable US-ASCII
                                                //                   %d42-91 /  ;  characters not including
                                                //                   %d93-126 / ;  "(", ")", or "\"
                                                //                   obs-ctext
                                                //
                                                //   obs-ctext     = obs-NO-WS-CTL
                                                //
                                                //   obs-NO-WS-CTL = %d1-8 /    ; US-ASCII control
                                                //                   %d11 /     ;  characters that do not
                                                //                   %d12 /     ;  include the carriage
                                                //                   %d14-31 /  ;  return, line feed, and
                                                //                   %d127      ;  white space characters
                                                charCode = token.codePointAt(0);

                                                if (charCode === 0 || charCode === 10 || charCode !== 127 && internals.c1Controls(charCode)) {
                                                    // Fatal error
                                                    updateResult(internals.diagnoses.errExpectingCTEXT);
                                                    break;
                                                } else if (internals.c0Controls(charCode) || charCode === 127) {
                                                    updateResult(internals.diagnoses.deprecatedCTEXT);
                                                }
                                        }

                                        break;

                                    // Folding white space
                                    case internals.components.contextFWS:
                                        // http://tools.ietf.org/html/rfc5322#section-3.2.2
                                        //   FWS     =   ([*WSP CRLF] 1*WSP) /  obs-FWS
                                        //                                   ; Folding white space

                                        // But note the erratum:
                                        // http://www.rfc-editor.org/errata_search.php?rfc=5322&eid=1908:
                                        //   In the obsolete syntax, any amount of folding white space MAY be
                                        //   inserted where the obs-FWS rule is allowed.  This creates the
                                        //   possibility of having two consecutive "folds" in a line, and
                                        //   therefore the possibility that a line which makes up a folded header
                                        //   field could be composed entirely of white space.
                                        //
                                        //   obs-FWS =   1*([CRLF] WSP)

                                        if (prevToken === '\r') {
                                            if (token === '\r') {
                                                // Fatal error
                                                updateResult(internals.diagnoses.errFWSCRLFx2);
                                                break;
                                            }

                                            if (++crlfCount > 1) {
                                                // Multiple folds => obsolete FWS
                                                updateResult(internals.diagnoses.deprecatedFWS);
                                            } else {
                                                crlfCount = 1;
                                            }
                                        }

                                        switch (token) {
                                            case '\r':
                                                if (emailLength === ++i || email[i] !== '\n') {
                                                    // Fatal error
                                                    updateResult(internals.diagnoses.errCRNoLF);
                                                }

                                                break;

                                            case ' ':
                                            case '\t':
                                                break;

                                            default:
                                                if (prevToken === '\r') {
                                                    // Fatal error
                                                    updateResult(internals.diagnoses.errFWSCRLFEnd);
                                                }

                                                crlfCount = 0;

                                                // End of FWS
                                                context.prev = context.now;
                                                context.now = context.stack.pop();

                                                // Look at this token again in the parent context
                                                --i;
                                        }

                                        prevToken = token;
                                        break;

                                    // Unexpected context
                                    // $lab:coverage:off$
                                    default:
                                        throw new Error('unknown context: ' + context.now);
                                    // $lab:coverage:on$
                                } // Primary state machine

                                if (maxResult > internals.categories.rfc5322) {
                                    // Fatal error, no point continuing
                                    break;
                                }
                            } // Token loop

                            // Check for errors
                            if (maxResult < internals.categories.rfc5322) {
                                var _punycodeLength = Punycode.encode(parseData.domain).length;
                                // Fatal errors
                                if (context.now === internals.components.contextQuotedString) {
                                    updateResult(internals.diagnoses.errUnclosedQuotedString);
                                } else if (context.now === internals.components.contextQuotedPair) {
                                    updateResult(internals.diagnoses.errBackslashEnd);
                                } else if (context.now === internals.components.contextComment) {
                                    updateResult(internals.diagnoses.errUnclosedComment);
                                } else if (context.now === internals.components.literal) {
                                    updateResult(internals.diagnoses.errUnclosedDomainLiteral);
                                } else if (token === '\r') {
                                    updateResult(internals.diagnoses.errFWSCRLFEnd);
                                } else if (parseData.domain.length === 0) {
                                    updateResult(internals.diagnoses.errNoDomain);
                                } else if (elementLength === 0) {
                                    updateResult(internals.diagnoses.errDotEnd);
                                } else if (hyphenFlag) {
                                    updateResult(internals.diagnoses.errDomainHyphenEnd);
                                }

                                // Other errors
                                else if (_punycodeLength > 255) {
                                    // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.2
                                    //   The maximum total length of a domain name or number is 255 octets.
                                    updateResult(internals.diagnoses.rfc5322DomainTooLong);
                                } else if (Buffer.byteLength(parseData.local, 'utf8') + _punycodeLength + /* '@' */1 > 254) {
                                    // http://tools.ietf.org/html/rfc5321#section-4.1.2
                                    //   Forward-path   = Path
                                    //
                                    //   Path           = "<" [ A-d-l ":" ] Mailbox ">"
                                    //
                                    // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.3
                                    //   The maximum total length of a reverse-path or forward-path is 256 octets (including the punctuation and element separators).
                                    //
                                    // Thus, even without (obsolete) routing information, the Mailbox can only be 254 characters long. This is confirmed by this verified
                                    // erratum to RFC 3696:
                                    //
                                    // http://www.rfc-editor.org/errata_search.php?rfc=3696&eid=1690
                                    //   However, there is a restriction in RFC 2821 on the length of an address in MAIL and RCPT commands of 254 characters.  Since
                                    //   addresses that do not fit in those fields are not normally useful, the upper limit on address lengths should normally be considered
                                    //   to be 254.
                                    updateResult(internals.diagnoses.rfc5322TooLong);
                                } else if (elementLength > 63) {
                                    // http://tools.ietf.org/html/rfc1035#section-2.3.4
                                    // labels   63 octets or less
                                    updateResult(internals.diagnoses.rfc5322LabelTooLong);
                                } else if (options.minDomainAtoms && atomData.domains.length < options.minDomainAtoms) {
                                    updateResult(internals.diagnoses.errDomainTooShort);
                                } else if (options.tldWhitelist || options.tldBlacklist) {
                                    var tldAtom = atomData.domains[elementCount];

                                    if (!internals.validDomain(tldAtom, options)) {
                                        updateResult(internals.diagnoses.errUnknownTLD);
                                    }
                                }
                            } // Check for errors

                            // Finish
                            if (maxResult < internals.categories.dnsWarn) {
                                // Per RFC 5321, domain atoms are limited to letter-digit-hyphen, so we only need to check code <= 57 to check for a digit
                                var code = atomData.domains[elementCount].codePointAt(0);

                                if (code <= 57) {
                                    updateResult(internals.diagnoses.rfc5321TLDNumeric);
                                }
                            }

                            if (maxResult < threshold) {
                                maxResult = internals.diagnoses.valid;
                            }

                            var finishResult = diagnose ? maxResult : maxResult < internals.defaultThreshold;

                            // $lab:coverage:off$
                            if (callback) {
                                callback(finishResult);
                            }
                            // $lab:coverage:on$

                            return finishResult;
                        };

                        exports.diagnoses = internals.validate.diagnoses = function () {

                            var diag = {};
                            var keys = Object.keys(internals.diagnoses);
                            for (var i = 0; i < keys.length; ++i) {
                                var key = keys[i];
                                diag[key] = internals.diagnoses[key];
                            }

                            return diag;
                        }();

                        exports.normalize = internals.normalize;
                        /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).Buffer));

                    /***/ }),
                /* 20 */
                /***/ (function(module, exports, __webpack_require__) {

                    exports.errors = {
                        root: 'value',
                        key: '"{{!label}}" ',
                        messages: {
                            wrapArrays: true
                        },
                        any: {
                            unknown: 'is not allowed',
                            invalid: 'contains an invalid value',
                            empty: 'is not allowed to be empty',
                            required: 'is required',
                            allowOnly: 'must be one of {{valids}}',
                            default: 'threw an error when running default method'
                        },
                        alternatives: {
                            base: 'not matching any of the allowed alternatives',
                            child: null
                        },
                        array: {
                            base: 'must be an array',
                            includes: 'at position {{pos}} does not match any of the allowed types',
                            includesSingle: 'single value of "{{!label}}" does not match any of the allowed types',
                            includesOne: 'at position {{pos}} fails because {{reason}}',
                            includesOneSingle: 'single value of "{{!label}}" fails because {{reason}}',
                            includesRequiredUnknowns: 'does not contain {{unknownMisses}} required value(s)',
                            includesRequiredKnowns: 'does not contain {{knownMisses}}',
                            includesRequiredBoth: 'does not contain {{knownMisses}} and {{unknownMisses}} other required value(s)',
                            excludes: 'at position {{pos}} contains an excluded value',
                            excludesSingle: 'single value of "{{!label}}" contains an excluded value',
                            min: 'must contain at least {{limit}} items',
                            max: 'must contain less than or equal to {{limit}} items',
                            length: 'must contain {{limit}} items',
                            ordered: 'at position {{pos}} fails because {{reason}}',
                            orderedLength: 'at position {{pos}} fails because array must contain at most {{limit}} items',
                            ref: 'references "{{ref}}" which is not a positive integer',
                            sparse: 'must not be a sparse array',
                            unique: 'position {{pos}} contains a duplicate value'
                        },
                        boolean: {
                            base: 'must be a boolean'
                        },
                        binary: {
                            base: 'must be a buffer or a string',
                            min: 'must be at least {{limit}} bytes',
                            max: 'must be less than or equal to {{limit}} bytes',
                            length: 'must be {{limit}} bytes'
                        },
                        date: {
                            base: 'must be a number of milliseconds or valid date string',
                            format: 'must be a string with one of the following formats {{format}}',
                            strict: 'must be a valid date',
                            min: 'must be larger than or equal to "{{limit}}"',
                            max: 'must be less than or equal to "{{limit}}"',
                            less: 'must be less than "{{limit}}"',
                            greater: 'must be greater than "{{limit}}"',
                            isoDate: 'must be a valid ISO 8601 date',
                            timestamp: {
                                javascript: 'must be a valid timestamp or number of milliseconds',
                                unix: 'must be a valid timestamp or number of seconds'
                            },
                            ref: 'references "{{ref}}" which is not a date'
                        },
                        function: {
                            base: 'must be a Function',
                            arity: 'must have an arity of {{n}}',
                            minArity: 'must have an arity greater or equal to {{n}}',
                            maxArity: 'must have an arity lesser or equal to {{n}}',
                            ref: 'must be a Joi reference',
                            class: 'must be a class'
                        },
                        lazy: {
                            base: '!!schema error: lazy schema must be set',
                            schema: '!!schema error: lazy schema function must return a schema'
                        },
                        object: {
                            base: 'must be an object',
                            child: '!!child "{{!child}}" fails because {{reason}}',
                            min: 'must have at least {{limit}} children',
                            max: 'must have less than or equal to {{limit}} children',
                            length: 'must have {{limit}} children',
                            allowUnknown: '!!"{{!child}}" is not allowed',
                            with: '!!"{{mainWithLabel}}" missing required peer "{{peerWithLabel}}"',
                            without: '!!"{{mainWithLabel}}" conflict with forbidden peer "{{peerWithLabel}}"',
                            missing: 'must contain at least one of {{peersWithLabels}}',
                            xor: 'contains a conflict between exclusive peers {{peersWithLabels}}',
                            or: 'must contain at least one of {{peersWithLabels}}',
                            and: 'contains {{presentWithLabels}} without its required peers {{missingWithLabels}}',
                            nand: '!!"{{mainWithLabel}}" must not exist simultaneously with {{peersWithLabels}}',
                            assert: '!!"{{ref}}" validation failed because "{{ref}}" failed to {{message}}',
                            rename: {
                                multiple: 'cannot rename child "{{from}}" because multiple renames are disabled and another key was already renamed to "{{to}}"',
                                override: 'cannot rename child "{{from}}" because override is disabled and target "{{to}}" exists',
                                regex: {
                                    multiple: 'cannot rename children {{from}} because multiple renames are disabled and another key was already renamed to "{{to}}"',
                                    override: 'cannot rename children {{from}} because override is disabled and target "{{to}}" exists'
                                }
                            },
                            type: 'must be an instance of "{{type}}"',
                            schema: 'must be a Joi instance'
                        },
                        number: {
                            base: 'must be a number',
                            min: 'must be larger than or equal to {{limit}}',
                            max: 'must be less than or equal to {{limit}}',
                            less: 'must be less than {{limit}}',
                            greater: 'must be greater than {{limit}}',
                            float: 'must be a float or double',
                            integer: 'must be an integer',
                            negative: 'must be a negative number',
                            positive: 'must be a positive number',
                            precision: 'must have no more than {{limit}} decimal places',
                            ref: 'references "{{ref}}" which is not a number',
                            multiple: 'must be a multiple of {{multiple}}',
                            port: 'must be a valid port'
                        },
                        string: {
                            base: 'must be a string',
                            min: 'length must be at least {{limit}} characters long',
                            max: 'length must be less than or equal to {{limit}} characters long',
                            length: 'length must be {{limit}} characters long',
                            alphanum: 'must only contain alpha-numeric characters',
                            token: 'must only contain alpha-numeric and underscore characters',
                            regex: {
                                base: 'with value "{{!value}}" fails to match the required pattern: {{pattern}}',
                                name: 'with value "{{!value}}" fails to match the {{name}} pattern',
                                invert: {
                                    base: 'with value "{{!value}}" matches the inverted pattern: {{pattern}}',
                                    name: 'with value "{{!value}}" matches the inverted {{name}} pattern'
                                }
                            },
                            email: 'must be a valid email',
                            uri: 'must be a valid uri',
                            uriRelativeOnly: 'must be a valid relative uri',
                            uriCustomScheme: 'must be a valid uri with a scheme matching the {{scheme}} pattern',
                            isoDate: 'must be a valid ISO 8601 date',
                            guid: 'must be a valid GUID',
                            hex: 'must only contain hexadecimal characters',
                            hexAlign: 'hex decoded representation must be byte aligned',
                            base64: 'must be a valid base64 string',
                            hostname: 'must be a valid hostname',
                            normalize: 'must be unicode normalized in the {{form}} form',
                            lowercase: 'must only contain lowercase characters',
                            uppercase: 'must only contain uppercase characters',
                            trim: 'must not have leading or trailing whitespace',
                            creditCard: 'must be a credit card',
                            ref: 'references "{{ref}}" which is not a number',
                            ip: 'must be a valid ip address with a {{cidr}} CIDR',
                            ipVersion: 'must be a valid ip address of one of the following versions {{version}} with a {{cidr}} CIDR'
                        }
                    };

                    /***/ }),
                /* 21 */
                /***/ (function(module, exports, __webpack_require__) {


// Load modules

                    var Joi = __webpack_require__(8);

                    exports.options = Joi.object({
                        abortEarly: Joi.boolean(),
                        convert: Joi.boolean(),
                        allowUnknown: Joi.boolean(),
                        skipFunctions: Joi.boolean(),
                        stripUnknown: [Joi.boolean(), Joi.object({ arrays: Joi.boolean(), objects: Joi.boolean() }).or('arrays', 'objects')],
                        language: Joi.object(),
                        presence: Joi.string().only('required', 'optional', 'forbidden', 'ignore'),
                        raw: Joi.boolean(),
                        context: Joi.object(),
                        strip: Joi.boolean(),
                        noDefaults: Joi.boolean(),
                        escapeHtml: Joi.boolean()
                    }).strict();

                    /***/ }),
                /* 22 */
                /***/ (function(module, exports, __webpack_require__) {


// Load modules

                    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

                    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

                    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

                    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

                    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

                    var Any = __webpack_require__(2);
                    var Cast = __webpack_require__(4);
                    var Ref = __webpack_require__(1);
                    var Hoek = __webpack_require__(0);

// Declare internals

                    var internals = {};

                    internals.fastSplice = function (arr, i) {

                        var pos = i;
                        while (pos < arr.length) {
                            arr[pos++] = arr[pos];
                        }

                        --arr.length;
                    };

                    internals.Array = function (_Any) {
                        _inherits(_class, _Any);

                        function _class() {
                            _classCallCheck(this, _class);

                            var _this = _possibleConstructorReturn(this, _Any.call(this));

                            _this._type = 'array';
                            _this._inner.items = [];
                            _this._inner.ordereds = [];
                            _this._inner.inclusions = [];
                            _this._inner.exclusions = [];
                            _this._inner.requireds = [];
                            _this._flags.sparse = false;
                            return _this;
                        }

                        _class.prototype._base = function _base(value, state, options) {

                            var result = {
                                value: value
                            };

                            if (typeof value === 'string' && options.convert) {

                                internals.safeParse(value, result);
                            }

                            var isArray = Array.isArray(result.value);
                            var wasArray = isArray;
                            if (options.convert && this._flags.single && !isArray) {
                                result.value = [result.value];
                                isArray = true;
                            }

                            if (!isArray) {
                                result.errors = this.createError('array.base', null, state, options);
                                return result;
                            }

                            if (this._inner.inclusions.length || this._inner.exclusions.length || this._inner.requireds.length || this._inner.ordereds.length || !this._flags.sparse) {

                                // Clone the array so that we don't modify the original
                                if (wasArray) {
                                    result.value = result.value.slice(0);
                                }

                                result.errors = this._checkItems.call(this, result.value, wasArray, state, options);

                                if (result.errors && wasArray && options.convert && this._flags.single) {

                                    // Attempt a 2nd pass by putting the array inside one.
                                    var previousErrors = result.errors;

                                    result.value = [result.value];
                                    result.errors = this._checkItems.call(this, result.value, wasArray, state, options);

                                    if (result.errors) {

                                        // Restore previous errors and value since this didn't validate either.
                                        result.errors = previousErrors;
                                        result.value = result.value[0];
                                    }
                                }
                            }

                            return result;
                        };

                        _class.prototype._checkItems = function _checkItems(items, wasArray, state, options) {

                            var errors = [];
                            var errored = void 0;

                            var requireds = this._inner.requireds.slice();
                            var ordereds = this._inner.ordereds.slice();
                            var inclusions = this._inner.inclusions.concat(requireds);

                            var il = items.length;
                            for (var i = 0; i < il; ++i) {
                                errored = false;
                                var item = items[i];
                                var isValid = false;
                                var key = wasArray ? i : state.key;
                                var path = wasArray ? state.path.concat(i) : state.path;
                                var localState = { key: key, path: path, parent: state.parent, reference: state.reference };
                                var res = void 0;

                                // Sparse

                                if (!this._flags.sparse && item === undefined) {
                                    errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));

                                    if (options.abortEarly) {
                                        return errors;
                                    }

                                    ordereds.shift();

                                    continue;
                                }

                                // Exclusions

                                for (var j = 0; j < this._inner.exclusions.length; ++j) {
                                    res = this._inner.exclusions[j]._validate(item, localState, {}); // Not passing options to use defaults

                                    if (!res.errors) {
                                        errors.push(this.createError(wasArray ? 'array.excludes' : 'array.excludesSingle', { pos: i, value: item }, { key: state.key, path: localState.path }, options));
                                        errored = true;

                                        if (options.abortEarly) {
                                            return errors;
                                        }

                                        ordereds.shift();

                                        break;
                                    }
                                }

                                if (errored) {
                                    continue;
                                }

                                // Ordered
                                if (this._inner.ordereds.length) {
                                    if (ordereds.length > 0) {
                                        var ordered = ordereds.shift();
                                        res = ordered._validate(item, localState, options);
                                        if (!res.errors) {
                                            if (ordered._flags.strip) {
                                                internals.fastSplice(items, i);
                                                --i;
                                                --il;
                                            } else if (!this._flags.sparse && res.value === undefined) {
                                                errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));

                                                if (options.abortEarly) {
                                                    return errors;
                                                }

                                                continue;
                                            } else {
                                                items[i] = res.value;
                                            }
                                        } else {
                                            errors.push(this.createError('array.ordered', { pos: i, reason: res.errors, value: item }, { key: state.key, path: localState.path }, options));
                                            if (options.abortEarly) {
                                                return errors;
                                            }
                                        }
                                        continue;
                                    } else if (!this._inner.items.length) {
                                        errors.push(this.createError('array.orderedLength', { pos: i, limit: this._inner.ordereds.length }, { key: state.key, path: localState.path }, options));
                                        if (options.abortEarly) {
                                            return errors;
                                        }
                                        continue;
                                    }
                                }

                                // Requireds

                                var requiredChecks = [];
                                var jl = requireds.length;
                                for (var _j = 0; _j < jl; ++_j) {
                                    res = requiredChecks[_j] = requireds[_j]._validate(item, localState, options);
                                    if (!res.errors) {
                                        items[i] = res.value;
                                        isValid = true;
                                        internals.fastSplice(requireds, _j);
                                        --_j;
                                        --jl;

                                        if (!this._flags.sparse && res.value === undefined) {
                                            errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));

                                            if (options.abortEarly) {
                                                return errors;
                                            }
                                        }

                                        break;
                                    }
                                }

                                if (isValid) {
                                    continue;
                                }

                                // Inclusions

                                var stripUnknown = options.stripUnknown ? options.stripUnknown === true ? true : !!options.stripUnknown.arrays : false;

                                jl = inclusions.length;
                                for (var _j2 = 0; _j2 < jl; ++_j2) {
                                    var inclusion = inclusions[_j2];

                                    // Avoid re-running requireds that already didn't match in the previous loop
                                    var previousCheck = requireds.indexOf(inclusion);
                                    if (previousCheck !== -1) {
                                        res = requiredChecks[previousCheck];
                                    } else {
                                        res = inclusion._validate(item, localState, options);

                                        if (!res.errors) {
                                            if (inclusion._flags.strip) {
                                                internals.fastSplice(items, i);
                                                --i;
                                                --il;
                                            } else if (!this._flags.sparse && res.value === undefined) {
                                                errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));
                                                errored = true;
                                            } else {
                                                items[i] = res.value;
                                            }
                                            isValid = true;
                                            break;
                                        }
                                    }

                                    // Return the actual error if only one inclusion defined
                                    if (jl === 1) {
                                        if (stripUnknown) {
                                            internals.fastSplice(items, i);
                                            --i;
                                            --il;
                                            isValid = true;
                                            break;
                                        }

                                        errors.push(this.createError(wasArray ? 'array.includesOne' : 'array.includesOneSingle', { pos: i, reason: res.errors, value: item }, { key: state.key, path: localState.path }, options));
                                        errored = true;

                                        if (options.abortEarly) {
                                            return errors;
                                        }

                                        break;
                                    }
                                }

                                if (errored) {
                                    continue;
                                }

                                if (this._inner.inclusions.length && !isValid) {
                                    if (stripUnknown) {
                                        internals.fastSplice(items, i);
                                        --i;
                                        --il;
                                        continue;
                                    }

                                    errors.push(this.createError(wasArray ? 'array.includes' : 'array.includesSingle', { pos: i, value: item }, { key: state.key, path: localState.path }, options));

                                    if (options.abortEarly) {
                                        return errors;
                                    }
                                }
                            }

                            if (requireds.length) {
                                this._fillMissedErrors.call(this, errors, requireds, state, options);
                            }

                            if (ordereds.length) {
                                this._fillOrderedErrors.call(this, errors, ordereds, state, options);
                            }

                            return errors.length ? errors : null;
                        };

                        _class.prototype.describe = function describe() {

                            var description = Any.prototype.describe.call(this);

                            if (this._inner.ordereds.length) {
                                description.orderedItems = [];

                                for (var i = 0; i < this._inner.ordereds.length; ++i) {
                                    description.orderedItems.push(this._inner.ordereds[i].describe());
                                }
                            }

                            if (this._inner.items.length) {
                                description.items = [];

                                for (var _i = 0; _i < this._inner.items.length; ++_i) {
                                    description.items.push(this._inner.items[_i].describe());
                                }
                            }

                            return description;
                        };

                        _class.prototype.items = function items() {
                            var _this2 = this;

                            var obj = this.clone();

                            for (var _len = arguments.length, schemas = Array(_len), _key = 0; _key < _len; _key++) {
                                schemas[_key] = arguments[_key];
                            }

                            Hoek.flatten(schemas).forEach(function (type, index) {

                                try {
                                    type = Cast.schema(_this2._currentJoi, type);
                                } catch (castErr) {
                                    if (castErr.hasOwnProperty('path')) {
                                        castErr.path = index + '.' + castErr.path;
                                    } else {
                                        castErr.path = index;
                                    }
                                    castErr.message = castErr.message + '(' + castErr.path + ')';
                                    throw castErr;
                                }

                                obj._inner.items.push(type);

                                if (type._flags.presence === 'required') {
                                    obj._inner.requireds.push(type);
                                } else if (type._flags.presence === 'forbidden') {
                                    obj._inner.exclusions.push(type.optional());
                                } else {
                                    obj._inner.inclusions.push(type);
                                }
                            });

                            return obj;
                        };

                        _class.prototype.ordered = function ordered() {
                            var _this3 = this;

                            var obj = this.clone();

                            for (var _len2 = arguments.length, schemas = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                                schemas[_key2] = arguments[_key2];
                            }

                            Hoek.flatten(schemas).forEach(function (type, index) {

                                try {
                                    type = Cast.schema(_this3._currentJoi, type);
                                } catch (castErr) {
                                    if (castErr.hasOwnProperty('path')) {
                                        castErr.path = index + '.' + castErr.path;
                                    } else {
                                        castErr.path = index;
                                    }
                                    castErr.message = castErr.message + '(' + castErr.path + ')';
                                    throw castErr;
                                }
                                obj._inner.ordereds.push(type);
                            });

                            return obj;
                        };

                        _class.prototype.min = function min(limit) {

                            var isRef = Ref.isRef(limit);

                            Hoek.assert(Number.isSafeInteger(limit) && limit >= 0 || isRef, 'limit must be a positive integer or reference');

                            return this._test('min', limit, function (value, state, options) {

                                var compareTo = void 0;
                                if (isRef) {
                                    compareTo = limit(state.reference || state.parent, options);

                                    if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {
                                        return this.createError('array.ref', { ref: limit.key }, state, options);
                                    }
                                } else {
                                    compareTo = limit;
                                }

                                if (value.length >= compareTo) {
                                    return value;
                                }

                                return this.createError('array.min', { limit: limit, value: value }, state, options);
                            });
                        };

                        _class.prototype.max = function max(limit) {

                            var isRef = Ref.isRef(limit);

                            Hoek.assert(Number.isSafeInteger(limit) && limit >= 0 || isRef, 'limit must be a positive integer or reference');

                            return this._test('max', limit, function (value, state, options) {

                                var compareTo = void 0;
                                if (isRef) {
                                    compareTo = limit(state.reference || state.parent, options);

                                    if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {
                                        return this.createError('array.ref', { ref: limit.key }, state, options);
                                    }
                                } else {
                                    compareTo = limit;
                                }

                                if (value.length <= compareTo) {
                                    return value;
                                }

                                return this.createError('array.max', { limit: limit, value: value }, state, options);
                            });
                        };

                        _class.prototype.length = function length(limit) {

                            var isRef = Ref.isRef(limit);

                            Hoek.assert(Number.isSafeInteger(limit) && limit >= 0 || isRef, 'limit must be a positive integer or reference');

                            return this._test('length', limit, function (value, state, options) {

                                var compareTo = void 0;
                                if (isRef) {
                                    compareTo = limit(state.reference || state.parent, options);

                                    if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {
                                        return this.createError('array.ref', { ref: limit.key }, state, options);
                                    }
                                } else {
                                    compareTo = limit;
                                }

                                if (value.length === compareTo) {
                                    return value;
                                }

                                return this.createError('array.length', { limit: limit, value: value }, state, options);
                            });
                        };

                        _class.prototype.unique = function unique(comparator) {

                            Hoek.assert(comparator === undefined || typeof comparator === 'function' || typeof comparator === 'string', 'comparator must be a function or a string');

                            var settings = {};

                            if (typeof comparator === 'string') {
                                settings.path = comparator;
                            } else if (typeof comparator === 'function') {
                                settings.comparator = comparator;
                            }

                            return this._test('unique', settings, function (value, state, options) {

                                var found = {
                                    string: Object.create(null),
                                    number: Object.create(null),
                                    undefined: Object.create(null),
                                    boolean: Object.create(null),
                                    object: new Map(),
                                    function: new Map(),
                                    custom: new Map()
                                };

                                var compare = settings.comparator || Hoek.deepEqual;

                                for (var i = 0; i < value.length; ++i) {
                                    var item = settings.path ? Hoek.reach(value[i], settings.path) : value[i];
                                    var records = settings.comparator ? found.custom : found[typeof item === 'undefined' ? 'undefined' : _typeof(item)];

                                    // All available types are supported, so it's not possible to reach 100% coverage without ignoring this line.
                                    // I still want to keep the test for future js versions with new types (eg. Symbol).
                                    if ( /* $lab:coverage:off$ */records /* $lab:coverage:on$ */) {
                                        if (records instanceof Map) {
                                            var entries = records.entries();
                                            var current = void 0;
                                            while (!(current = entries.next()).done) {
                                                if (compare(current.value[0], item)) {
                                                    var localState = {
                                                        key: state.key,
                                                        path: state.path.concat(i),
                                                        parent: state.parent,
                                                        reference: state.reference
                                                    };

                                                    var context = {
                                                        pos: i,
                                                        value: value[i],
                                                        dupePos: current.value[1],
                                                        dupeValue: value[current.value[1]]
                                                    };

                                                    if (settings.path) {
                                                        context.path = settings.path;
                                                    }

                                                    return this.createError('array.unique', context, localState, options);
                                                }
                                            }

                                            records.set(item, i);
                                        } else {
                                            if (records[item] !== undefined) {
                                                var _localState = {
                                                    key: state.key,
                                                    path: state.path.concat(i),
                                                    parent: state.parent,
                                                    reference: state.reference
                                                };

                                                var _context = {
                                                    pos: i,
                                                    value: value[i],
                                                    dupePos: records[item],
                                                    dupeValue: value[records[item]]
                                                };

                                                if (settings.path) {
                                                    _context.path = settings.path;
                                                }

                                                return this.createError('array.unique', _context, _localState, options);
                                            }

                                            records[item] = i;
                                        }
                                    }
                                }

                                return value;
                            });
                        };

                        _class.prototype.sparse = function sparse(enabled) {

                            var value = enabled === undefined ? true : !!enabled;

                            if (this._flags.sparse === value) {
                                return this;
                            }

                            var obj = this.clone();
                            obj._flags.sparse = value;
                            return obj;
                        };

                        _class.prototype.single = function single(enabled) {

                            var value = enabled === undefined ? true : !!enabled;

                            if (this._flags.single === value) {
                                return this;
                            }

                            var obj = this.clone();
                            obj._flags.single = value;
                            return obj;
                        };

                        _class.prototype._fillMissedErrors = function _fillMissedErrors(errors, requireds, state, options) {

                            var knownMisses = [];
                            var unknownMisses = 0;
                            for (var i = 0; i < requireds.length; ++i) {
                                var label = requireds[i]._getLabel();
                                if (label) {
                                    knownMisses.push(label);
                                } else {
                                    ++unknownMisses;
                                }
                            }

                            if (knownMisses.length) {
                                if (unknownMisses) {
                                    errors.push(this.createError('array.includesRequiredBoth', { knownMisses: knownMisses, unknownMisses: unknownMisses }, { key: state.key, path: state.path }, options));
                                } else {
                                    errors.push(this.createError('array.includesRequiredKnowns', { knownMisses: knownMisses }, { key: state.key, path: state.path }, options));
                                }
                            } else {
                                errors.push(this.createError('array.includesRequiredUnknowns', { unknownMisses: unknownMisses }, { key: state.key, path: state.path }, options));
                            }
                        };

                        _class.prototype._fillOrderedErrors = function _fillOrderedErrors(errors, ordereds, state, options) {

                            var requiredOrdereds = [];

                            for (var i = 0; i < ordereds.length; ++i) {
                                var presence = Hoek.reach(ordereds[i], '_flags.presence');
                                if (presence === 'required') {
                                    requiredOrdereds.push(ordereds[i]);
                                }
                            }

                            if (requiredOrdereds.length) {
                                this._fillMissedErrors.call(this, errors, requiredOrdereds, state, options);
                            }
                        };

                        return _class;
                    }(Any);

                    internals.safeParse = function (value, result) {

                        try {
                            var converted = JSON.parse(value);
                            if (Array.isArray(converted)) {
                                result.value = converted;
                            }
                        } catch (e) {}
                    };

                    module.exports = new internals.Array();

                    /***/ }),
                /* 23 */
                /***/ (function(module, exports, __webpack_require__) {
                    /* WEBPACK VAR INJECTION */(function(Buffer) {

// Load modules

                        function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

                        function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

                        function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

                        function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

                        var Any = __webpack_require__(2);
                        var Hoek = __webpack_require__(0);

// Declare internals

                        var internals = {};

                        internals.Binary = function (_Any) {
                            _inherits(_class, _Any);

                            function _class() {
                                _classCallCheck(this, _class);

                                var _this = _possibleConstructorReturn(this, _Any.call(this));

                                _this._type = 'binary';
                                return _this;
                            }

                            _class.prototype._base = function _base(value, state, options) {

                                var result = {
                                    value: value
                                };

                                if (typeof value === 'string' && options.convert) {

                                    try {
                                        result.value = Buffer.from(value, this._flags.encoding);
                                    } catch (e) {}
                                }

                                result.errors = Buffer.isBuffer(result.value) ? null : this.createError('binary.base', null, state, options);
                                return result;
                            };

                            _class.prototype.encoding = function encoding(_encoding) {

                                Hoek.assert(Buffer.isEncoding(_encoding), 'Invalid encoding:', _encoding);

                                if (this._flags.encoding === _encoding) {
                                    return this;
                                }

                                var obj = this.clone();
                                obj._flags.encoding = _encoding;
                                return obj;
                            };

                            _class.prototype.min = function min(limit) {

                                Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');

                                return this._test('min', limit, function (value, state, options) {

                                    if (value.length >= limit) {
                                        return value;
                                    }

                                    return this.createError('binary.min', { limit: limit, value: value }, state, options);
                                });
                            };

                            _class.prototype.max = function max(limit) {

                                Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');

                                return this._test('max', limit, function (value, state, options) {

                                    if (value.length <= limit) {
                                        return value;
                                    }

                                    return this.createError('binary.max', { limit: limit, value: value }, state, options);
                                });
                            };

                            _class.prototype.length = function length(limit) {

                                Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');

                                return this._test('length', limit, function (value, state, options) {

                                    if (value.length === limit) {
                                        return value;
                                    }

                                    return this.createError('binary.length', { limit: limit, value: value }, state, options);
                                });
                            };

                            return _class;
                        }(Any);

                        module.exports = new internals.Binary();
                        /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).Buffer));

                    /***/ }),
                /* 24 */
                /***/ (function(module, exports, __webpack_require__) {


// Load modules

                    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

                    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

                    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

                    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

                    var Any = __webpack_require__(2);
                    var Hoek = __webpack_require__(0);

// Declare internals

                    var internals = {
                        Set: __webpack_require__(9)
                    };

                    internals.Boolean = function (_Any) {
                        _inherits(_class, _Any);

                        function _class() {
                            _classCallCheck(this, _class);

                            var _this = _possibleConstructorReturn(this, _Any.call(this));

                            _this._type = 'boolean';
                            _this._flags.insensitive = true;
                            _this._inner.truthySet = new internals.Set();
                            _this._inner.falsySet = new internals.Set();
                            return _this;
                        }

                        _class.prototype._base = function _base(value, state, options) {

                            var result = {
                                value: value
                            };

                            if (typeof value === 'string' && options.convert) {

                                var normalized = this._flags.insensitive ? value.toLowerCase() : value;
                                result.value = normalized === 'true' ? true : normalized === 'false' ? false : value;
                            }

                            if (typeof result.value !== 'boolean') {
                                result.value = this._inner.truthySet.has(value, null, null, this._flags.insensitive) ? true : this._inner.falsySet.has(value, null, null, this._flags.insensitive) ? false : value;
                            }

                            result.errors = typeof result.value === 'boolean' ? null : this.createError('boolean.base', null, state, options);
                            return result;
                        };

                        _class.prototype.truthy = function truthy() {
                            for (var _len = arguments.length, values = Array(_len), _key = 0; _key < _len; _key++) {
                                values[_key] = arguments[_key];
                            }

                            var obj = this.clone();
                            values = Hoek.flatten(values);
                            for (var i = 0; i < values.length; ++i) {
                                var value = values[i];

                                Hoek.assert(value !== undefined, 'Cannot call truthy with undefined');
                                obj._inner.truthySet.add(value);
                            }
                            return obj;
                        };

                        _class.prototype.falsy = function falsy() {
                            for (var _len2 = arguments.length, values = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                                values[_key2] = arguments[_key2];
                            }

                            var obj = this.clone();
                            values = Hoek.flatten(values);
                            for (var i = 0; i < values.length; ++i) {
                                var value = values[i];

                                Hoek.assert(value !== undefined, 'Cannot call falsy with undefined');
                                obj._inner.falsySet.add(value);
                            }
                            return obj;
                        };

                        _class.prototype.insensitive = function insensitive(enabled) {

                            var insensitive = enabled === undefined ? true : !!enabled;

                            if (this._flags.insensitive === insensitive) {
                                return this;
                            }

                            var obj = this.clone();
                            obj._flags.insensitive = insensitive;
                            return obj;
                        };

                        _class.prototype.describe = function describe() {

                            var description = Any.prototype.describe.call(this);
                            description.truthy = [true].concat(this._inner.truthySet.values());
                            description.falsy = [false].concat(this._inner.falsySet.values());
                            return description;
                        };

                        return _class;
                    }(Any);

                    module.exports = new internals.Boolean();

                    /***/ }),
                /* 25 */
                /***/ (function(module, exports, __webpack_require__) {


// Load modules

                    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

                    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

                    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

                    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

                    var Hoek = __webpack_require__(0);
                    var ObjectType = __webpack_require__(13);
                    var Ref = __webpack_require__(1);

// Declare internals

                    var internals = {};

                    internals.Func = function (_ObjectType$construct) {
                        _inherits(_class, _ObjectType$construct);

                        function _class() {
                            _classCallCheck(this, _class);

                            var _this = _possibleConstructorReturn(this, _ObjectType$construct.call(this));

                            _this._flags.func = true;
                            return _this;
                        }

                        _class.prototype.arity = function arity(n) {

                            Hoek.assert(Number.isSafeInteger(n) && n >= 0, 'n must be a positive integer');

                            return this._test('arity', n, function (value, state, options) {

                                if (value.length === n) {
                                    return value;
                                }

                                return this.createError('function.arity', { n: n }, state, options);
                            });
                        };

                        _class.prototype.minArity = function minArity(n) {

                            Hoek.assert(Number.isSafeInteger(n) && n > 0, 'n must be a strict positive integer');

                            return this._test('minArity', n, function (value, state, options) {

                                if (value.length >= n) {
                                    return value;
                                }

                                return this.createError('function.minArity', { n: n }, state, options);
                            });
                        };

                        _class.prototype.maxArity = function maxArity(n) {

                            Hoek.assert(Number.isSafeInteger(n) && n >= 0, 'n must be a positive integer');

                            return this._test('maxArity', n, function (value, state, options) {

                                if (value.length <= n) {
                                    return value;
                                }

                                return this.createError('function.maxArity', { n: n }, state, options);
                            });
                        };

                        _class.prototype.ref = function ref() {

                            return this._test('ref', null, function (value, state, options) {

                                if (Ref.isRef(value)) {
                                    return value;
                                }

                                return this.createError('function.ref', null, state, options);
                            });
                        };

                        _class.prototype.class = function _class() {

                            return this._test('class', null, function (value, state, options) {

                                if (/^\s*class\s/.test(value.toString())) {
                                    return value;
                                }

                                return this.createError('function.class', null, state, options);
                            });
                        };

                        return _class;
                    }(ObjectType.constructor);

                    module.exports = new internals.Func();

                    /***/ }),
                /* 26 */
                /***/ (function(module, exports, __webpack_require__) {


// Load modules

                    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

                    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

                    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

                    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

                    var Any = __webpack_require__(2);
                    var Hoek = __webpack_require__(0);

// Declare internals

                    var internals = {};

                    internals.Lazy = function (_Any) {
                        _inherits(_class, _Any);

                        function _class() {
                            _classCallCheck(this, _class);

                            var _this = _possibleConstructorReturn(this, _Any.call(this));

                            _this._type = 'lazy';
                            return _this;
                        }

                        _class.prototype._base = function _base(value, state, options) {

                            var result = { value: value };
                            var lazy = this._flags.lazy;

                            if (!lazy) {
                                result.errors = this.createError('lazy.base', null, state, options);
                                return result;
                            }

                            var schema = lazy();

                            if (!(schema instanceof Any)) {
                                result.errors = this.createError('lazy.schema', null, state, options);
                                return result;
                            }

                            return schema._validate(value, state, options);
                        };

                        _class.prototype.set = function set(fn) {

                            Hoek.assert(typeof fn === 'function', 'You must provide a function as first argument');

                            var obj = this.clone();
                            obj._flags.lazy = fn;
                            return obj;
                        };

                        return _class;
                    }(Any);

                    module.exports = new internals.Lazy();

                    /***/ }),
                /* 27 */
                /***/ (function(module, exports, __webpack_require__) {


// Load modules

                    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

                    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

                    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

                    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

                    var Any = __webpack_require__(2);
                    var Ref = __webpack_require__(1);
                    var Hoek = __webpack_require__(0);

// Declare internals

                    var internals = {
                        precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/
                    };

                    internals.Number = function (_Any) {
                        _inherits(_class, _Any);

                        function _class() {
                            _classCallCheck(this, _class);

                            var _this = _possibleConstructorReturn(this, _Any.call(this));

                            _this._type = 'number';
                            _this._invalids.add(Infinity);
                            _this._invalids.add(-Infinity);
                            return _this;
                        }

                        _class.prototype._base = function _base(value, state, options) {

                            var result = {
                                errors: null,
                                value: value
                            };

                            if (typeof value === 'string' && options.convert) {

                                var number = parseFloat(value);
                                result.value = isNaN(number) || !isFinite(value) ? NaN : number;
                            }

                            var isNumber = typeof result.value === 'number' && !isNaN(result.value);

                            if (options.convert && 'precision' in this._flags && isNumber) {

                                // This is conceptually equivalent to using toFixed but it should be much faster
                                var precision = Math.pow(10, this._flags.precision);
                                result.value = Math.round(result.value * precision) / precision;
                            }

                            result.errors = isNumber ? null : this.createError('number.base', null, state, options);
                            return result;
                        };

                        _class.prototype.multiple = function multiple(base) {

                            var isRef = Ref.isRef(base);

                            if (!isRef) {
                                Hoek.assert(typeof base === 'number' && isFinite(base), 'multiple must be a number');
                                Hoek.assert(base > 0, 'multiple must be greater than 0');
                            }

                            return this._test('multiple', base, function (value, state, options) {

                                var divisor = isRef ? base(state.reference || state.parent, options) : base;

                                if (isRef && (typeof divisor !== 'number' || !isFinite(divisor))) {
                                    return this.createError('number.ref', { ref: base.key }, state, options);
                                }

                                if (value % divisor === 0) {
                                    return value;
                                }

                                return this.createError('number.multiple', { multiple: base, value: value }, state, options);
                            });
                        };

                        _class.prototype.integer = function integer() {

                            return this._test('integer', undefined, function (value, state, options) {

                                return Number.isSafeInteger(value) ? value : this.createError('number.integer', { value: value }, state, options);
                            });
                        };

                        _class.prototype.negative = function negative() {

                            return this._test('negative', undefined, function (value, state, options) {

                                if (value < 0) {
                                    return value;
                                }

                                return this.createError('number.negative', { value: value }, state, options);
                            });
                        };

                        _class.prototype.positive = function positive() {

                            return this._test('positive', undefined, function (value, state, options) {

                                if (value > 0) {
                                    return value;
                                }

                                return this.createError('number.positive', { value: value }, state, options);
                            });
                        };

                        _class.prototype.precision = function precision(limit) {

                            Hoek.assert(Number.isSafeInteger(limit), 'limit must be an integer');
                            Hoek.assert(!('precision' in this._flags), 'precision already set');

                            var obj = this._test('precision', limit, function (value, state, options) {

                                var places = value.toString().match(internals.precisionRx);
                                var decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);
                                if (decimals <= limit) {
                                    return value;
                                }

                                return this.createError('number.precision', { limit: limit, value: value }, state, options);
                            });

                            obj._flags.precision = limit;
                            return obj;
                        };

                        _class.prototype.port = function port() {

                            return this._test('port', undefined, function (value, state, options) {

                                if (!Number.isSafeInteger(value) || value < 0 || value > 65535) {
                                    return this.createError('number.port', { value: value }, state, options);
                                }

                                return value;
                            });
                        };

                        return _class;
                    }(Any);

                    internals.compare = function (type, compare) {

                        return function (limit) {

                            var isRef = Ref.isRef(limit);
                            var isNumber = typeof limit === 'number' && !isNaN(limit);

                            Hoek.assert(isNumber || isRef, 'limit must be a number or reference');

                            return this._test(type, limit, function (value, state, options) {

                                var compareTo = void 0;
                                if (isRef) {
                                    compareTo = limit(state.reference || state.parent, options);

                                    if (!(typeof compareTo === 'number' && !isNaN(compareTo))) {
                                        return this.createError('number.ref', { ref: limit.key }, state, options);
                                    }
                                } else {
                                    compareTo = limit;
                                }

                                if (compare(value, compareTo)) {
                                    return value;
                                }

                                return this.createError('number.' + type, { limit: compareTo, value: value }, state, options);
                            });
                        };
                    };

                    internals.Number.prototype.min = internals.compare('min', function (value, limit) {
                        return value >= limit;
                    });
                    internals.Number.prototype.max = internals.compare('max', function (value, limit) {
                        return value <= limit;
                    });
                    internals.Number.prototype.greater = internals.compare('greater', function (value, limit) {
                        return value > limit;
                    });
                    internals.Number.prototype.less = internals.compare('less', function (value, limit) {
                        return value < limit;
                    });

                    module.exports = new internals.Number();

                    /***/ }),
                /* 28 */
                /***/ (function(module, exports, __webpack_require__) {
                    /* WEBPACK VAR INJECTION */(function(Buffer) {

// Load modules

                        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

                        function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

                        function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

                        function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

                        function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

                        var Net = __webpack_require__(15);
                        var Hoek = __webpack_require__(0);
                        var Isemail = void 0; // Loaded on demand
                        var Any = __webpack_require__(2);
                        var Ref = __webpack_require__(1);
                        var JoiDate = __webpack_require__(12);
                        var Uri = __webpack_require__(30);
                        var Ip = __webpack_require__(29);

// Declare internals

                        var internals = {
                            uriRegex: Uri.createUriRegex(),
                            ipRegex: Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], 'optional'),
                            guidBrackets: {
                                '{': '}', '[': ']', '(': ')', '': ''
                            },
                            guidVersions: {
                                uuidv1: '1',
                                uuidv2: '2',
                                uuidv3: '3',
                                uuidv4: '4',
                                uuidv5: '5'
                            },
                            cidrPresences: ['required', 'optional', 'forbidden'],
                            normalizationForms: ['NFC', 'NFD', 'NFKC', 'NFKD']
                        };

                        internals.String = function (_Any) {
                            _inherits(_class, _Any);

                            function _class() {
                                _classCallCheck(this, _class);

                                var _this = _possibleConstructorReturn(this, _Any.call(this));

                                _this._type = 'string';
                                _this._invalids.add('');
                                return _this;
                            }

                            _class.prototype._base = function _base(value, state, options) {

                                if (typeof value === 'string' && options.convert) {

                                    if (this._flags.normalize) {
                                        value = value.normalize(this._flags.normalize);
                                    }

                                    if (this._flags.case) {
                                        value = this._flags.case === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase();
                                    }

                                    if (this._flags.trim) {
                                        value = value.trim();
                                    }

                                    if (this._inner.replacements) {

                                        for (var i = 0; i < this._inner.replacements.length; ++i) {
                                            var replacement = this._inner.replacements[i];
                                            value = value.replace(replacement.pattern, replacement.replacement);
                                        }
                                    }

                                    if (this._flags.truncate) {
                                        for (var _i = 0; _i < this._tests.length; ++_i) {
                                            var test = this._tests[_i];
                                            if (test.name === 'max') {
                                                value = value.slice(0, test.arg);
                                                break;
                                            }
                                        }
                                    }

                                    if (this._flags.byteAligned && value.length % 2 !== 0) {
                                        value = '0' + value;
                                    }
                                }

                                return {
                                    value: value,
                                    errors: typeof value === 'string' ? null : this.createError('string.base', { value: value }, state, options)
                                };
                            };

                            _class.prototype.insensitive = function insensitive() {

                                if (this._flags.insensitive) {
                                    return this;
                                }

                                var obj = this.clone();
                                obj._flags.insensitive = true;
                                return obj;
                            };

                            _class.prototype.creditCard = function creditCard() {

                                return this._test('creditCard', undefined, function (value, state, options) {

                                    var i = value.length;
                                    var sum = 0;
                                    var mul = 1;

                                    while (i--) {
                                        var char = value.charAt(i) * mul;
                                        sum = sum + (char - (char > 9) * 9);
                                        mul = mul ^ 3;
                                    }

                                    var check = sum % 10 === 0 && sum > 0;
                                    return check ? value : this.createError('string.creditCard', { value: value }, state, options);
                                });
                            };

                            _class.prototype.regex = function regex(pattern, patternOptions) {

                                Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');

                                var patternObject = {
                                    pattern: new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined) // Future version should break this and forbid unsupported regex flags
                                };

                                if (typeof patternOptions === 'string') {
                                    patternObject.name = patternOptions;
                                } else if ((typeof patternOptions === 'undefined' ? 'undefined' : _typeof(patternOptions)) === 'object') {
                                    patternObject.invert = !!patternOptions.invert;

                                    if (patternOptions.name) {
                                        patternObject.name = patternOptions.name;
                                    }
                                }

                                var errorCode = ['string.regex', patternObject.invert ? '.invert' : '', patternObject.name ? '.name' : '.base'].join('');

                                return this._test('regex', patternObject, function (value, state, options) {

                                    var patternMatch = patternObject.pattern.test(value);

                                    if (patternMatch ^ patternObject.invert) {
                                        return value;
                                    }

                                    return this.createError(errorCode, { name: patternObject.name, pattern: patternObject.pattern, value: value }, state, options);
                                });
                            };

                            _class.prototype.alphanum = function alphanum() {

                                return this._test('alphanum', undefined, function (value, state, options) {

                                    if (/^[a-zA-Z0-9]+$/.test(value)) {
                                        return value;
                                    }

                                    return this.createError('string.alphanum', { value: value }, state, options);
                                });
                            };

                            _class.prototype.token = function token() {

                                return this._test('token', undefined, function (value, state, options) {

                                    if (/^\w+$/.test(value)) {
                                        return value;
                                    }

                                    return this.createError('string.token', { value: value }, state, options);
                                });
                            };

                            _class.prototype.email = function email(isEmailOptions) {

                                if (isEmailOptions) {
                                    Hoek.assert((typeof isEmailOptions === 'undefined' ? 'undefined' : _typeof(isEmailOptions)) === 'object', 'email options must be an object');
                                    Hoek.assert(typeof isEmailOptions.checkDNS === 'undefined', 'checkDNS option is not supported');
                                    Hoek.assert(typeof isEmailOptions.tldWhitelist === 'undefined' || _typeof(isEmailOptions.tldWhitelist) === 'object', 'tldWhitelist must be an array or object');
                                    Hoek.assert(typeof isEmailOptions.minDomainAtoms === 'undefined' || Number.isSafeInteger(isEmailOptions.minDomainAtoms) && isEmailOptions.minDomainAtoms > 0, 'minDomainAtoms must be a positive integer');
                                    Hoek.assert(typeof isEmailOptions.errorLevel === 'undefined' || typeof isEmailOptions.errorLevel === 'boolean' || Number.isSafeInteger(isEmailOptions.errorLevel) && isEmailOptions.errorLevel >= 0, 'errorLevel must be a non-negative integer or boolean');
                                }

                                return this._test('email', isEmailOptions, function (value, state, options) {

                                    Isemail = Isemail || __webpack_require__(19);

                                    try {
                                        var result = Isemail.validate(value, isEmailOptions);
                                        if (result === true || result === 0) {
                                            return value;
                                        }
                                    } catch (e) {}

                                    return this.createError('string.email', { value: value }, state, options);
                                });
                            };

                            _class.prototype.ip = function ip() {
                                var ipOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};


                                var regex = internals.ipRegex;
                                Hoek.assert((typeof ipOptions === 'undefined' ? 'undefined' : _typeof(ipOptions)) === 'object', 'options must be an object');

                                if (ipOptions.cidr) {
                                    Hoek.assert(typeof ipOptions.cidr === 'string', 'cidr must be a string');
                                    ipOptions.cidr = ipOptions.cidr.toLowerCase();

                                    Hoek.assert(Hoek.contain(internals.cidrPresences, ipOptions.cidr), 'cidr must be one of ' + internals.cidrPresences.join(', '));

                                    // If we only received a `cidr` setting, create a regex for it. But we don't need to create one if `cidr` is "optional" since that is the default
                                    if (!ipOptions.version && ipOptions.cidr !== 'optional') {
                                        regex = Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], ipOptions.cidr);
                                    }
                                } else {

                                    // Set our default cidr strategy
                                    ipOptions.cidr = 'optional';
                                }

                                var versions = void 0;
                                if (ipOptions.version) {
                                    if (!Array.isArray(ipOptions.version)) {
                                        ipOptions.version = [ipOptions.version];
                                    }

                                    Hoek.assert(ipOptions.version.length >= 1, 'version must have at least 1 version specified');

                                    versions = [];
                                    for (var i = 0; i < ipOptions.version.length; ++i) {
                                        var version = ipOptions.version[i];
                                        Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');
                                        version = version.toLowerCase();
                                        Hoek.assert(Ip.versions[version], 'version at position ' + i + ' must be one of ' + Object.keys(Ip.versions).join(', '));
                                        versions.push(version);
                                    }

                                    // Make sure we have a set of versions
                                    versions = Hoek.unique(versions);

                                    regex = Ip.createIpRegex(versions, ipOptions.cidr);
                                }

                                return this._test('ip', ipOptions, function (value, state, options) {

                                    if (regex.test(value)) {
                                        return value;
                                    }

                                    if (versions) {
                                        return this.createError('string.ipVersion', { value: value, cidr: ipOptions.cidr, version: versions }, state, options);
                                    }

                                    return this.createError('string.ip', { value: value, cidr: ipOptions.cidr }, state, options);
                                });
                            };

                            _class.prototype.uri = function uri(uriOptions) {

                                var customScheme = '';
                                var allowRelative = false;
                                var relativeOnly = false;
                                var regex = internals.uriRegex;

                                if (uriOptions) {
                                    Hoek.assert((typeof uriOptions === 'undefined' ? 'undefined' : _typeof(uriOptions)) === 'object', 'options must be an object');

                                    if (uriOptions.scheme) {
                                        Hoek.assert(uriOptions.scheme instanceof RegExp || typeof uriOptions.scheme === 'string' || Array.isArray(uriOptions.scheme), 'scheme must be a RegExp, String, or Array');

                                        if (!Array.isArray(uriOptions.scheme)) {
                                            uriOptions.scheme = [uriOptions.scheme];
                                        }

                                        Hoek.assert(uriOptions.scheme.length >= 1, 'scheme must have at least 1 scheme specified');

                                        // Flatten the array into a string to be used to match the schemes.
                                        for (var i = 0; i < uriOptions.scheme.length; ++i) {
                                            var scheme = uriOptions.scheme[i];
                                            Hoek.assert(scheme instanceof RegExp || typeof scheme === 'string', 'scheme at position ' + i + ' must be a RegExp or String');

                                            // Add OR separators if a value already exists
                                            customScheme = customScheme + (customScheme ? '|' : '');

                                            // If someone wants to match HTTP or HTTPS for example then we need to support both RegExp and String so we don't escape their pattern unknowingly.
                                            if (scheme instanceof RegExp) {
                                                customScheme = customScheme + scheme.source;
                                            } else {
                                                Hoek.assert(/[a-zA-Z][a-zA-Z0-9+-\.]*/.test(scheme), 'scheme at position ' + i + ' must be a valid scheme');
                                                customScheme = customScheme + Hoek.escapeRegex(scheme);
                                            }
                                        }
                                    }

                                    if (uriOptions.allowRelative) {
                                        allowRelative = true;
                                    }

                                    if (uriOptions.relativeOnly) {
                                        relativeOnly = true;
                                    }
                                }

                                if (customScheme || allowRelative || relativeOnly) {
                                    regex = Uri.createUriRegex(customScheme, allowRelative, relativeOnly);
                                }

                                return this._test('uri', uriOptions, function (value, state, options) {

                                    if (regex.test(value)) {
                                        return value;
                                    }

                                    if (relativeOnly) {
                                        return this.createError('string.uriRelativeOnly', { value: value }, state, options);
                                    }

                                    if (customScheme) {
                                        return this.createError('string.uriCustomScheme', { scheme: customScheme, value: value }, state, options);
                                    }

                                    return this.createError('string.uri', { value: value }, state, options);
                                });
                            };

                            _class.prototype.isoDate = function isoDate() {

                                return this._test('isoDate', undefined, function (value, state, options) {

                                    if (JoiDate._isIsoDate(value)) {
                                        if (!options.convert) {
                                            return value;
                                        }

                                        var d = new Date(value);
                                        if (!isNaN(d.getTime())) {
                                            return d.toISOString();
                                        }
                                    }

                                    return this.createError('string.isoDate', { value: value }, state, options);
                                });
                            };

                            _class.prototype.guid = function guid(guidOptions) {

                                var versionNumbers = '';

                                if (guidOptions && guidOptions.version) {
                                    if (!Array.isArray(guidOptions.version)) {
                                        guidOptions.version = [guidOptions.version];
                                    }

                                    Hoek.assert(guidOptions.version.length >= 1, 'version must have at least 1 valid version specified');
                                    var versions = new Set();

                                    for (var i = 0; i < guidOptions.version.length; ++i) {
                                        var version = guidOptions.version[i];
                                        Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');
                                        version = version.toLowerCase();
                                        var versionNumber = internals.guidVersions[version];
                                        Hoek.assert(versionNumber, 'version at position ' + i + ' must be one of ' + Object.keys(internals.guidVersions).join(', '));
                                        Hoek.assert(!versions.has(versionNumber), 'version at position ' + i + ' must not be a duplicate.');

                                        versionNumbers += versionNumber;
                                        versions.add(versionNumber);
                                    }
                                }

                                var guidRegex = new RegExp('^([\\[{\\(]?)[0-9A-F]{8}([:-]?)[0-9A-F]{4}\\2?[' + (versionNumbers || '0-9A-F') + '][0-9A-F]{3}\\2?[' + (versionNumbers ? '89AB' : '0-9A-F') + '][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$', 'i');

                                return this._test('guid', guidOptions, function (value, state, options) {

                                    var results = guidRegex.exec(value);

                                    if (!results) {
                                        return this.createError('string.guid', { value: value }, state, options);
                                    }

                                    // Matching braces
                                    if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {
                                        return this.createError('string.guid', { value: value }, state, options);
                                    }

                                    return value;
                                });
                            };

                            _class.prototype.hex = function hex() {
                                var hexOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};


                                Hoek.assert((typeof hexOptions === 'undefined' ? 'undefined' : _typeof(hexOptions)) === 'object', 'hex options must be an object');
                                Hoek.assert(typeof hexOptions.byteAligned === 'undefined' || typeof hexOptions.byteAligned === 'boolean', 'byteAligned must be boolean');

                                var byteAligned = hexOptions.byteAligned === true;
                                var regex = /^[a-f0-9]+$/i;

                                var obj = this._test('hex', regex, function (value, state, options) {

                                    if (regex.test(value)) {
                                        if (byteAligned && value.length % 2 !== 0) {
                                            return this.createError('string.hexAlign', { value: value }, state, options);
                                        }
                                        return value;
                                    }

                                    return this.createError('string.hex', { value: value }, state, options);
                                });

                                if (byteAligned) {
                                    obj._flags.byteAligned = true;
                                }

                                return obj;
                            };

                            _class.prototype.base64 = function base64() {
                                var base64Options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};


                                // Validation.
                                Hoek.assert((typeof base64Options === 'undefined' ? 'undefined' : _typeof(base64Options)) === 'object', 'base64 options must be an object');
                                Hoek.assert(typeof base64Options.paddingRequired === 'undefined' || typeof base64Options.paddingRequired === 'boolean', 'paddingRequired must be boolean');

                                // Determine if padding is required.
                                var paddingRequired = base64Options.paddingRequired === false ? base64Options.paddingRequired : base64Options.paddingRequired || true;

                                // Set validation based on preference.
                                var regex = paddingRequired ?
                                    // Padding is required.
                                    /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/
                                    // Padding is optional.
                                    : /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/;

                                return this._test('base64', regex, function (value, state, options) {

                                    if (regex.test(value)) {
                                        return value;
                                    }

                                    return this.createError('string.base64', { value: value }, state, options);
                                });
                            };

                            _class.prototype.hostname = function hostname() {

                                var regex = /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9])$/;

                                return this._test('hostname', undefined, function (value, state, options) {

                                    if (value.length <= 255 && regex.test(value) || Net.isIPv6(value)) {

                                        return value;
                                    }

                                    return this.createError('string.hostname', { value: value }, state, options);
                                });
                            };

                            _class.prototype.normalize = function normalize() {
                                var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'NFC';


                                Hoek.assert(Hoek.contain(internals.normalizationForms, form), 'normalization form must be one of ' + internals.normalizationForms.join(', '));

                                var obj = this._test('normalize', form, function (value, state, options) {

                                    if (options.convert || value === value.normalize(form)) {

                                        return value;
                                    }

                                    return this.createError('string.normalize', { value: value, form: form }, state, options);
                                });

                                obj._flags.normalize = form;
                                return obj;
                            };

                            _class.prototype.lowercase = function lowercase() {

                                var obj = this._test('lowercase', undefined, function (value, state, options) {

                                    if (options.convert || value === value.toLocaleLowerCase()) {

                                        return value;
                                    }

                                    return this.createError('string.lowercase', { value: value }, state, options);
                                });

                                obj._flags.case = 'lower';
                                return obj;
                            };

                            _class.prototype.uppercase = function uppercase() {

                                var obj = this._test('uppercase', undefined, function (value, state, options) {

                                    if (options.convert || value === value.toLocaleUpperCase()) {

                                        return value;
                                    }

                                    return this.createError('string.uppercase', { value: value }, state, options);
                                });

                                obj._flags.case = 'upper';
                                return obj;
                            };

                            _class.prototype.trim = function trim() {

                                var obj = this._test('trim', undefined, function (value, state, options) {

                                    if (options.convert || value === value.trim()) {

                                        return value;
                                    }

                                    return this.createError('string.trim', { value: value }, state, options);
                                });

                                obj._flags.trim = true;
                                return obj;
                            };

                            _class.prototype.replace = function replace(pattern, replacement) {

                                if (typeof pattern === 'string') {
                                    pattern = new RegExp(Hoek.escapeRegex(pattern), 'g');
                                }

                                Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');
                                Hoek.assert(typeof replacement === 'string', 'replacement must be a String');

                                // This can not be considere a test like trim, we can't "reject"
                                // anything from this rule, so just clone the current object
                                var obj = this.clone();

                                if (!obj._inner.replacements) {
                                    obj._inner.replacements = [];
                                }

                                obj._inner.replacements.push({
                                    pattern: pattern,
                                    replacement: replacement
                                });

                                return obj;
                            };

                            _class.prototype.truncate = function truncate(enabled) {

                                var value = enabled === undefined ? true : !!enabled;

                                if (this._flags.truncate === value) {
                                    return this;
                                }

                                var obj = this.clone();
                                obj._flags.truncate = value;
                                return obj;
                            };

                            return _class;
                        }(Any);

                        internals.compare = function (type, compare) {

                            return function (limit, encoding) {

                                var isRef = Ref.isRef(limit);

                                Hoek.assert(Number.isSafeInteger(limit) && limit >= 0 || isRef, 'limit must be a positive integer or reference');
                                Hoek.assert(!encoding || Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);

                                return this._test(type, limit, function (value, state, options) {

                                    var compareTo = void 0;
                                    if (isRef) {
                                        compareTo = limit(state.reference || state.parent, options);

                                        if (!Number.isSafeInteger(compareTo)) {
                                            return this.createError('string.ref', { ref: limit.key }, state, options);
                                        }
                                    } else {
                                        compareTo = limit;
                                    }

                                    if (compare(value, compareTo, encoding)) {
                                        return value;
                                    }

                                    return this.createError('string.' + type, { limit: compareTo, value: value, encoding: encoding }, state, options);
                                });
                            };
                        };

                        internals.String.prototype.min = internals.compare('min', function (value, limit, encoding) {

                            var length = encoding ? Buffer.byteLength(value, encoding) : value.length;
                            return length >= limit;
                        });

                        internals.String.prototype.max = internals.compare('max', function (value, limit, encoding) {

                            var length = encoding ? Buffer.byteLength(value, encoding) : value.length;
                            return length <= limit;
                        });

                        internals.String.prototype.length = internals.compare('length', function (value, limit, encoding) {

                            var length = encoding ? Buffer.byteLength(value, encoding) : value.length;
                            return length === limit;
                        });

// Aliases

                        internals.String.prototype.uuid = internals.String.prototype.guid;

                        module.exports = new internals.String();
                        /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).Buffer));

                    /***/ }),
                /* 29 */
                /***/ (function(module, exports, __webpack_require__) {


// Load modules

                    var RFC3986 = __webpack_require__(14);

// Declare internals

                    var internals = {
                        Ip: {
                            cidrs: {
                                ipv4: {
                                    required: '\\/(?:' + RFC3986.ipv4Cidr + ')',
                                    optional: '(?:\\/(?:' + RFC3986.ipv4Cidr + '))?',
                                    forbidden: ''
                                },
                                ipv6: {
                                    required: '\\/' + RFC3986.ipv6Cidr,
                                    optional: '(?:\\/' + RFC3986.ipv6Cidr + ')?',
                                    forbidden: ''
                                },
                                ipvfuture: {
                                    required: '\\/' + RFC3986.ipv6Cidr,
                                    optional: '(?:\\/' + RFC3986.ipv6Cidr + ')?',
                                    forbidden: ''
                                }
                            },
                            versions: {
                                ipv4: RFC3986.IPv4address,
                                ipv6: RFC3986.IPv6address,
                                ipvfuture: RFC3986.IPvFuture
                            }
                        }
                    };

                    internals.Ip.createIpRegex = function (versions, cidr) {

                        var regex = void 0;
                        for (var i = 0; i < versions.length; ++i) {
                            var version = versions[i];
                            if (!regex) {
                                regex = '^(?:' + internals.Ip.versions[version] + internals.Ip.cidrs[version][cidr];
                            } else {
                                regex += '|' + internals.Ip.versions[version] + internals.Ip.cidrs[version][cidr];
                            }
                        }

                        return new RegExp(regex + ')$');
                    };

                    module.exports = internals.Ip;

                    /***/ }),
                /* 30 */
                /***/ (function(module, exports, __webpack_require__) {


// Load Modules

                    var RFC3986 = __webpack_require__(14);

// Declare internals

                    var internals = {
                        Uri: {
                            createUriRegex: function createUriRegex(optionalScheme, allowRelative, relativeOnly) {

                                var scheme = RFC3986.scheme;
                                var prefix = void 0;

                                if (relativeOnly) {
                                    prefix = '(?:' + RFC3986.relativeRef + ')';
                                } else {
                                    // If we were passed a scheme, use it instead of the generic one
                                    if (optionalScheme) {

                                        // Have to put this in a non-capturing group to handle the OR statements
                                        scheme = '(?:' + optionalScheme + ')';
                                    }

                                    var withScheme = '(?:' + scheme + ':' + RFC3986.hierPart + ')';

                                    prefix = allowRelative ? '(?:' + withScheme + '|' + RFC3986.relativeRef + ')' : withScheme;
                                }

                                /**
                                 * URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
                                 *
                                 * OR
                                 *
                                 * relative-ref = relative-part [ "?" query ] [ "#" fragment ]
                                 */
                                return new RegExp('^' + prefix + '(?:\\?' + RFC3986.query + ')?' + '(?:#' + RFC3986.fragment + ')?$');
                            }
                        }
                    };

                    module.exports = internals.Uri;

                    /***/ }),
                /* 31 */
                /***/ (function(module, exports, __webpack_require__) {


// Load modules

                    var Hoek = __webpack_require__(0);

// Declare internals

                    var internals = {};

                    module.exports = internals.Topo = function () {

                        this._items = [];
                        this.nodes = [];
                    };

                    internals.Topo.prototype.add = function (nodes, options) {
                        var _this = this;

                        options = options || {};

                        // Validate rules

                        var before = [].concat(options.before || []);
                        var after = [].concat(options.after || []);
                        var group = options.group || '?';
                        var sort = options.sort || 0; // Used for merging only

                        Hoek.assert(before.indexOf(group) === -1, 'Item cannot come before itself:', group);
                        Hoek.assert(before.indexOf('?') === -1, 'Item cannot come before unassociated items');
                        Hoek.assert(after.indexOf(group) === -1, 'Item cannot come after itself:', group);
                        Hoek.assert(after.indexOf('?') === -1, 'Item cannot come after unassociated items');

                        [].concat(nodes).forEach(function (node, i) {

                            var item = {
                                seq: _this._items.length,
                                sort: sort,
                                before: before,
                                after: after,
                                group: group,
                                node: node
                            };

                            _this._items.push(item);
                        });

                        // Insert event

                        var error = this._sort();
                        Hoek.assert(!error, 'item', group !== '?' ? 'added into group ' + group : '', 'created a dependencies error');

                        return this.nodes;
                    };

                    internals.Topo.prototype.merge = function (others) {

                        others = [].concat(others);
                        for (var i = 0; i < others.length; ++i) {
                            var other = others[i];
                            if (other) {
                                for (var j = 0; j < other._items.length; ++j) {
                                    var item = Hoek.shallow(other._items[j]);
                                    this._items.push(item);
                                }
                            }
                        }

                        // Sort items

                        this._items.sort(internals.mergeSort);
                        for (var _i = 0; _i < this._items.length; ++_i) {
                            this._items[_i].seq = _i;
                        }

                        var error = this._sort();
                        Hoek.assert(!error, 'merge created a dependencies error');

                        return this.nodes;
                    };

                    internals.mergeSort = function (a, b) {

                        return a.sort === b.sort ? 0 : a.sort < b.sort ? -1 : 1;
                    };

                    internals.Topo.prototype._sort = function () {

                        // Construct graph

                        var graph = {};
                        var graphAfters = Object.create(null); // A prototype can bungle lookups w/ false positives
                        var groups = Object.create(null);

                        for (var i = 0; i < this._items.length; ++i) {
                            var item = this._items[i];
                            var seq = item.seq; // Unique across all items
                            var group = item.group;

                            // Determine Groups

                            groups[group] = groups[group] || [];
                            groups[group].push(seq);

                            // Build intermediary graph using 'before'

                            graph[seq] = item.before;

                            // Build second intermediary graph with 'after'

                            var after = item.after;
                            for (var j = 0; j < after.length; ++j) {
                                graphAfters[after[j]] = (graphAfters[after[j]] || []).concat(seq);
                            }
                        }

                        // Expand intermediary graph

                        var graphNodes = Object.keys(graph);
                        for (var _i2 = 0; _i2 < graphNodes.length; ++_i2) {
                            var node = graphNodes[_i2];
                            var expandedGroups = [];

                            var graphNodeItems = Object.keys(graph[node]);
                            for (var _j = 0; _j < graphNodeItems.length; ++_j) {
                                var _group = graph[node][graphNodeItems[_j]];
                                groups[_group] = groups[_group] || [];

                                for (var k = 0; k < groups[_group].length; ++k) {
                                    expandedGroups.push(groups[_group][k]);
                                }
                            }
                            graph[node] = expandedGroups;
                        }

                        // Merge intermediary graph using graphAfters into final graph

                        var afterNodes = Object.keys(graphAfters);
                        for (var _i3 = 0; _i3 < afterNodes.length; ++_i3) {
                            var _group2 = afterNodes[_i3];

                            if (groups[_group2]) {
                                for (var _j2 = 0; _j2 < groups[_group2].length; ++_j2) {
                                    var _node = groups[_group2][_j2];
                                    graph[_node] = graph[_node].concat(graphAfters[_group2]);
                                }
                            }
                        }

                        // Compile ancestors

                        var children = void 0;
                        var ancestors = {};
                        graphNodes = Object.keys(graph);
                        for (var _i4 = 0; _i4 < graphNodes.length; ++_i4) {
                            var _node2 = graphNodes[_i4];
                            children = graph[_node2];

                            for (var _j3 = 0; _j3 < children.length; ++_j3) {
                                ancestors[children[_j3]] = (ancestors[children[_j3]] || []).concat(_node2);
                            }
                        }

                        // Topo sort

                        var visited = {};
                        var sorted = [];

                        for (var _i5 = 0; _i5 < this._items.length; ++_i5) {
                            // Really looping thru item.seq values out of order
                            var next = _i5;

                            if (ancestors[_i5]) {
                                next = null;
                                for (var _j4 = 0; _j4 < this._items.length; ++_j4) {
                                    // As above, these are item.seq values
                                    if (visited[_j4] === true) {
                                        continue;
                                    }

                                    if (!ancestors[_j4]) {
                                        ancestors[_j4] = [];
                                    }

                                    var shouldSeeCount = ancestors[_j4].length;
                                    var seenCount = 0;
                                    for (var _k = 0; _k < shouldSeeCount; ++_k) {
                                        if (visited[ancestors[_j4][_k]]) {
                                            ++seenCount;
                                        }
                                    }

                                    if (seenCount === shouldSeeCount) {
                                        next = _j4;
                                        break;
                                    }
                                }
                            }

                            if (next !== null) {
                                visited[next] = true;
                                sorted.push(next);
                            }
                        }

                        if (sorted.length !== this._items.length) {
                            return new Error('Invalid dependencies');
                        }

                        var seqIndex = {};
                        for (var _i6 = 0; _i6 < this._items.length; ++_i6) {
                            var _item = this._items[_i6];
                            seqIndex[_item.seq] = _item;
                        }

                        var sortedNodes = [];
                        this._items = sorted.map(function (value) {

                            var sortedItem = seqIndex[value];
                            sortedNodes.push(sortedItem.node);
                            return sortedItem;
                        });

                        this.nodes = sortedNodes;
                    };

                    /***/ }),
                /* 32 */
                /***/ (function(module, exports, __webpack_require__) {


                    var Joi = __webpack_require__(8);

                    module.exports = Joi;

                    /***/ }),
                /* 33 */
                /***/ (function(module, exports, __webpack_require__) {


                    exports.byteLength = byteLength;
                    exports.toByteArray = toByteArray;
                    exports.fromByteArray = fromByteArray;

                    var lookup = [];
                    var revLookup = [];
                    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

                    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                    for (var i = 0, len = code.length; i < len; ++i) {
                        lookup[i] = code[i];
                        revLookup[code.charCodeAt(i)] = i;
                    }

                    revLookup['-'.charCodeAt(0)] = 62;
                    revLookup['_'.charCodeAt(0)] = 63;

                    function placeHoldersCount (b64) {
                        var len = b64.length;
                        if (len % 4 > 0) {
                            throw new Error('Invalid string. Length must be a multiple of 4')
                        }

                        // the number of equal signs (place holders)
                        // if there are two placeholders, than the two characters before it
                        // represent one byte
                        // if there is only one, then the three characters before it represent 2 bytes
                        // this is just a cheap hack to not do indexOf twice
                        return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
                    }

                    function byteLength (b64) {
                        // base64 is 4/3 + up to two characters of the original data
                        return (b64.length * 3 / 4) - placeHoldersCount(b64)
                    }

                    function toByteArray (b64) {
                        var i, l, tmp, placeHolders, arr;
                        var len = b64.length;
                        placeHolders = placeHoldersCount(b64);

                        arr = new Arr((len * 3 / 4) - placeHolders);

                        // if there are placeholders, only get up to the last complete 4 chars
                        l = placeHolders > 0 ? len - 4 : len;

                        var L = 0;

                        for (i = 0; i < l; i += 4) {
                            tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
                            arr[L++] = (tmp >> 16) & 0xFF;
                            arr[L++] = (tmp >> 8) & 0xFF;
                            arr[L++] = tmp & 0xFF;
                        }

                        if (placeHolders === 2) {
                            tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
                            arr[L++] = tmp & 0xFF;
                        } else if (placeHolders === 1) {
                            tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
                            arr[L++] = (tmp >> 8) & 0xFF;
                            arr[L++] = tmp & 0xFF;
                        }

                        return arr
                    }

                    function tripletToBase64 (num) {
                        return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
                    }

                    function encodeChunk (uint8, start, end) {
                        var tmp;
                        var output = [];
                        for (var i = start; i < end; i += 3) {
                            tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
                            output.push(tripletToBase64(tmp));
                        }
                        return output.join('')
                    }

                    function fromByteArray (uint8) {
                        var tmp;
                        var len = uint8.length;
                        var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
                        var output = '';
                        var parts = [];
                        var maxChunkLength = 16383; // must be multiple of 3

                        // go through the array every three bytes, we'll deal with trailing stuff later
                        for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
                            parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
                        }

                        // pad the end with zeros, but make sure to not forget the extra bytes
                        if (extraBytes === 1) {
                            tmp = uint8[len - 1];
                            output += lookup[tmp >> 2];
                            output += lookup[(tmp << 4) & 0x3F];
                            output += '==';
                        } else if (extraBytes === 2) {
                            tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
                            output += lookup[tmp >> 10];
                            output += lookup[(tmp >> 4) & 0x3F];
                            output += lookup[(tmp << 2) & 0x3F];
                            output += '=';
                        }

                        parts.push(output);

                        return parts.join('')
                    }


                    /***/ }),
                /* 34 */
                /***/ (function(module, exports) {

                    exports.read = function (buffer, offset, isLE, mLen, nBytes) {
                        var e, m;
                        var eLen = nBytes * 8 - mLen - 1;
                        var eMax = (1 << eLen) - 1;
                        var eBias = eMax >> 1;
                        var nBits = -7;
                        var i = isLE ? (nBytes - 1) : 0;
                        var d = isLE ? -1 : 1;
                        var s = buffer[offset + i];

                        i += d;

                        e = s & ((1 << (-nBits)) - 1);
                        s >>= (-nBits);
                        nBits += eLen;
                        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

                        m = e & ((1 << (-nBits)) - 1);
                        e >>= (-nBits);
                        nBits += mLen;
                        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

                        if (e === 0) {
                            e = 1 - eBias;
                        } else if (e === eMax) {
                            return m ? NaN : ((s ? -1 : 1) * Infinity)
                        } else {
                            m = m + Math.pow(2, mLen);
                            e = e - eBias;
                        }
                        return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
                    };

                    exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
                        var e, m, c;
                        var eLen = nBytes * 8 - mLen - 1;
                        var eMax = (1 << eLen) - 1;
                        var eBias = eMax >> 1;
                        var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
                        var i = isLE ? 0 : (nBytes - 1);
                        var d = isLE ? 1 : -1;
                        var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

                        value = Math.abs(value);

                        if (isNaN(value) || value === Infinity) {
                            m = isNaN(value) ? 1 : 0;
                            e = eMax;
                        } else {
                            e = Math.floor(Math.log(value) / Math.LN2);
                            if (value * (c = Math.pow(2, -e)) < 1) {
                                e--;
                                c *= 2;
                            }
                            if (e + eBias >= 1) {
                                value += rt / c;
                            } else {
                                value += rt * Math.pow(2, 1 - eBias);
                            }
                            if (value * c >= 2) {
                                e++;
                                c /= 2;
                            }

                            if (e + eBias >= eMax) {
                                m = 0;
                                e = eMax;
                            } else if (e + eBias >= 1) {
                                m = (value * c - 1) * Math.pow(2, mLen);
                                e = e + eBias;
                            } else {
                                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                                e = 0;
                            }
                        }

                        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

                        e = (e << mLen) | m;
                        eLen += mLen;
                        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

                        buffer[offset + i - d] |= s * 128;
                    };


                    /***/ }),
                /* 35 */
                /***/ (function(module, exports) {

                    var toString = {}.toString;

                    module.exports = Array.isArray || function (arr) {
                        return toString.call(arr) == '[object Array]';
                    };


                    /***/ }),
                /* 36 */
                /***/ (function(module, exports) {

                    module.exports = {"_args":[["joi@13.4.0","/Users/jeff/projects/joi-browser"]],"_development":true,"_from":"joi@13.4.0","_id":"joi@13.4.0","_inBundle":false,"_integrity":"sha512-JuK4GjEu6j7zr9FuVe2MAseZ6si/8/HaY0qMAejfDFHp7jcH4OKE937mIHM5VT4xDS0q7lpQbszbxKV9rm0yUg==","_location":"/joi","_phantomChildren":{},"_requested":{"type":"version","registry":true,"raw":"joi@13.4.0","name":"joi","escapedName":"joi","rawSpec":"13.4.0","saveSpec":null,"fetchSpec":"13.4.0"},"_requiredBy":["#DEV:/"],"_resolved":"https://registry.npmjs.org/joi/-/joi-13.4.0.tgz","_spec":"13.4.0","_where":"/Users/jeff/projects/joi-browser","bugs":{"url":"https://github.com/hapijs/joi/issues"},"dependencies":{"hoek":"5.x.x","isemail":"3.x.x","topo":"3.x.x"},"description":"Object schema validation","devDependencies":{"code":"5.x.x","hapitoc":"1.x.x","lab":"15.x.x"},"engines":{"node":">=8.9.0"},"homepage":"https://github.com/hapijs/joi","keywords":["hapi","schema","validation"],"license":"BSD-3-Clause","main":"lib/index.js","name":"joi","repository":{"type":"git","url":"git://github.com/hapijs/joi.git"},"scripts":{"test":"lab -t 100 -a code -L","test-cov-html":"lab -r html -o coverage.html -a code","test-debug":"lab -a code","toc":"hapitoc","version":"npm run toc && git add API.md README.md"},"version":"13.4.0"};

                    /***/ }),
                /* 37 */
                /***/ (function(module, exports, __webpack_require__) {

                    /* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
                        function normalizeArray(parts, allowAboveRoot) {
                            // if the path tries to go above the root, `up` ends up > 0
                            var up = 0;
                            for (var i = parts.length - 1; i >= 0; i--) {
                                var last = parts[i];
                                if (last === '.') {
                                    parts.splice(i, 1);
                                } else if (last === '..') {
                                    parts.splice(i, 1);
                                    up++;
                                } else if (up) {
                                    parts.splice(i, 1);
                                    up--;
                                }
                            }

                            // if the path is allowed to go above the root, restore leading ..s
                            if (allowAboveRoot) {
                                for (; up--; up) {
                                    parts.unshift('..');
                                }
                            }

                            return parts;
                        }

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
                        var splitPathRe =
                            /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
                        var splitPath = function(filename) {
                            return splitPathRe.exec(filename).slice(1);
                        };

// path.resolve([from ...], to)
// posix version
                        exports.resolve = function() {
                            var resolvedPath = '',
                                resolvedAbsolute = false;

                            for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
                                var path = (i >= 0) ? arguments[i] : process.cwd();

                                // Skip empty and invalid entries
                                if (typeof path !== 'string') {
                                    throw new TypeError('Arguments to path.resolve must be strings');
                                } else if (!path) {
                                    continue;
                                }

                                resolvedPath = path + '/' + resolvedPath;
                                resolvedAbsolute = path.charAt(0) === '/';
                            }

                            // At this point the path should be resolved to a full absolute path, but
                            // handle relative paths to be safe (might happen when process.cwd() fails)

                            // Normalize the path
                            resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
                                return !!p;
                            }), !resolvedAbsolute).join('/');

                            return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
                        };

// path.normalize(path)
// posix version
                        exports.normalize = function(path) {
                            var isAbsolute = exports.isAbsolute(path),
                                trailingSlash = substr(path, -1) === '/';

                            // Normalize the path
                            path = normalizeArray(filter(path.split('/'), function(p) {
                                return !!p;
                            }), !isAbsolute).join('/');

                            if (!path && !isAbsolute) {
                                path = '.';
                            }
                            if (path && trailingSlash) {
                                path += '/';
                            }

                            return (isAbsolute ? '/' : '') + path;
                        };

// posix version
                        exports.isAbsolute = function(path) {
                            return path.charAt(0) === '/';
                        };

// posix version
                        exports.join = function() {
                            var paths = Array.prototype.slice.call(arguments, 0);
                            return exports.normalize(filter(paths, function(p, index) {
                                if (typeof p !== 'string') {
                                    throw new TypeError('Arguments to path.join must be strings');
                                }
                                return p;
                            }).join('/'));
                        };


// path.relative(from, to)
// posix version
                        exports.relative = function(from, to) {
                            from = exports.resolve(from).substr(1);
                            to = exports.resolve(to).substr(1);

                            function trim(arr) {
                                var start = 0;
                                for (; start < arr.length; start++) {
                                    if (arr[start] !== '') break;
                                }

                                var end = arr.length - 1;
                                for (; end >= 0; end--) {
                                    if (arr[end] !== '') break;
                                }

                                if (start > end) return [];
                                return arr.slice(start, end - start + 1);
                            }

                            var fromParts = trim(from.split('/'));
                            var toParts = trim(to.split('/'));

                            var length = Math.min(fromParts.length, toParts.length);
                            var samePartsLength = length;
                            for (var i = 0; i < length; i++) {
                                if (fromParts[i] !== toParts[i]) {
                                    samePartsLength = i;
                                    break;
                                }
                            }

                            var outputParts = [];
                            for (var i = samePartsLength; i < fromParts.length; i++) {
                                outputParts.push('..');
                            }

                            outputParts = outputParts.concat(toParts.slice(samePartsLength));

                            return outputParts.join('/');
                        };

                        exports.sep = '/';
                        exports.delimiter = ':';

                        exports.dirname = function(path) {
                            var result = splitPath(path),
                                root = result[0],
                                dir = result[1];

                            if (!root && !dir) {
                                // No dirname whatsoever
                                return '.';
                            }

                            if (dir) {
                                // It has a dirname, strip trailing slash
                                dir = dir.substr(0, dir.length - 1);
                            }

                            return root + dir;
                        };


                        exports.basename = function(path, ext) {
                            var f = splitPath(path)[2];
                            // TODO: make this comparison case-insensitive on windows?
                            if (ext && f.substr(-1 * ext.length) === ext) {
                                f = f.substr(0, f.length - ext.length);
                            }
                            return f;
                        };


                        exports.extname = function(path) {
                            return splitPath(path)[3];
                        };

                        function filter (xs, f) {
                            if (xs.filter) return xs.filter(f);
                            var res = [];
                            for (var i = 0; i < xs.length; i++) {
                                if (f(xs[i], i, xs)) res.push(xs[i]);
                            }
                            return res;
                        }

// String.prototype.substr - negative index don't work in IE8
                        var substr = 'ab'.substr(-1) === 'b'
                            ? function (str, start, len) { return str.substr(start, len) }
                            : function (str, start, len) {
                                if (start < 0) start = str.length + start;
                                return str.substr(start, len);
                            }
                        ;

                        /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)));

                    /***/ }),
                /* 38 */
                /***/ (function(module, exports, __webpack_require__) {

                    /* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
                        (function(root) {

                            /** Detect free variables */
                            typeof exports == 'object' && exports &&
                            !exports.nodeType && exports;
                            typeof module == 'object' && module &&
                            !module.nodeType && module;
                            var freeGlobal = typeof global == 'object' && global;
                            if (
                                freeGlobal.global === freeGlobal ||
                                freeGlobal.window === freeGlobal ||
                                freeGlobal.self === freeGlobal
                            ) ;

                            /**
                             * The `punycode` object.
                             * @name punycode
                             * @type Object
                             */
                            var punycode,

                                /** Highest positive signed 32-bit float value */
                                maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

                                /** Bootstring parameters */
                                base = 36,
                                tMin = 1,
                                tMax = 26,
                                skew = 38,
                                damp = 700,
                                initialBias = 72,
                                initialN = 128, // 0x80
                                delimiter = '-', // '\x2D'

                                /** Regular expressions */
                                regexPunycode = /^xn--/,
                                regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
                                regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

                                /** Error messages */
                                errors = {
                                    'overflow': 'Overflow: input needs wider integers to process',
                                    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
                                    'invalid-input': 'Invalid input'
                                },

                                /** Convenience shortcuts */
                                baseMinusTMin = base - tMin,
                                floor = Math.floor,
                                stringFromCharCode = String.fromCharCode;

                            /*--------------------------------------------------------------------------*/

                            /**
                             * A generic error utility function.
                             * @private
                             * @param {String} type The error type.
                             * @returns {Error} Throws a `RangeError` with the applicable error message.
                             */
                            function error(type) {
                                throw new RangeError(errors[type]);
                            }

                            /**
                             * A generic `Array#map` utility function.
                             * @private
                             * @param {Array} array The array to iterate over.
                             * @param {Function} callback The function that gets called for every array
                             * item.
                             * @returns {Array} A new array of values returned by the callback function.
                             */
                            function map(array, fn) {
                                var length = array.length;
                                var result = [];
                                while (length--) {
                                    result[length] = fn(array[length]);
                                }
                                return result;
                            }

                            /**
                             * A simple `Array#map`-like wrapper to work with domain name strings or email
                             * addresses.
                             * @private
                             * @param {String} domain The domain name or email address.
                             * @param {Function} callback The function that gets called for every
                             * character.
                             * @returns {Array} A new string of characters returned by the callback
                             * function.
                             */
                            function mapDomain(string, fn) {
                                var parts = string.split('@');
                                var result = '';
                                if (parts.length > 1) {
                                    // In email addresses, only the domain name should be punycoded. Leave
                                    // the local part (i.e. everything up to `@`) intact.
                                    result = parts[0] + '@';
                                    string = parts[1];
                                }
                                // Avoid `split(regex)` for IE8 compatibility. See #17.
                                string = string.replace(regexSeparators, '\x2E');
                                var labels = string.split('.');
                                var encoded = map(labels, fn).join('.');
                                return result + encoded;
                            }

                            /**
                             * Creates an array containing the numeric code points of each Unicode
                             * character in the string. While JavaScript uses UCS-2 internally,
                             * this function will convert a pair of surrogate halves (each of which
                             * UCS-2 exposes as separate characters) into a single code point,
                             * matching UTF-16.
                             * @see `punycode.ucs2.encode`
                             * @see <https://mathiasbynens.be/notes/javascript-encoding>
                             * @memberOf punycode.ucs2
                             * @name decode
                             * @param {String} string The Unicode input string (UCS-2).
                             * @returns {Array} The new array of code points.
                             */
                            function ucs2decode(string) {
                                var output = [],
                                    counter = 0,
                                    length = string.length,
                                    value,
                                    extra;
                                while (counter < length) {
                                    value = string.charCodeAt(counter++);
                                    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                                        // high surrogate, and there is a next character
                                        extra = string.charCodeAt(counter++);
                                        if ((extra & 0xFC00) == 0xDC00) { // low surrogate
                                            output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                                        } else {
                                            // unmatched surrogate; only append this code unit, in case the next
                                            // code unit is the high surrogate of a surrogate pair
                                            output.push(value);
                                            counter--;
                                        }
                                    } else {
                                        output.push(value);
                                    }
                                }
                                return output;
                            }

                            /**
                             * Creates a string based on an array of numeric code points.
                             * @see `punycode.ucs2.decode`
                             * @memberOf punycode.ucs2
                             * @name encode
                             * @param {Array} codePoints The array of numeric code points.
                             * @returns {String} The new Unicode string (UCS-2).
                             */
                            function ucs2encode(array) {
                                return map(array, function(value) {
                                    var output = '';
                                    if (value > 0xFFFF) {
                                        value -= 0x10000;
                                        output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                                        value = 0xDC00 | value & 0x3FF;
                                    }
                                    output += stringFromCharCode(value);
                                    return output;
                                }).join('');
                            }

                            /**
                             * Converts a basic code point into a digit/integer.
                             * @see `digitToBasic()`
                             * @private
                             * @param {Number} codePoint The basic numeric code point value.
                             * @returns {Number} The numeric value of a basic code point (for use in
                             * representing integers) in the range `0` to `base - 1`, or `base` if
                             * the code point does not represent a value.
                             */
                            function basicToDigit(codePoint) {
                                if (codePoint - 48 < 10) {
                                    return codePoint - 22;
                                }
                                if (codePoint - 65 < 26) {
                                    return codePoint - 65;
                                }
                                if (codePoint - 97 < 26) {
                                    return codePoint - 97;
                                }
                                return base;
                            }

                            /**
                             * Converts a digit/integer into a basic code point.
                             * @see `basicToDigit()`
                             * @private
                             * @param {Number} digit The numeric value of a basic code point.
                             * @returns {Number} The basic code point whose value (when used for
                             * representing integers) is `digit`, which needs to be in the range
                             * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
                             * used; else, the lowercase form is used. The behavior is undefined
                             * if `flag` is non-zero and `digit` has no uppercase form.
                             */
                            function digitToBasic(digit, flag) {
                                //  0..25 map to ASCII a..z or A..Z
                                // 26..35 map to ASCII 0..9
                                return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
                            }

                            /**
                             * Bias adaptation function as per section 3.4 of RFC 3492.
                             * https://tools.ietf.org/html/rfc3492#section-3.4
                             * @private
                             */
                            function adapt(delta, numPoints, firstTime) {
                                var k = 0;
                                delta = firstTime ? floor(delta / damp) : delta >> 1;
                                delta += floor(delta / numPoints);
                                for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
                                    delta = floor(delta / baseMinusTMin);
                                }
                                return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
                            }

                            /**
                             * Converts a Punycode string of ASCII-only symbols to a string of Unicode
                             * symbols.
                             * @memberOf punycode
                             * @param {String} input The Punycode string of ASCII-only symbols.
                             * @returns {String} The resulting string of Unicode symbols.
                             */
                            function decode(input) {
                                // Don't use UCS-2
                                var output = [],
                                    inputLength = input.length,
                                    out,
                                    i = 0,
                                    n = initialN,
                                    bias = initialBias,
                                    basic,
                                    j,
                                    index,
                                    oldi,
                                    w,
                                    k,
                                    digit,
                                    t,
                                    /** Cached calculation results */
                                    baseMinusT;

                                // Handle the basic code points: let `basic` be the number of input code
                                // points before the last delimiter, or `0` if there is none, then copy
                                // the first basic code points to the output.

                                basic = input.lastIndexOf(delimiter);
                                if (basic < 0) {
                                    basic = 0;
                                }

                                for (j = 0; j < basic; ++j) {
                                    // if it's not a basic code point
                                    if (input.charCodeAt(j) >= 0x80) {
                                        error('not-basic');
                                    }
                                    output.push(input.charCodeAt(j));
                                }

                                // Main decoding loop: start just after the last delimiter if any basic code
                                // points were copied; start at the beginning otherwise.

                                for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

                                    // `index` is the index of the next character to be consumed.
                                    // Decode a generalized variable-length integer into `delta`,
                                    // which gets added to `i`. The overflow checking is easier
                                    // if we increase `i` as we go, then subtract off its starting
                                    // value at the end to obtain `delta`.
                                    for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

                                        if (index >= inputLength) {
                                            error('invalid-input');
                                        }

                                        digit = basicToDigit(input.charCodeAt(index++));

                                        if (digit >= base || digit > floor((maxInt - i) / w)) {
                                            error('overflow');
                                        }

                                        i += digit * w;
                                        t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

                                        if (digit < t) {
                                            break;
                                        }

                                        baseMinusT = base - t;
                                        if (w > floor(maxInt / baseMinusT)) {
                                            error('overflow');
                                        }

                                        w *= baseMinusT;

                                    }

                                    out = output.length + 1;
                                    bias = adapt(i - oldi, out, oldi == 0);

                                    // `i` was supposed to wrap around from `out` to `0`,
                                    // incrementing `n` each time, so we'll fix that now:
                                    if (floor(i / out) > maxInt - n) {
                                        error('overflow');
                                    }

                                    n += floor(i / out);
                                    i %= out;

                                    // Insert `n` at position `i` of the output
                                    output.splice(i++, 0, n);

                                }

                                return ucs2encode(output);
                            }

                            /**
                             * Converts a string of Unicode symbols (e.g. a domain name label) to a
                             * Punycode string of ASCII-only symbols.
                             * @memberOf punycode
                             * @param {String} input The string of Unicode symbols.
                             * @returns {String} The resulting Punycode string of ASCII-only symbols.
                             */
                            function encode(input) {
                                var n,
                                    delta,
                                    handledCPCount,
                                    basicLength,
                                    bias,
                                    j,
                                    m,
                                    q,
                                    k,
                                    t,
                                    currentValue,
                                    output = [],
                                    /** `inputLength` will hold the number of code points in `input`. */
                                    inputLength,
                                    /** Cached calculation results */
                                    handledCPCountPlusOne,
                                    baseMinusT,
                                    qMinusT;

                                // Convert the input in UCS-2 to Unicode
                                input = ucs2decode(input);

                                // Cache the length
                                inputLength = input.length;

                                // Initialize the state
                                n = initialN;
                                delta = 0;
                                bias = initialBias;

                                // Handle the basic code points
                                for (j = 0; j < inputLength; ++j) {
                                    currentValue = input[j];
                                    if (currentValue < 0x80) {
                                        output.push(stringFromCharCode(currentValue));
                                    }
                                }

                                handledCPCount = basicLength = output.length;

                                // `handledCPCount` is the number of code points that have been handled;
                                // `basicLength` is the number of basic code points.

                                // Finish the basic string - if it is not empty - with a delimiter
                                if (basicLength) {
                                    output.push(delimiter);
                                }

                                // Main encoding loop:
                                while (handledCPCount < inputLength) {

                                    // All non-basic code points < n have been handled already. Find the next
                                    // larger one:
                                    for (m = maxInt, j = 0; j < inputLength; ++j) {
                                        currentValue = input[j];
                                        if (currentValue >= n && currentValue < m) {
                                            m = currentValue;
                                        }
                                    }

                                    // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
                                    // but guard against overflow
                                    handledCPCountPlusOne = handledCPCount + 1;
                                    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                                        error('overflow');
                                    }

                                    delta += (m - n) * handledCPCountPlusOne;
                                    n = m;

                                    for (j = 0; j < inputLength; ++j) {
                                        currentValue = input[j];

                                        if (currentValue < n && ++delta > maxInt) {
                                            error('overflow');
                                        }

                                        if (currentValue == n) {
                                            // Represent delta as a generalized variable-length integer
                                            for (q = delta, k = base; /* no condition */; k += base) {
                                                t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
                                                if (q < t) {
                                                    break;
                                                }
                                                qMinusT = q - t;
                                                baseMinusT = base - t;
                                                output.push(
                                                    stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                                                );
                                                q = floor(qMinusT / baseMinusT);
                                            }

                                            output.push(stringFromCharCode(digitToBasic(q, 0)));
                                            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                                            delta = 0;
                                            ++handledCPCount;
                                        }
                                    }

                                    ++delta;
                                    ++n;

                                }
                                return output.join('');
                            }

                            /**
                             * Converts a Punycode string representing a domain name or an email address
                             * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
                             * it doesn't matter if you call it on a string that has already been
                             * converted to Unicode.
                             * @memberOf punycode
                             * @param {String} input The Punycoded domain name or email address to
                             * convert to Unicode.
                             * @returns {String} The Unicode representation of the given Punycode
                             * string.
                             */
                            function toUnicode(input) {
                                return mapDomain(input, function(string) {
                                    return regexPunycode.test(string)
                                        ? decode(string.slice(4).toLowerCase())
                                        : string;
                                });
                            }

                            /**
                             * Converts a Unicode string representing a domain name or an email address to
                             * Punycode. Only the non-ASCII parts of the domain name will be converted,
                             * i.e. it doesn't matter if you call it with a domain that's already in
                             * ASCII.
                             * @memberOf punycode
                             * @param {String} input The domain name or email address to convert, as a
                             * Unicode string.
                             * @returns {String} The Punycode representation of the given domain name or
                             * email address.
                             */
                            function toASCII(input) {
                                return mapDomain(input, function(string) {
                                    return regexNonASCII.test(string)
                                        ? 'xn--' + encode(string)
                                        : string;
                                });
                            }

                            /*--------------------------------------------------------------------------*/

                            /** Define the public API */
                            punycode = {
                                /**
                                 * A string representing the current Punycode.js version number.
                                 * @memberOf punycode
                                 * @type String
                                 */
                                'version': '1.4.1',
                                /**
                                 * An object of methods to convert from JavaScript's internal character
                                 * representation (UCS-2) to Unicode code points, and back.
                                 * @see <https://mathiasbynens.be/notes/javascript-encoding>
                                 * @memberOf punycode
                                 * @type Object
                                 */
                                'ucs2': {
                                    'decode': ucs2decode,
                                    'encode': ucs2encode
                                },
                                'decode': decode,
                                'encode': encode,
                                'toASCII': toASCII,
                                'toUnicode': toUnicode
                            };

                            /** Expose `punycode` */
                            // Some AMD build optimizers, like r.js, check for specific condition patterns
                            // like the following:
                            {
                                !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                                    return punycode;
                                }.call(exports, __webpack_require__, exports, module),
                                __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                            }

                        }());

                        /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(41)(module), __webpack_require__(5)));

                    /***/ }),
                /* 39 */
                /***/ (function(module, exports) {

                    if (typeof Object.create === 'function') {
                        // implementation from standard node.js 'util' module
                        module.exports = function inherits(ctor, superCtor) {
                            ctor.super_ = superCtor;
                            ctor.prototype = Object.create(superCtor.prototype, {
                                constructor: {
                                    value: ctor,
                                    enumerable: false,
                                    writable: true,
                                    configurable: true
                                }
                            });
                        };
                    } else {
                        // old school shim for old browsers
                        module.exports = function inherits(ctor, superCtor) {
                            ctor.super_ = superCtor;
                            var TempCtor = function () {};
                            TempCtor.prototype = superCtor.prototype;
                            ctor.prototype = new TempCtor();
                            ctor.prototype.constructor = ctor;
                        };
                    }


                    /***/ }),
                /* 40 */
                /***/ (function(module, exports) {

                    module.exports = function isBuffer(arg) {
                        return arg && typeof arg === 'object'
                            && typeof arg.copy === 'function'
                            && typeof arg.fill === 'function'
                            && typeof arg.readUInt8 === 'function';
                    };

                    /***/ }),
                /* 41 */
                /***/ (function(module, exports) {

                    module.exports = function(module) {
                        if(!module.webpackPolyfill) {
                            module.deprecate = function() {};
                            module.paths = [];
                            // module.parent = undefined by default
                            if(!module.children) module.children = [];
                            Object.defineProperty(module, "loaded", {
                                enumerable: true,
                                get: function() {
                                    return module.l;
                                }
                            });
                            Object.defineProperty(module, "id", {
                                enumerable: true,
                                get: function() {
                                    return module.i;
                                }
                            });
                            module.webpackPolyfill = 1;
                        }
                        return module;
                    };


                    /***/ })
                /******/ ]);
    });
});

var BaseJoi = unwrapExports(joiBrowser);

var moment$1 = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
        module.exports = factory() ;
    }(commonjsGlobal, (function () {
        var hookCallback;

        function hooks() {
            return hookCallback.apply(null, arguments);
        }

        // This is done to register the method called with moment()
        // without creating circular dependencies.
        function setHookCallback(callback) {
            hookCallback = callback;
        }

        function isArray(input) {
            return (
                input instanceof Array ||
                Object.prototype.toString.call(input) === '[object Array]'
            );
        }

        function isObject(input) {
            // IE8 will treat undefined and null as object if it wasn't for
            // input != null
            return (
                input != null &&
                Object.prototype.toString.call(input) === '[object Object]'
            );
        }

        function hasOwnProp(a, b) {
            return Object.prototype.hasOwnProperty.call(a, b);
        }

        function isObjectEmpty(obj) {
            if (Object.getOwnPropertyNames) {
                return Object.getOwnPropertyNames(obj).length === 0;
            } else {
                var k;
                for (k in obj) {
                    if (hasOwnProp(obj, k)) {
                        return false;
                    }
                }
                return true;
            }
        }

        function isUndefined(input) {
            return input === void 0;
        }

        function isNumber(input) {
            return (
                typeof input === 'number' ||
                Object.prototype.toString.call(input) === '[object Number]'
            );
        }

        function isDate(input) {
            return (
                input instanceof Date ||
                Object.prototype.toString.call(input) === '[object Date]'
            );
        }

        function map(arr, fn) {
            var res = [],
                i;
            for (i = 0; i < arr.length; ++i) {
                res.push(fn(arr[i], i));
            }
            return res;
        }

        function extend(a, b) {
            for (var i in b) {
                if (hasOwnProp(b, i)) {
                    a[i] = b[i];
                }
            }

            if (hasOwnProp(b, 'toString')) {
                a.toString = b.toString;
            }

            if (hasOwnProp(b, 'valueOf')) {
                a.valueOf = b.valueOf;
            }

            return a;
        }

        function createUTC(input, format, locale, strict) {
            return createLocalOrUTC(input, format, locale, strict, true).utc();
        }

        function defaultParsingFlags() {
            // We need to deep clone this object.
            return {
                empty: false,
                unusedTokens: [],
                unusedInput: [],
                overflow: -2,
                charsLeftOver: 0,
                nullInput: false,
                invalidEra: null,
                invalidMonth: null,
                invalidFormat: false,
                userInvalidated: false,
                iso: false,
                parsedDateParts: [],
                era: null,
                meridiem: null,
                rfc2822: false,
                weekdayMismatch: false,
            };
        }

        function getParsingFlags(m) {
            if (m._pf == null) {
                m._pf = defaultParsingFlags();
            }
            return m._pf;
        }

        var some;
        if (Array.prototype.some) {
            some = Array.prototype.some;
        } else {
            some = function (fun) {
                var t = Object(this),
                    len = t.length >>> 0,
                    i;

                for (i = 0; i < len; i++) {
                    if (i in t && fun.call(this, t[i], i, t)) {
                        return true;
                    }
                }

                return false;
            };
        }

        function isValid(m) {
            if (m._isValid == null) {
                var flags = getParsingFlags(m),
                    parsedParts = some.call(flags.parsedDateParts, function (i) {
                        return i != null;
                    }),
                    isNowValid =
                        !isNaN(m._d.getTime()) &&
                        flags.overflow < 0 &&
                        !flags.empty &&
                        !flags.invalidEra &&
                        !flags.invalidMonth &&
                        !flags.invalidWeekday &&
                        !flags.weekdayMismatch &&
                        !flags.nullInput &&
                        !flags.invalidFormat &&
                        !flags.userInvalidated &&
                        (!flags.meridiem || (flags.meridiem && parsedParts));

                if (m._strict) {
                    isNowValid =
                        isNowValid &&
                        flags.charsLeftOver === 0 &&
                        flags.unusedTokens.length === 0 &&
                        flags.bigHour === undefined;
                }

                if (Object.isFrozen == null || !Object.isFrozen(m)) {
                    m._isValid = isNowValid;
                } else {
                    return isNowValid;
                }
            }
            return m._isValid;
        }

        function createInvalid(flags) {
            var m = createUTC(NaN);
            if (flags != null) {
                extend(getParsingFlags(m), flags);
            } else {
                getParsingFlags(m).userInvalidated = true;
            }

            return m;
        }

        // Plugins that add properties should also add the key here (null value),
        // so we can properly clone ourselves.
        var momentProperties = (hooks.momentProperties = []),
            updateInProgress = false;

        function copyConfig(to, from) {
            var i, prop, val;

            if (!isUndefined(from._isAMomentObject)) {
                to._isAMomentObject = from._isAMomentObject;
            }
            if (!isUndefined(from._i)) {
                to._i = from._i;
            }
            if (!isUndefined(from._f)) {
                to._f = from._f;
            }
            if (!isUndefined(from._l)) {
                to._l = from._l;
            }
            if (!isUndefined(from._strict)) {
                to._strict = from._strict;
            }
            if (!isUndefined(from._tzm)) {
                to._tzm = from._tzm;
            }
            if (!isUndefined(from._isUTC)) {
                to._isUTC = from._isUTC;
            }
            if (!isUndefined(from._offset)) {
                to._offset = from._offset;
            }
            if (!isUndefined(from._pf)) {
                to._pf = getParsingFlags(from);
            }
            if (!isUndefined(from._locale)) {
                to._locale = from._locale;
            }

            if (momentProperties.length > 0) {
                for (i = 0; i < momentProperties.length; i++) {
                    prop = momentProperties[i];
                    val = from[prop];
                    if (!isUndefined(val)) {
                        to[prop] = val;
                    }
                }
            }

            return to;
        }

        // Moment prototype object
        function Moment(config) {
            copyConfig(this, config);
            this._d = new Date(config._d != null ? config._d.getTime() : NaN);
            if (!this.isValid()) {
                this._d = new Date(NaN);
            }
            // Prevent infinite loop in case updateOffset creates new moment
            // objects.
            if (updateInProgress === false) {
                updateInProgress = true;
                hooks.updateOffset(this);
                updateInProgress = false;
            }
        }

        function isMoment(obj) {
            return (
                obj instanceof Moment || (obj != null && obj._isAMomentObject != null)
            );
        }

        function warn(msg) {
            if (
                hooks.suppressDeprecationWarnings === false &&
                typeof console !== 'undefined' &&
                console.warn
            ) {
                console.warn('Deprecation warning: ' + msg);
            }
        }

        function deprecate(msg, fn) {
            var firstTime = true;

            return extend(function () {
                if (hooks.deprecationHandler != null) {
                    hooks.deprecationHandler(null, msg);
                }
                if (firstTime) {
                    var args = [],
                        arg,
                        i,
                        key;
                    for (i = 0; i < arguments.length; i++) {
                        arg = '';
                        if (typeof arguments[i] === 'object') {
                            arg += '\n[' + i + '] ';
                            for (key in arguments[0]) {
                                if (hasOwnProp(arguments[0], key)) {
                                    arg += key + ': ' + arguments[0][key] + ', ';
                                }
                            }
                            arg = arg.slice(0, -2); // Remove trailing comma and space
                        } else {
                            arg = arguments[i];
                        }
                        args.push(arg);
                    }
                    warn(
                        msg +
                        '\nArguments: ' +
                        Array.prototype.slice.call(args).join('') +
                        '\n' +
                        new Error().stack
                    );
                    firstTime = false;
                }
                return fn.apply(this, arguments);
            }, fn);
        }

        var deprecations = {};

        function deprecateSimple(name, msg) {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(name, msg);
            }
            if (!deprecations[name]) {
                warn(msg);
                deprecations[name] = true;
            }
        }

        hooks.suppressDeprecationWarnings = false;
        hooks.deprecationHandler = null;

        function isFunction(input) {
            return (
                (typeof Function !== 'undefined' && input instanceof Function) ||
                Object.prototype.toString.call(input) === '[object Function]'
            );
        }

        function set(config) {
            var prop, i;
            for (i in config) {
                if (hasOwnProp(config, i)) {
                    prop = config[i];
                    if (isFunction(prop)) {
                        this[i] = prop;
                    } else {
                        this['_' + i] = prop;
                    }
                }
            }
            this._config = config;
            // Lenient ordinal parsing accepts just a number in addition to
            // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
            // TODO: Remove "ordinalParse" fallback in next major release.
            this._dayOfMonthOrdinalParseLenient = new RegExp(
                (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                '|' +
                /\d{1,2}/.source
            );
        }

        function mergeConfigs(parentConfig, childConfig) {
            var res = extend({}, parentConfig),
                prop;
            for (prop in childConfig) {
                if (hasOwnProp(childConfig, prop)) {
                    if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                        res[prop] = {};
                        extend(res[prop], parentConfig[prop]);
                        extend(res[prop], childConfig[prop]);
                    } else if (childConfig[prop] != null) {
                        res[prop] = childConfig[prop];
                    } else {
                        delete res[prop];
                    }
                }
            }
            for (prop in parentConfig) {
                if (
                    hasOwnProp(parentConfig, prop) &&
                    !hasOwnProp(childConfig, prop) &&
                    isObject(parentConfig[prop])
                ) {
                    // make sure changes to properties don't modify parent config
                    res[prop] = extend({}, res[prop]);
                }
            }
            return res;
        }

        function Locale(config) {
            if (config != null) {
                this.set(config);
            }
        }

        var keys;

        if (Object.keys) {
            keys = Object.keys;
        } else {
            keys = function (obj) {
                var i,
                    res = [];
                for (i in obj) {
                    if (hasOwnProp(obj, i)) {
                        res.push(i);
                    }
                }
                return res;
            };
        }

        var defaultCalendar = {
            sameDay: '[Today at] LT',
            nextDay: '[Tomorrow at] LT',
            nextWeek: 'dddd [at] LT',
            lastDay: '[Yesterday at] LT',
            lastWeek: '[Last] dddd [at] LT',
            sameElse: 'L',
        };

        function calendar(key, mom, now) {
            var output = this._calendar[key] || this._calendar['sameElse'];
            return isFunction(output) ? output.call(mom, now) : output;
        }

        function zeroFill(number, targetLength, forceSign) {
            var absNumber = '' + Math.abs(number),
                zerosToFill = targetLength - absNumber.length,
                sign = number >= 0;
            return (
                (sign ? (forceSign ? '+' : '') : '-') +
                Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
                absNumber
            );
        }

        var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
            localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
            formatFunctions = {},
            formatTokenFunctions = {};

        // token:    'M'
        // padded:   ['MM', 2]
        // ordinal:  'Mo'
        // callback: function () { this.month() + 1 }
        function addFormatToken(token, padded, ordinal, callback) {
            var func = callback;
            if (typeof callback === 'string') {
                func = function () {
                    return this[callback]();
                };
            }
            if (token) {
                formatTokenFunctions[token] = func;
            }
            if (padded) {
                formatTokenFunctions[padded[0]] = function () {
                    return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
                };
            }
            if (ordinal) {
                formatTokenFunctions[ordinal] = function () {
                    return this.localeData().ordinal(
                        func.apply(this, arguments),
                        token
                    );
                };
            }
        }

        function removeFormattingTokens(input) {
            if (input.match(/\[[\s\S]/)) {
                return input.replace(/^\[|\]$/g, '');
            }
            return input.replace(/\\/g, '');
        }

        function makeFormatFunction(format) {
            var array = format.match(formattingTokens),
                i,
                length;

            for (i = 0, length = array.length; i < length; i++) {
                if (formatTokenFunctions[array[i]]) {
                    array[i] = formatTokenFunctions[array[i]];
                } else {
                    array[i] = removeFormattingTokens(array[i]);
                }
            }

            return function (mom) {
                var output = '',
                    i;
                for (i = 0; i < length; i++) {
                    output += isFunction(array[i])
                        ? array[i].call(mom, format)
                        : array[i];
                }
                return output;
            };
        }

        // format date using native date object
        function formatMoment(m, format) {
            if (!m.isValid()) {
                return m.localeData().invalidDate();
            }

            format = expandFormat(format, m.localeData());
            formatFunctions[format] =
                formatFunctions[format] || makeFormatFunction(format);

            return formatFunctions[format](m);
        }

        function expandFormat(format, locale) {
            var i = 5;

            function replaceLongDateFormatTokens(input) {
                return locale.longDateFormat(input) || input;
            }

            localFormattingTokens.lastIndex = 0;
            while (i >= 0 && localFormattingTokens.test(format)) {
                format = format.replace(
                    localFormattingTokens,
                    replaceLongDateFormatTokens
                );
                localFormattingTokens.lastIndex = 0;
                i -= 1;
            }

            return format;
        }

        var defaultLongDateFormat = {
            LTS: 'h:mm:ss A',
            LT: 'h:mm A',
            L: 'MM/DD/YYYY',
            LL: 'MMMM D, YYYY',
            LLL: 'MMMM D, YYYY h:mm A',
            LLLL: 'dddd, MMMM D, YYYY h:mm A',
        };

        function longDateFormat(key) {
            var format = this._longDateFormat[key],
                formatUpper = this._longDateFormat[key.toUpperCase()];

            if (format || !formatUpper) {
                return format;
            }

            this._longDateFormat[key] = formatUpper
                .match(formattingTokens)
                .map(function (tok) {
                    if (
                        tok === 'MMMM' ||
                        tok === 'MM' ||
                        tok === 'DD' ||
                        tok === 'dddd'
                    ) {
                        return tok.slice(1);
                    }
                    return tok;
                })
                .join('');

            return this._longDateFormat[key];
        }

        var defaultInvalidDate = 'Invalid date';

        function invalidDate() {
            return this._invalidDate;
        }

        var defaultOrdinal = '%d',
            defaultDayOfMonthOrdinalParse = /\d{1,2}/;

        function ordinal(number) {
            return this._ordinal.replace('%d', number);
        }

        var defaultRelativeTime = {
            future: 'in %s',
            past: '%s ago',
            s: 'a few seconds',
            ss: '%d seconds',
            m: 'a minute',
            mm: '%d minutes',
            h: 'an hour',
            hh: '%d hours',
            d: 'a day',
            dd: '%d days',
            w: 'a week',
            ww: '%d weeks',
            M: 'a month',
            MM: '%d months',
            y: 'a year',
            yy: '%d years',
        };

        function relativeTime(number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return isFunction(output)
                ? output(number, withoutSuffix, string, isFuture)
                : output.replace(/%d/i, number);
        }

        function pastFuture(diff, output) {
            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
            return isFunction(format) ? format(output) : format.replace(/%s/i, output);
        }

        var aliases = {};

        function addUnitAlias(unit, shorthand) {
            var lowerCase = unit.toLowerCase();
            aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
        }

        function normalizeUnits(units) {
            return typeof units === 'string'
                ? aliases[units] || aliases[units.toLowerCase()]
                : undefined;
        }

        function normalizeObjectUnits(inputObject) {
            var normalizedInput = {},
                normalizedProp,
                prop;

            for (prop in inputObject) {
                if (hasOwnProp(inputObject, prop)) {
                    normalizedProp = normalizeUnits(prop);
                    if (normalizedProp) {
                        normalizedInput[normalizedProp] = inputObject[prop];
                    }
                }
            }

            return normalizedInput;
        }

        var priorities = {};

        function addUnitPriority(unit, priority) {
            priorities[unit] = priority;
        }

        function getPrioritizedUnits(unitsObj) {
            var units = [],
                u;
            for (u in unitsObj) {
                if (hasOwnProp(unitsObj, u)) {
                    units.push({ unit: u, priority: priorities[u] });
                }
            }
            units.sort(function (a, b) {
                return a.priority - b.priority;
            });
            return units;
        }

        function isLeapYear(year) {
            return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
        }

        function absFloor(number) {
            if (number < 0) {
                // -0 -> 0
                return Math.ceil(number) || 0;
            } else {
                return Math.floor(number);
            }
        }

        function toInt(argumentForCoercion) {
            var coercedNumber = +argumentForCoercion,
                value = 0;

            if (coercedNumber !== 0 && isFinite(coercedNumber)) {
                value = absFloor(coercedNumber);
            }

            return value;
        }

        function makeGetSet(unit, keepTime) {
            return function (value) {
                if (value != null) {
                    set$1(this, unit, value);
                    hooks.updateOffset(this, keepTime);
                    return this;
                } else {
                    return get(this, unit);
                }
            };
        }

        function get(mom, unit) {
            return mom.isValid()
                ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]()
                : NaN;
        }

        function set$1(mom, unit, value) {
            if (mom.isValid() && !isNaN(value)) {
                if (
                    unit === 'FullYear' &&
                    isLeapYear(mom.year()) &&
                    mom.month() === 1 &&
                    mom.date() === 29
                ) {
                    value = toInt(value);
                    mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](
                        value,
                        mom.month(),
                        daysInMonth(value, mom.month())
                    );
                } else {
                    mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
                }
            }
        }

        // MOMENTS

        function stringGet(units) {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units]();
            }
            return this;
        }

        function stringSet(units, value) {
            if (typeof units === 'object') {
                units = normalizeObjectUnits(units);
                var prioritized = getPrioritizedUnits(units),
                    i;
                for (i = 0; i < prioritized.length; i++) {
                    this[prioritized[i].unit](units[prioritized[i].unit]);
                }
            } else {
                units = normalizeUnits(units);
                if (isFunction(this[units])) {
                    return this[units](value);
                }
            }
            return this;
        }

        var match1 = /\d/, //       0 - 9
            match2 = /\d\d/, //      00 - 99
            match3 = /\d{3}/, //     000 - 999
            match4 = /\d{4}/, //    0000 - 9999
            match6 = /[+-]?\d{6}/, // -999999 - 999999
            match1to2 = /\d\d?/, //       0 - 99
            match3to4 = /\d\d\d\d?/, //     999 - 9999
            match5to6 = /\d\d\d\d\d\d?/, //   99999 - 999999
            match1to3 = /\d{1,3}/, //       0 - 999
            match1to4 = /\d{1,4}/, //       0 - 9999
            match1to6 = /[+-]?\d{1,6}/, // -999999 - 999999
            matchUnsigned = /\d+/, //       0 - inf
            matchSigned = /[+-]?\d+/, //    -inf - inf
            matchOffset = /Z|[+-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
            matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 or Z
            matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
            // any word (or two) characters or numbers including two/three word month in arabic.
            // includes scottish gaelic two word and hyphenated months
            matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
            regexes;

        regexes = {};

        function addRegexToken(token, regex, strictRegex) {
            regexes[token] = isFunction(regex)
                ? regex
                : function (isStrict, localeData) {
                    return isStrict && strictRegex ? strictRegex : regex;
                };
        }

        function getParseRegexForToken(token, config) {
            if (!hasOwnProp(regexes, token)) {
                return new RegExp(unescapeFormat(token));
            }

            return regexes[token](config._strict, config._locale);
        }

        // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
        function unescapeFormat(s) {
            return regexEscape(
                s
                    .replace('\\', '')
                    .replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (
                        matched,
                        p1,
                        p2,
                        p3,
                        p4
                    ) {
                        return p1 || p2 || p3 || p4;
                    })
            );
        }

        function regexEscape(s) {
            return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
        }

        var tokens = {};

        function addParseToken(token, callback) {
            var i,
                func = callback;
            if (typeof token === 'string') {
                token = [token];
            }
            if (isNumber(callback)) {
                func = function (input, array) {
                    array[callback] = toInt(input);
                };
            }
            for (i = 0; i < token.length; i++) {
                tokens[token[i]] = func;
            }
        }

        function addWeekParseToken(token, callback) {
            addParseToken(token, function (input, array, config, token) {
                config._w = config._w || {};
                callback(input, config._w, config, token);
            });
        }

        function addTimeToArrayFromToken(token, input, config) {
            if (input != null && hasOwnProp(tokens, token)) {
                tokens[token](input, config._a, config, token);
            }
        }

        var YEAR = 0,
            MONTH = 1,
            DATE = 2,
            HOUR = 3,
            MINUTE = 4,
            SECOND = 5,
            MILLISECOND = 6,
            WEEK = 7,
            WEEKDAY = 8;

        function mod(n, x) {
            return ((n % x) + x) % x;
        }

        var indexOf;

        if (Array.prototype.indexOf) {
            indexOf = Array.prototype.indexOf;
        } else {
            indexOf = function (o) {
                // I know
                var i;
                for (i = 0; i < this.length; ++i) {
                    if (this[i] === o) {
                        return i;
                    }
                }
                return -1;
            };
        }

        function daysInMonth(year, month) {
            if (isNaN(year) || isNaN(month)) {
                return NaN;
            }
            var modMonth = mod(month, 12);
            year += (month - modMonth) / 12;
            return modMonth === 1
                ? isLeapYear(year)
                    ? 29
                    : 28
                : 31 - ((modMonth % 7) % 2);
        }

        // FORMATTING

        addFormatToken('M', ['MM', 2], 'Mo', function () {
            return this.month() + 1;
        });

        addFormatToken('MMM', 0, 0, function (format) {
            return this.localeData().monthsShort(this, format);
        });

        addFormatToken('MMMM', 0, 0, function (format) {
            return this.localeData().months(this, format);
        });

        // ALIASES

        addUnitAlias('month', 'M');

        // PRIORITY

        addUnitPriority('month', 8);

        // PARSING

        addRegexToken('M', match1to2);
        addRegexToken('MM', match1to2, match2);
        addRegexToken('MMM', function (isStrict, locale) {
            return locale.monthsShortRegex(isStrict);
        });
        addRegexToken('MMMM', function (isStrict, locale) {
            return locale.monthsRegex(isStrict);
        });

        addParseToken(['M', 'MM'], function (input, array) {
            array[MONTH] = toInt(input) - 1;
        });

        addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
            var month = config._locale.monthsParse(input, token, config._strict);
            // if we didn't find a month name, mark the date as invalid.
            if (month != null) {
                array[MONTH] = month;
            } else {
                getParsingFlags(config).invalidMonth = input;
            }
        });

        // LOCALES

        var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
                '_'
            ),
            defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split(
                '_'
            ),
            MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
            defaultMonthsShortRegex = matchWord,
            defaultMonthsRegex = matchWord;

        function localeMonths(m, format) {
            if (!m) {
                return isArray(this._months)
                    ? this._months
                    : this._months['standalone'];
            }
            return isArray(this._months)
                ? this._months[m.month()]
                : this._months[
                    (this._months.isFormat || MONTHS_IN_FORMAT).test(format)
                        ? 'format'
                        : 'standalone'
                    ][m.month()];
        }

        function localeMonthsShort(m, format) {
            if (!m) {
                return isArray(this._monthsShort)
                    ? this._monthsShort
                    : this._monthsShort['standalone'];
            }
            return isArray(this._monthsShort)
                ? this._monthsShort[m.month()]
                : this._monthsShort[
                    MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'
                    ][m.month()];
        }

        function handleStrictParse(monthName, format, strict) {
            var i,
                ii,
                mom,
                llc = monthName.toLocaleLowerCase();
            if (!this._monthsParse) {
                // this is not used
                this._monthsParse = [];
                this._longMonthsParse = [];
                this._shortMonthsParse = [];
                for (i = 0; i < 12; ++i) {
                    mom = createUTC([2000, i]);
                    this._shortMonthsParse[i] = this.monthsShort(
                        mom,
                        ''
                    ).toLocaleLowerCase();
                    this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
                }
            }

            if (strict) {
                if (format === 'MMM') {
                    ii = indexOf.call(this._shortMonthsParse, llc);
                    return ii !== -1 ? ii : null;
                } else {
                    ii = indexOf.call(this._longMonthsParse, llc);
                    return ii !== -1 ? ii : null;
                }
            } else {
                if (format === 'MMM') {
                    ii = indexOf.call(this._shortMonthsParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._longMonthsParse, llc);
                    return ii !== -1 ? ii : null;
                } else {
                    ii = indexOf.call(this._longMonthsParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._shortMonthsParse, llc);
                    return ii !== -1 ? ii : null;
                }
            }
        }

        function localeMonthsParse(monthName, format, strict) {
            var i, mom, regex;

            if (this._monthsParseExact) {
                return handleStrictParse.call(this, monthName, format, strict);
            }

            if (!this._monthsParse) {
                this._monthsParse = [];
                this._longMonthsParse = [];
                this._shortMonthsParse = [];
            }

            // TODO: add sorting
            // Sorting makes sure if one month (or abbr) is a prefix of another
            // see sorting in computeMonthsParse
            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                mom = createUTC([2000, i]);
                if (strict && !this._longMonthsParse[i]) {
                    this._longMonthsParse[i] = new RegExp(
                        '^' + this.months(mom, '').replace('.', '') + '$',
                        'i'
                    );
                    this._shortMonthsParse[i] = new RegExp(
                        '^' + this.monthsShort(mom, '').replace('.', '') + '$',
                        'i'
                    );
                }
                if (!strict && !this._monthsParse[i]) {
                    regex =
                        '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (
                    strict &&
                    format === 'MMMM' &&
                    this._longMonthsParse[i].test(monthName)
                ) {
                    return i;
                } else if (
                    strict &&
                    format === 'MMM' &&
                    this._shortMonthsParse[i].test(monthName)
                ) {
                    return i;
                } else if (!strict && this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        }

        // MOMENTS

        function setMonth(mom, value) {
            var dayOfMonth;

            if (!mom.isValid()) {
                // No op
                return mom;
            }

            if (typeof value === 'string') {
                if (/^\d+$/.test(value)) {
                    value = toInt(value);
                } else {
                    value = mom.localeData().monthsParse(value);
                    // TODO: Another silent failure?
                    if (!isNumber(value)) {
                        return mom;
                    }
                }
            }

            dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
            return mom;
        }

        function getSetMonth(value) {
            if (value != null) {
                setMonth(this, value);
                hooks.updateOffset(this, true);
                return this;
            } else {
                return get(this, 'Month');
            }
        }

        function getDaysInMonth() {
            return daysInMonth(this.year(), this.month());
        }

        function monthsShortRegex(isStrict) {
            if (this._monthsParseExact) {
                if (!hasOwnProp(this, '_monthsRegex')) {
                    computeMonthsParse.call(this);
                }
                if (isStrict) {
                    return this._monthsShortStrictRegex;
                } else {
                    return this._monthsShortRegex;
                }
            } else {
                if (!hasOwnProp(this, '_monthsShortRegex')) {
                    this._monthsShortRegex = defaultMonthsShortRegex;
                }
                return this._monthsShortStrictRegex && isStrict
                    ? this._monthsShortStrictRegex
                    : this._monthsShortRegex;
            }
        }

        function monthsRegex(isStrict) {
            if (this._monthsParseExact) {
                if (!hasOwnProp(this, '_monthsRegex')) {
                    computeMonthsParse.call(this);
                }
                if (isStrict) {
                    return this._monthsStrictRegex;
                } else {
                    return this._monthsRegex;
                }
            } else {
                if (!hasOwnProp(this, '_monthsRegex')) {
                    this._monthsRegex = defaultMonthsRegex;
                }
                return this._monthsStrictRegex && isStrict
                    ? this._monthsStrictRegex
                    : this._monthsRegex;
            }
        }

        function computeMonthsParse() {
            function cmpLenRev(a, b) {
                return b.length - a.length;
            }

            var shortPieces = [],
                longPieces = [],
                mixedPieces = [],
                i,
                mom;
            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                mom = createUTC([2000, i]);
                shortPieces.push(this.monthsShort(mom, ''));
                longPieces.push(this.months(mom, ''));
                mixedPieces.push(this.months(mom, ''));
                mixedPieces.push(this.monthsShort(mom, ''));
            }
            // Sorting makes sure if one month (or abbr) is a prefix of another it
            // will match the longer piece.
            shortPieces.sort(cmpLenRev);
            longPieces.sort(cmpLenRev);
            mixedPieces.sort(cmpLenRev);
            for (i = 0; i < 12; i++) {
                shortPieces[i] = regexEscape(shortPieces[i]);
                longPieces[i] = regexEscape(longPieces[i]);
            }
            for (i = 0; i < 24; i++) {
                mixedPieces[i] = regexEscape(mixedPieces[i]);
            }

            this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
            this._monthsShortRegex = this._monthsRegex;
            this._monthsStrictRegex = new RegExp(
                '^(' + longPieces.join('|') + ')',
                'i'
            );
            this._monthsShortStrictRegex = new RegExp(
                '^(' + shortPieces.join('|') + ')',
                'i'
            );
        }

        // FORMATTING

        addFormatToken('Y', 0, 0, function () {
            var y = this.year();
            return y <= 9999 ? zeroFill(y, 4) : '+' + y;
        });

        addFormatToken(0, ['YY', 2], 0, function () {
            return this.year() % 100;
        });

        addFormatToken(0, ['YYYY', 4], 0, 'year');
        addFormatToken(0, ['YYYYY', 5], 0, 'year');
        addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

        // ALIASES

        addUnitAlias('year', 'y');

        // PRIORITIES

        addUnitPriority('year', 1);

        // PARSING

        addRegexToken('Y', matchSigned);
        addRegexToken('YY', match1to2, match2);
        addRegexToken('YYYY', match1to4, match4);
        addRegexToken('YYYYY', match1to6, match6);
        addRegexToken('YYYYYY', match1to6, match6);

        addParseToken(['YYYYY', 'YYYYYY'], YEAR);
        addParseToken('YYYY', function (input, array) {
            array[YEAR] =
                input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
        });
        addParseToken('YY', function (input, array) {
            array[YEAR] = hooks.parseTwoDigitYear(input);
        });
        addParseToken('Y', function (input, array) {
            array[YEAR] = parseInt(input, 10);
        });

        // HELPERS

        function daysInYear(year) {
            return isLeapYear(year) ? 366 : 365;
        }

        // HOOKS

        hooks.parseTwoDigitYear = function (input) {
            return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
        };

        // MOMENTS

        var getSetYear = makeGetSet('FullYear', true);

        function getIsLeapYear() {
            return isLeapYear(this.year());
        }

        function createDate(y, m, d, h, M, s, ms) {
            // can't just apply() to create a date:
            // https://stackoverflow.com/q/181348
            var date;
            // the date constructor remaps years 0-99 to 1900-1999
            if (y < 100 && y >= 0) {
                // preserve leap years using a full 400 year cycle, then reset
                date = new Date(y + 400, m, d, h, M, s, ms);
                if (isFinite(date.getFullYear())) {
                    date.setFullYear(y);
                }
            } else {
                date = new Date(y, m, d, h, M, s, ms);
            }

            return date;
        }

        function createUTCDate(y) {
            var date, args;
            // the Date.UTC function remaps years 0-99 to 1900-1999
            if (y < 100 && y >= 0) {
                args = Array.prototype.slice.call(arguments);
                // preserve leap years using a full 400 year cycle, then reset
                args[0] = y + 400;
                date = new Date(Date.UTC.apply(null, args));
                if (isFinite(date.getUTCFullYear())) {
                    date.setUTCFullYear(y);
                }
            } else {
                date = new Date(Date.UTC.apply(null, arguments));
            }

            return date;
        }

        // start-of-first-week - start-of-year
        function firstWeekOffset(year, dow, doy) {
            var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
                fwd = 7 + dow - doy,
                // first-week day local weekday -- which local weekday is fwd
                fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

            return -fwdlw + fwd - 1;
        }

        // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
        function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
            var localWeekday = (7 + weekday - dow) % 7,
                weekOffset = firstWeekOffset(year, dow, doy),
                dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
                resYear,
                resDayOfYear;

            if (dayOfYear <= 0) {
                resYear = year - 1;
                resDayOfYear = daysInYear(resYear) + dayOfYear;
            } else if (dayOfYear > daysInYear(year)) {
                resYear = year + 1;
                resDayOfYear = dayOfYear - daysInYear(year);
            } else {
                resYear = year;
                resDayOfYear = dayOfYear;
            }

            return {
                year: resYear,
                dayOfYear: resDayOfYear,
            };
        }

        function weekOfYear(mom, dow, doy) {
            var weekOffset = firstWeekOffset(mom.year(), dow, doy),
                week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
                resWeek,
                resYear;

            if (week < 1) {
                resYear = mom.year() - 1;
                resWeek = week + weeksInYear(resYear, dow, doy);
            } else if (week > weeksInYear(mom.year(), dow, doy)) {
                resWeek = week - weeksInYear(mom.year(), dow, doy);
                resYear = mom.year() + 1;
            } else {
                resYear = mom.year();
                resWeek = week;
            }

            return {
                week: resWeek,
                year: resYear,
            };
        }

        function weeksInYear(year, dow, doy) {
            var weekOffset = firstWeekOffset(year, dow, doy),
                weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
            return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
        }

        // FORMATTING

        addFormatToken('w', ['ww', 2], 'wo', 'week');
        addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

        // ALIASES

        addUnitAlias('week', 'w');
        addUnitAlias('isoWeek', 'W');

        // PRIORITIES

        addUnitPriority('week', 5);
        addUnitPriority('isoWeek', 5);

        // PARSING

        addRegexToken('w', match1to2);
        addRegexToken('ww', match1to2, match2);
        addRegexToken('W', match1to2);
        addRegexToken('WW', match1to2, match2);

        addWeekParseToken(['w', 'ww', 'W', 'WW'], function (
            input,
            week,
            config,
            token
        ) {
            week[token.substr(0, 1)] = toInt(input);
        });

        // HELPERS

        // LOCALES

        function localeWeek(mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        }

        var defaultLocaleWeek = {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 6th is the first week of the year.
        };

        function localeFirstDayOfWeek() {
            return this._week.dow;
        }

        function localeFirstDayOfYear() {
            return this._week.doy;
        }

        // MOMENTS

        function getSetWeek(input) {
            var week = this.localeData().week(this);
            return input == null ? week : this.add((input - week) * 7, 'd');
        }

        function getSetISOWeek(input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add((input - week) * 7, 'd');
        }

        // FORMATTING

        addFormatToken('d', 0, 'do', 'day');

        addFormatToken('dd', 0, 0, function (format) {
            return this.localeData().weekdaysMin(this, format);
        });

        addFormatToken('ddd', 0, 0, function (format) {
            return this.localeData().weekdaysShort(this, format);
        });

        addFormatToken('dddd', 0, 0, function (format) {
            return this.localeData().weekdays(this, format);
        });

        addFormatToken('e', 0, 0, 'weekday');
        addFormatToken('E', 0, 0, 'isoWeekday');

        // ALIASES

        addUnitAlias('day', 'd');
        addUnitAlias('weekday', 'e');
        addUnitAlias('isoWeekday', 'E');

        // PRIORITY
        addUnitPriority('day', 11);
        addUnitPriority('weekday', 11);
        addUnitPriority('isoWeekday', 11);

        // PARSING

        addRegexToken('d', match1to2);
        addRegexToken('e', match1to2);
        addRegexToken('E', match1to2);
        addRegexToken('dd', function (isStrict, locale) {
            return locale.weekdaysMinRegex(isStrict);
        });
        addRegexToken('ddd', function (isStrict, locale) {
            return locale.weekdaysShortRegex(isStrict);
        });
        addRegexToken('dddd', function (isStrict, locale) {
            return locale.weekdaysRegex(isStrict);
        });

        addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
            var weekday = config._locale.weekdaysParse(input, token, config._strict);
            // if we didn't get a weekday name, mark the date as invalid
            if (weekday != null) {
                week.d = weekday;
            } else {
                getParsingFlags(config).invalidWeekday = input;
            }
        });

        addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
            week[token] = toInt(input);
        });

        // HELPERS

        function parseWeekday(input, locale) {
            if (typeof input !== 'string') {
                return input;
            }

            if (!isNaN(input)) {
                return parseInt(input, 10);
            }

            input = locale.weekdaysParse(input);
            if (typeof input === 'number') {
                return input;
            }

            return null;
        }

        function parseIsoWeekday(input, locale) {
            if (typeof input === 'string') {
                return locale.weekdaysParse(input) % 7 || 7;
            }
            return isNaN(input) ? null : input;
        }

        // LOCALES
        function shiftWeekdays(ws, n) {
            return ws.slice(n, 7).concat(ws.slice(0, n));
        }

        var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
                '_'
            ),
            defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
            defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
            defaultWeekdaysRegex = matchWord,
            defaultWeekdaysShortRegex = matchWord,
            defaultWeekdaysMinRegex = matchWord;

        function localeWeekdays(m, format) {
            var weekdays = isArray(this._weekdays)
                ? this._weekdays
                : this._weekdays[
                    m && m !== true && this._weekdays.isFormat.test(format)
                        ? 'format'
                        : 'standalone'
                    ];
            return m === true
                ? shiftWeekdays(weekdays, this._week.dow)
                : m
                    ? weekdays[m.day()]
                    : weekdays;
        }

        function localeWeekdaysShort(m) {
            return m === true
                ? shiftWeekdays(this._weekdaysShort, this._week.dow)
                : m
                    ? this._weekdaysShort[m.day()]
                    : this._weekdaysShort;
        }

        function localeWeekdaysMin(m) {
            return m === true
                ? shiftWeekdays(this._weekdaysMin, this._week.dow)
                : m
                    ? this._weekdaysMin[m.day()]
                    : this._weekdaysMin;
        }

        function handleStrictParse$1(weekdayName, format, strict) {
            var i,
                ii,
                mom,
                llc = weekdayName.toLocaleLowerCase();
            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
                this._shortWeekdaysParse = [];
                this._minWeekdaysParse = [];

                for (i = 0; i < 7; ++i) {
                    mom = createUTC([2000, 1]).day(i);
                    this._minWeekdaysParse[i] = this.weekdaysMin(
                        mom,
                        ''
                    ).toLocaleLowerCase();
                    this._shortWeekdaysParse[i] = this.weekdaysShort(
                        mom,
                        ''
                    ).toLocaleLowerCase();
                    this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
                }
            }

            if (strict) {
                if (format === 'dddd') {
                    ii = indexOf.call(this._weekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                } else if (format === 'ddd') {
                    ii = indexOf.call(this._shortWeekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                } else {
                    ii = indexOf.call(this._minWeekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                }
            } else {
                if (format === 'dddd') {
                    ii = indexOf.call(this._weekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._shortWeekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._minWeekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                } else if (format === 'ddd') {
                    ii = indexOf.call(this._shortWeekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._weekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._minWeekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                } else {
                    ii = indexOf.call(this._minWeekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._weekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._shortWeekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                }
            }
        }

        function localeWeekdaysParse(weekdayName, format, strict) {
            var i, mom, regex;

            if (this._weekdaysParseExact) {
                return handleStrictParse$1.call(this, weekdayName, format, strict);
            }

            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
                this._minWeekdaysParse = [];
                this._shortWeekdaysParse = [];
                this._fullWeekdaysParse = [];
            }

            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already

                mom = createUTC([2000, 1]).day(i);
                if (strict && !this._fullWeekdaysParse[i]) {
                    this._fullWeekdaysParse[i] = new RegExp(
                        '^' + this.weekdays(mom, '').replace('.', '\\.?') + '$',
                        'i'
                    );
                    this._shortWeekdaysParse[i] = new RegExp(
                        '^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$',
                        'i'
                    );
                    this._minWeekdaysParse[i] = new RegExp(
                        '^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$',
                        'i'
                    );
                }
                if (!this._weekdaysParse[i]) {
                    regex =
                        '^' +
                        this.weekdays(mom, '') +
                        '|^' +
                        this.weekdaysShort(mom, '') +
                        '|^' +
                        this.weekdaysMin(mom, '');
                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (
                    strict &&
                    format === 'dddd' &&
                    this._fullWeekdaysParse[i].test(weekdayName)
                ) {
                    return i;
                } else if (
                    strict &&
                    format === 'ddd' &&
                    this._shortWeekdaysParse[i].test(weekdayName)
                ) {
                    return i;
                } else if (
                    strict &&
                    format === 'dd' &&
                    this._minWeekdaysParse[i].test(weekdayName)
                ) {
                    return i;
                } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        }

        // MOMENTS

        function getSetDayOfWeek(input) {
            if (!this.isValid()) {
                return input != null ? this : NaN;
            }
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.localeData());
                return this.add(input - day, 'd');
            } else {
                return day;
            }
        }

        function getSetLocaleDayOfWeek(input) {
            if (!this.isValid()) {
                return input != null ? this : NaN;
            }
            var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
            return input == null ? weekday : this.add(input - weekday, 'd');
        }

        function getSetISODayOfWeek(input) {
            if (!this.isValid()) {
                return input != null ? this : NaN;
            }

            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.

            if (input != null) {
                var weekday = parseIsoWeekday(input, this.localeData());
                return this.day(this.day() % 7 ? weekday : weekday - 7);
            } else {
                return this.day() || 7;
            }
        }

        function weekdaysRegex(isStrict) {
            if (this._weekdaysParseExact) {
                if (!hasOwnProp(this, '_weekdaysRegex')) {
                    computeWeekdaysParse.call(this);
                }
                if (isStrict) {
                    return this._weekdaysStrictRegex;
                } else {
                    return this._weekdaysRegex;
                }
            } else {
                if (!hasOwnProp(this, '_weekdaysRegex')) {
                    this._weekdaysRegex = defaultWeekdaysRegex;
                }
                return this._weekdaysStrictRegex && isStrict
                    ? this._weekdaysStrictRegex
                    : this._weekdaysRegex;
            }
        }

        function weekdaysShortRegex(isStrict) {
            if (this._weekdaysParseExact) {
                if (!hasOwnProp(this, '_weekdaysRegex')) {
                    computeWeekdaysParse.call(this);
                }
                if (isStrict) {
                    return this._weekdaysShortStrictRegex;
                } else {
                    return this._weekdaysShortRegex;
                }
            } else {
                if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                    this._weekdaysShortRegex = defaultWeekdaysShortRegex;
                }
                return this._weekdaysShortStrictRegex && isStrict
                    ? this._weekdaysShortStrictRegex
                    : this._weekdaysShortRegex;
            }
        }

        function weekdaysMinRegex(isStrict) {
            if (this._weekdaysParseExact) {
                if (!hasOwnProp(this, '_weekdaysRegex')) {
                    computeWeekdaysParse.call(this);
                }
                if (isStrict) {
                    return this._weekdaysMinStrictRegex;
                } else {
                    return this._weekdaysMinRegex;
                }
            } else {
                if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                    this._weekdaysMinRegex = defaultWeekdaysMinRegex;
                }
                return this._weekdaysMinStrictRegex && isStrict
                    ? this._weekdaysMinStrictRegex
                    : this._weekdaysMinRegex;
            }
        }

        function computeWeekdaysParse() {
            function cmpLenRev(a, b) {
                return b.length - a.length;
            }

            var minPieces = [],
                shortPieces = [],
                longPieces = [],
                mixedPieces = [],
                i,
                mom,
                minp,
                shortp,
                longp;
            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already
                mom = createUTC([2000, 1]).day(i);
                minp = regexEscape(this.weekdaysMin(mom, ''));
                shortp = regexEscape(this.weekdaysShort(mom, ''));
                longp = regexEscape(this.weekdays(mom, ''));
                minPieces.push(minp);
                shortPieces.push(shortp);
                longPieces.push(longp);
                mixedPieces.push(minp);
                mixedPieces.push(shortp);
                mixedPieces.push(longp);
            }
            // Sorting makes sure if one weekday (or abbr) is a prefix of another it
            // will match the longer piece.
            minPieces.sort(cmpLenRev);
            shortPieces.sort(cmpLenRev);
            longPieces.sort(cmpLenRev);
            mixedPieces.sort(cmpLenRev);

            this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
            this._weekdaysShortRegex = this._weekdaysRegex;
            this._weekdaysMinRegex = this._weekdaysRegex;

            this._weekdaysStrictRegex = new RegExp(
                '^(' + longPieces.join('|') + ')',
                'i'
            );
            this._weekdaysShortStrictRegex = new RegExp(
                '^(' + shortPieces.join('|') + ')',
                'i'
            );
            this._weekdaysMinStrictRegex = new RegExp(
                '^(' + minPieces.join('|') + ')',
                'i'
            );
        }

        // FORMATTING

        function hFormat() {
            return this.hours() % 12 || 12;
        }

        function kFormat() {
            return this.hours() || 24;
        }

        addFormatToken('H', ['HH', 2], 0, 'hour');
        addFormatToken('h', ['hh', 2], 0, hFormat);
        addFormatToken('k', ['kk', 2], 0, kFormat);

        addFormatToken('hmm', 0, 0, function () {
            return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
        });

        addFormatToken('hmmss', 0, 0, function () {
            return (
                '' +
                hFormat.apply(this) +
                zeroFill(this.minutes(), 2) +
                zeroFill(this.seconds(), 2)
            );
        });

        addFormatToken('Hmm', 0, 0, function () {
            return '' + this.hours() + zeroFill(this.minutes(), 2);
        });

        addFormatToken('Hmmss', 0, 0, function () {
            return (
                '' +
                this.hours() +
                zeroFill(this.minutes(), 2) +
                zeroFill(this.seconds(), 2)
            );
        });

        function meridiem(token, lowercase) {
            addFormatToken(token, 0, 0, function () {
                return this.localeData().meridiem(
                    this.hours(),
                    this.minutes(),
                    lowercase
                );
            });
        }

        meridiem('a', true);
        meridiem('A', false);

        // ALIASES

        addUnitAlias('hour', 'h');

        // PRIORITY
        addUnitPriority('hour', 13);

        // PARSING

        function matchMeridiem(isStrict, locale) {
            return locale._meridiemParse;
        }

        addRegexToken('a', matchMeridiem);
        addRegexToken('A', matchMeridiem);
        addRegexToken('H', match1to2);
        addRegexToken('h', match1to2);
        addRegexToken('k', match1to2);
        addRegexToken('HH', match1to2, match2);
        addRegexToken('hh', match1to2, match2);
        addRegexToken('kk', match1to2, match2);

        addRegexToken('hmm', match3to4);
        addRegexToken('hmmss', match5to6);
        addRegexToken('Hmm', match3to4);
        addRegexToken('Hmmss', match5to6);

        addParseToken(['H', 'HH'], HOUR);
        addParseToken(['k', 'kk'], function (input, array, config) {
            var kInput = toInt(input);
            array[HOUR] = kInput === 24 ? 0 : kInput;
        });
        addParseToken(['a', 'A'], function (input, array, config) {
            config._isPm = config._locale.isPM(input);
            config._meridiem = input;
        });
        addParseToken(['h', 'hh'], function (input, array, config) {
            array[HOUR] = toInt(input);
            getParsingFlags(config).bigHour = true;
        });
        addParseToken('hmm', function (input, array, config) {
            var pos = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos));
            array[MINUTE] = toInt(input.substr(pos));
            getParsingFlags(config).bigHour = true;
        });
        addParseToken('hmmss', function (input, array, config) {
            var pos1 = input.length - 4,
                pos2 = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos1));
            array[MINUTE] = toInt(input.substr(pos1, 2));
            array[SECOND] = toInt(input.substr(pos2));
            getParsingFlags(config).bigHour = true;
        });
        addParseToken('Hmm', function (input, array, config) {
            var pos = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos));
            array[MINUTE] = toInt(input.substr(pos));
        });
        addParseToken('Hmmss', function (input, array, config) {
            var pos1 = input.length - 4,
                pos2 = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos1));
            array[MINUTE] = toInt(input.substr(pos1, 2));
            array[SECOND] = toInt(input.substr(pos2));
        });

        // LOCALES

        function localeIsPM(input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return (input + '').toLowerCase().charAt(0) === 'p';
        }

        var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
            // Setting the hour should keep the time, because the user explicitly
            // specified which hour they want. So trying to maintain the same hour (in
            // a new timezone) makes sense. Adding/subtracting hours does not follow
            // this rule.
            getSetHour = makeGetSet('Hours', true);

        function localeMeridiem(hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        }

        var baseConfig = {
            calendar: defaultCalendar,
            longDateFormat: defaultLongDateFormat,
            invalidDate: defaultInvalidDate,
            ordinal: defaultOrdinal,
            dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
            relativeTime: defaultRelativeTime,

            months: defaultLocaleMonths,
            monthsShort: defaultLocaleMonthsShort,

            week: defaultLocaleWeek,

            weekdays: defaultLocaleWeekdays,
            weekdaysMin: defaultLocaleWeekdaysMin,
            weekdaysShort: defaultLocaleWeekdaysShort,

            meridiemParse: defaultLocaleMeridiemParse,
        };

        // internal storage for locale config files
        var locales = {},
            localeFamilies = {},
            globalLocale;

        function commonPrefix(arr1, arr2) {
            var i,
                minl = Math.min(arr1.length, arr2.length);
            for (i = 0; i < minl; i += 1) {
                if (arr1[i] !== arr2[i]) {
                    return i;
                }
            }
            return minl;
        }

        function normalizeLocale(key) {
            return key ? key.toLowerCase().replace('_', '-') : key;
        }

        // pick the locale from the array
        // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
        // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
        function chooseLocale(names) {
            var i = 0,
                j,
                next,
                locale,
                split;

            while (i < names.length) {
                split = normalizeLocale(names[i]).split('-');
                j = split.length;
                next = normalizeLocale(names[i + 1]);
                next = next ? next.split('-') : null;
                while (j > 0) {
                    locale = loadLocale(split.slice(0, j).join('-'));
                    if (locale) {
                        return locale;
                    }
                    if (
                        next &&
                        next.length >= j &&
                        commonPrefix(split, next) >= j - 1
                    ) {
                        //the next array item is better than a shallower substring of this one
                        break;
                    }
                    j--;
                }
                i++;
            }
            return globalLocale;
        }

        function loadLocale(name) {
            var oldLocale = null,
                aliasedRequire;
            // TODO: Find a better way to register and load all the locales in Node
            if (
                locales[name] === undefined &&
                'object' !== 'undefined' &&
                module &&
                module.exports
            ) {
                try {
                    oldLocale = globalLocale._abbr;
                    aliasedRequire = commonjsRequire;
                    aliasedRequire('./locale/' + name);
                    getSetGlobalLocale(oldLocale);
                } catch (e) {
                    // mark as not found to avoid repeating expensive file require call causing high CPU
                    // when trying to find en-US, en_US, en-us for every format call
                    locales[name] = null; // null means not found
                }
            }
            return locales[name];
        }

        // This function will load locale and then set the global locale.  If
        // no arguments are passed in, it will simply return the current global
        // locale key.
        function getSetGlobalLocale(key, values) {
            var data;
            if (key) {
                if (isUndefined(values)) {
                    data = getLocale(key);
                } else {
                    data = defineLocale(key, values);
                }

                if (data) {
                    // moment.duration._locale = moment._locale = data;
                    globalLocale = data;
                } else {
                    if (typeof console !== 'undefined' && console.warn) {
                        //warn user if arguments are passed but the locale could not be set
                        console.warn(
                            'Locale ' + key + ' not found. Did you forget to load it?'
                        );
                    }
                }
            }

            return globalLocale._abbr;
        }

        function defineLocale(name, config) {
            if (config !== null) {
                var locale,
                    parentConfig = baseConfig;
                config.abbr = name;
                if (locales[name] != null) {
                    deprecateSimple(
                        'defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'
                    );
                    parentConfig = locales[name]._config;
                } else if (config.parentLocale != null) {
                    if (locales[config.parentLocale] != null) {
                        parentConfig = locales[config.parentLocale]._config;
                    } else {
                        locale = loadLocale(config.parentLocale);
                        if (locale != null) {
                            parentConfig = locale._config;
                        } else {
                            if (!localeFamilies[config.parentLocale]) {
                                localeFamilies[config.parentLocale] = [];
                            }
                            localeFamilies[config.parentLocale].push({
                                name: name,
                                config: config,
                            });
                            return null;
                        }
                    }
                }
                locales[name] = new Locale(mergeConfigs(parentConfig, config));

                if (localeFamilies[name]) {
                    localeFamilies[name].forEach(function (x) {
                        defineLocale(x.name, x.config);
                    });
                }

                // backwards compat for now: also set the locale
                // make sure we set the locale AFTER all child locales have been
                // created, so we won't end up with the child locale set.
                getSetGlobalLocale(name);

                return locales[name];
            } else {
                // useful for testing
                delete locales[name];
                return null;
            }
        }

        function updateLocale(name, config) {
            if (config != null) {
                var locale,
                    tmpLocale,
                    parentConfig = baseConfig;

                if (locales[name] != null && locales[name].parentLocale != null) {
                    // Update existing child locale in-place to avoid memory-leaks
                    locales[name].set(mergeConfigs(locales[name]._config, config));
                } else {
                    // MERGE
                    tmpLocale = loadLocale(name);
                    if (tmpLocale != null) {
                        parentConfig = tmpLocale._config;
                    }
                    config = mergeConfigs(parentConfig, config);
                    if (tmpLocale == null) {
                        // updateLocale is called for creating a new locale
                        // Set abbr so it will have a name (getters return
                        // undefined otherwise).
                        config.abbr = name;
                    }
                    locale = new Locale(config);
                    locale.parentLocale = locales[name];
                    locales[name] = locale;
                }

                // backwards compat for now: also set the locale
                getSetGlobalLocale(name);
            } else {
                // pass null for config to unupdate, useful for tests
                if (locales[name] != null) {
                    if (locales[name].parentLocale != null) {
                        locales[name] = locales[name].parentLocale;
                        if (name === getSetGlobalLocale()) {
                            getSetGlobalLocale(name);
                        }
                    } else if (locales[name] != null) {
                        delete locales[name];
                    }
                }
            }
            return locales[name];
        }

        // returns locale data
        function getLocale(key) {
            var locale;

            if (key && key._locale && key._locale._abbr) {
                key = key._locale._abbr;
            }

            if (!key) {
                return globalLocale;
            }

            if (!isArray(key)) {
                //short-circuit everything else
                locale = loadLocale(key);
                if (locale) {
                    return locale;
                }
                key = [key];
            }

            return chooseLocale(key);
        }

        function listLocales() {
            return keys(locales);
        }

        function checkOverflow(m) {
            var overflow,
                a = m._a;

            if (a && getParsingFlags(m).overflow === -2) {
                overflow =
                    a[MONTH] < 0 || a[MONTH] > 11
                        ? MONTH
                        : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])
                            ? DATE
                            : a[HOUR] < 0 ||
                            a[HOUR] > 24 ||
                            (a[HOUR] === 24 &&
                                (a[MINUTE] !== 0 ||
                                    a[SECOND] !== 0 ||
                                    a[MILLISECOND] !== 0))
                                ? HOUR
                                : a[MINUTE] < 0 || a[MINUTE] > 59
                                    ? MINUTE
                                    : a[SECOND] < 0 || a[SECOND] > 59
                                        ? SECOND
                                        : a[MILLISECOND] < 0 || a[MILLISECOND] > 999
                                            ? MILLISECOND
                                            : -1;

                if (
                    getParsingFlags(m)._overflowDayOfYear &&
                    (overflow < YEAR || overflow > DATE)
                ) {
                    overflow = DATE;
                }
                if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                    overflow = WEEK;
                }
                if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                    overflow = WEEKDAY;
                }

                getParsingFlags(m).overflow = overflow;
            }

            return m;
        }

        // iso 8601 regex
        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
        var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
            basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
            tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
            isoDates = [
                ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
                ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
                ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
                ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
                ['YYYY-DDD', /\d{4}-\d{3}/],
                ['YYYY-MM', /\d{4}-\d\d/, false],
                ['YYYYYYMMDD', /[+-]\d{10}/],
                ['YYYYMMDD', /\d{8}/],
                ['GGGG[W]WWE', /\d{4}W\d{3}/],
                ['GGGG[W]WW', /\d{4}W\d{2}/, false],
                ['YYYYDDD', /\d{7}/],
                ['YYYYMM', /\d{6}/, false],
                ['YYYY', /\d{4}/, false],
            ],
            // iso time formats and regexes
            isoTimes = [
                ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
                ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
                ['HH:mm:ss', /\d\d:\d\d:\d\d/],
                ['HH:mm', /\d\d:\d\d/],
                ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
                ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
                ['HHmmss', /\d\d\d\d\d\d/],
                ['HHmm', /\d\d\d\d/],
                ['HH', /\d\d/],
            ],
            aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
            // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
            rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
            obsOffsets = {
                UT: 0,
                GMT: 0,
                EDT: -4 * 60,
                EST: -5 * 60,
                CDT: -5 * 60,
                CST: -6 * 60,
                MDT: -6 * 60,
                MST: -7 * 60,
                PDT: -7 * 60,
                PST: -8 * 60,
            };

        // date from iso format
        function configFromISO(config) {
            var i,
                l,
                string = config._i,
                match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
                allowTime,
                dateFormat,
                timeFormat,
                tzFormat;

            if (match) {
                getParsingFlags(config).iso = true;

                for (i = 0, l = isoDates.length; i < l; i++) {
                    if (isoDates[i][1].exec(match[1])) {
                        dateFormat = isoDates[i][0];
                        allowTime = isoDates[i][2] !== false;
                        break;
                    }
                }
                if (dateFormat == null) {
                    config._isValid = false;
                    return;
                }
                if (match[3]) {
                    for (i = 0, l = isoTimes.length; i < l; i++) {
                        if (isoTimes[i][1].exec(match[3])) {
                            // match[2] should be 'T' or space
                            timeFormat = (match[2] || ' ') + isoTimes[i][0];
                            break;
                        }
                    }
                    if (timeFormat == null) {
                        config._isValid = false;
                        return;
                    }
                }
                if (!allowTime && timeFormat != null) {
                    config._isValid = false;
                    return;
                }
                if (match[4]) {
                    if (tzRegex.exec(match[4])) {
                        tzFormat = 'Z';
                    } else {
                        config._isValid = false;
                        return;
                    }
                }
                config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
                configFromStringAndFormat(config);
            } else {
                config._isValid = false;
            }
        }

        function extractFromRFC2822Strings(
            yearStr,
            monthStr,
            dayStr,
            hourStr,
            minuteStr,
            secondStr
        ) {
            var result = [
                untruncateYear(yearStr),
                defaultLocaleMonthsShort.indexOf(monthStr),
                parseInt(dayStr, 10),
                parseInt(hourStr, 10),
                parseInt(minuteStr, 10),
            ];

            if (secondStr) {
                result.push(parseInt(secondStr, 10));
            }

            return result;
        }

        function untruncateYear(yearStr) {
            var year = parseInt(yearStr, 10);
            if (year <= 49) {
                return 2000 + year;
            } else if (year <= 999) {
                return 1900 + year;
            }
            return year;
        }

        function preprocessRFC2822(s) {
            // Remove comments and folding whitespace and replace multiple-spaces with a single space
            return s
                .replace(/\([^)]*\)|[\n\t]/g, ' ')
                .replace(/(\s\s+)/g, ' ')
                .replace(/^\s\s*/, '')
                .replace(/\s\s*$/, '');
        }

        function checkWeekday(weekdayStr, parsedInput, config) {
            if (weekdayStr) {
                // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
                var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                    weekdayActual = new Date(
                        parsedInput[0],
                        parsedInput[1],
                        parsedInput[2]
                    ).getDay();
                if (weekdayProvided !== weekdayActual) {
                    getParsingFlags(config).weekdayMismatch = true;
                    config._isValid = false;
                    return false;
                }
            }
            return true;
        }

        function calculateOffset(obsOffset, militaryOffset, numOffset) {
            if (obsOffset) {
                return obsOffsets[obsOffset];
            } else if (militaryOffset) {
                // the only allowed military tz is Z
                return 0;
            } else {
                var hm = parseInt(numOffset, 10),
                    m = hm % 100,
                    h = (hm - m) / 100;
                return h * 60 + m;
            }
        }

        // date and time from ref 2822 format
        function configFromRFC2822(config) {
            var match = rfc2822.exec(preprocessRFC2822(config._i)),
                parsedArray;
            if (match) {
                parsedArray = extractFromRFC2822Strings(
                    match[4],
                    match[3],
                    match[2],
                    match[5],
                    match[6],
                    match[7]
                );
                if (!checkWeekday(match[1], parsedArray, config)) {
                    return;
                }

                config._a = parsedArray;
                config._tzm = calculateOffset(match[8], match[9], match[10]);

                config._d = createUTCDate.apply(null, config._a);
                config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

                getParsingFlags(config).rfc2822 = true;
            } else {
                config._isValid = false;
            }
        }

        // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
        function configFromString(config) {
            var matched = aspNetJsonRegex.exec(config._i);
            if (matched !== null) {
                config._d = new Date(+matched[1]);
                return;
            }

            configFromISO(config);
            if (config._isValid === false) {
                delete config._isValid;
            } else {
                return;
            }

            configFromRFC2822(config);
            if (config._isValid === false) {
                delete config._isValid;
            } else {
                return;
            }

            if (config._strict) {
                config._isValid = false;
            } else {
                // Final attempt, use Input Fallback
                hooks.createFromInputFallback(config);
            }
        }

        hooks.createFromInputFallback = deprecate(
            'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
            'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
            'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',
            function (config) {
                config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
            }
        );

        // Pick the first defined of two or three arguments.
        function defaults(a, b, c) {
            if (a != null) {
                return a;
            }
            if (b != null) {
                return b;
            }
            return c;
        }

        function currentDateArray(config) {
            // hooks is actually the exported moment object
            var nowValue = new Date(hooks.now());
            if (config._useUTC) {
                return [
                    nowValue.getUTCFullYear(),
                    nowValue.getUTCMonth(),
                    nowValue.getUTCDate(),
                ];
            }
            return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
        }

        // convert an array to a date.
        // the array should mirror the parameters below
        // note: all values past the year are optional and will default to the lowest possible value.
        // [year, month, day , hour, minute, second, millisecond]
        function configFromArray(config) {
            var i,
                date,
                input = [],
                currentDate,
                expectedWeekday,
                yearToUse;

            if (config._d) {
                return;
            }

            currentDate = currentDateArray(config);

            //compute day of the year from weeks and weekdays
            if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
                dayOfYearFromWeekInfo(config);
            }

            //if the day of the year is set, figure out what it is
            if (config._dayOfYear != null) {
                yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

                if (
                    config._dayOfYear > daysInYear(yearToUse) ||
                    config._dayOfYear === 0
                ) {
                    getParsingFlags(config)._overflowDayOfYear = true;
                }

                date = createUTCDate(yearToUse, 0, config._dayOfYear);
                config._a[MONTH] = date.getUTCMonth();
                config._a[DATE] = date.getUTCDate();
            }

            // Default to current date.
            // * if no year, month, day of month are given, default to today
            // * if day of month is given, default month and year
            // * if month is given, default only year
            // * if year is given, don't default anything
            for (i = 0; i < 3 && config._a[i] == null; ++i) {
                config._a[i] = input[i] = currentDate[i];
            }

            // Zero out whatever was not defaulted, including time
            for (; i < 7; i++) {
                config._a[i] = input[i] =
                    config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];
            }

            // Check for 24:00:00.000
            if (
                config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0
            ) {
                config._nextDay = true;
                config._a[HOUR] = 0;
            }

            config._d = (config._useUTC ? createUTCDate : createDate).apply(
                null,
                input
            );
            expectedWeekday = config._useUTC
                ? config._d.getUTCDay()
                : config._d.getDay();

            // Apply timezone offset from input. The actual utcOffset can be changed
            // with parseZone.
            if (config._tzm != null) {
                config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
            }

            if (config._nextDay) {
                config._a[HOUR] = 24;
            }

            // check for mismatching day of week
            if (
                config._w &&
                typeof config._w.d !== 'undefined' &&
                config._w.d !== expectedWeekday
            ) {
                getParsingFlags(config).weekdayMismatch = true;
            }
        }

        function dayOfYearFromWeekInfo(config) {
            var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;

            w = config._w;
            if (w.GG != null || w.W != null || w.E != null) {
                dow = 1;
                doy = 4;

                // TODO: We need to take the current isoWeekYear, but that depends on
                // how we interpret now (local, utc, fixed offset). So create
                // a now version of current config (take local/utc/offset flags, and
                // create now).
                weekYear = defaults(
                    w.GG,
                    config._a[YEAR],
                    weekOfYear(createLocal(), 1, 4).year
                );
                week = defaults(w.W, 1);
                weekday = defaults(w.E, 1);
                if (weekday < 1 || weekday > 7) {
                    weekdayOverflow = true;
                }
            } else {
                dow = config._locale._week.dow;
                doy = config._locale._week.doy;

                curWeek = weekOfYear(createLocal(), dow, doy);

                weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

                // Default to current week.
                week = defaults(w.w, curWeek.week);

                if (w.d != null) {
                    // weekday -- low day numbers are considered next week
                    weekday = w.d;
                    if (weekday < 0 || weekday > 6) {
                        weekdayOverflow = true;
                    }
                } else if (w.e != null) {
                    // local weekday -- counting starts from beginning of week
                    weekday = w.e + dow;
                    if (w.e < 0 || w.e > 6) {
                        weekdayOverflow = true;
                    }
                } else {
                    // default to beginning of week
                    weekday = dow;
                }
            }
            if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
                getParsingFlags(config)._overflowWeeks = true;
            } else if (weekdayOverflow != null) {
                getParsingFlags(config)._overflowWeekday = true;
            } else {
                temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
                config._a[YEAR] = temp.year;
                config._dayOfYear = temp.dayOfYear;
            }
        }

        // constant that refers to the ISO standard
        hooks.ISO_8601 = function () {};

        // constant that refers to the RFC 2822 form
        hooks.RFC_2822 = function () {};

        // date from string and format string
        function configFromStringAndFormat(config) {
            // TODO: Move this to another part of the creation flow to prevent circular deps
            if (config._f === hooks.ISO_8601) {
                configFromISO(config);
                return;
            }
            if (config._f === hooks.RFC_2822) {
                configFromRFC2822(config);
                return;
            }
            config._a = [];
            getParsingFlags(config).empty = true;

            // This array is used to make a Date, either with `new Date` or `Date.UTC`
            var string = '' + config._i,
                i,
                parsedInput,
                tokens,
                token,
                skipped,
                stringLength = string.length,
                totalParsedInputLength = 0,
                era;

            tokens =
                expandFormat(config._f, config._locale).match(formattingTokens) || [];

            for (i = 0; i < tokens.length; i++) {
                token = tokens[i];
                parsedInput = (string.match(getParseRegexForToken(token, config)) ||
                    [])[0];
                if (parsedInput) {
                    skipped = string.substr(0, string.indexOf(parsedInput));
                    if (skipped.length > 0) {
                        getParsingFlags(config).unusedInput.push(skipped);
                    }
                    string = string.slice(
                        string.indexOf(parsedInput) + parsedInput.length
                    );
                    totalParsedInputLength += parsedInput.length;
                }
                // don't parse if it's not a known token
                if (formatTokenFunctions[token]) {
                    if (parsedInput) {
                        getParsingFlags(config).empty = false;
                    } else {
                        getParsingFlags(config).unusedTokens.push(token);
                    }
                    addTimeToArrayFromToken(token, parsedInput, config);
                } else if (config._strict && !parsedInput) {
                    getParsingFlags(config).unusedTokens.push(token);
                }
            }

            // add remaining unparsed input length to the string
            getParsingFlags(config).charsLeftOver =
                stringLength - totalParsedInputLength;
            if (string.length > 0) {
                getParsingFlags(config).unusedInput.push(string);
            }

            // clear _12h flag if hour is <= 12
            if (
                config._a[HOUR] <= 12 &&
                getParsingFlags(config).bigHour === true &&
                config._a[HOUR] > 0
            ) {
                getParsingFlags(config).bigHour = undefined;
            }

            getParsingFlags(config).parsedDateParts = config._a.slice(0);
            getParsingFlags(config).meridiem = config._meridiem;
            // handle meridiem
            config._a[HOUR] = meridiemFixWrap(
                config._locale,
                config._a[HOUR],
                config._meridiem
            );

            // handle era
            era = getParsingFlags(config).era;
            if (era !== null) {
                config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
            }

            configFromArray(config);
            checkOverflow(config);
        }

        function meridiemFixWrap(locale, hour, meridiem) {
            var isPm;

            if (meridiem == null) {
                // nothing to do
                return hour;
            }
            if (locale.meridiemHour != null) {
                return locale.meridiemHour(hour, meridiem);
            } else if (locale.isPM != null) {
                // Fallback
                isPm = locale.isPM(meridiem);
                if (isPm && hour < 12) {
                    hour += 12;
                }
                if (!isPm && hour === 12) {
                    hour = 0;
                }
                return hour;
            } else {
                // this is not supposed to happen
                return hour;
            }
        }

        // date from string and array of format strings
        function configFromStringAndArray(config) {
            var tempConfig,
                bestMoment,
                scoreToBeat,
                i,
                currentScore,
                validFormatFound,
                bestFormatIsValid = false;

            if (config._f.length === 0) {
                getParsingFlags(config).invalidFormat = true;
                config._d = new Date(NaN);
                return;
            }

            for (i = 0; i < config._f.length; i++) {
                currentScore = 0;
                validFormatFound = false;
                tempConfig = copyConfig({}, config);
                if (config._useUTC != null) {
                    tempConfig._useUTC = config._useUTC;
                }
                tempConfig._f = config._f[i];
                configFromStringAndFormat(tempConfig);

                if (isValid(tempConfig)) {
                    validFormatFound = true;
                }

                // if there is any input that was not parsed add a penalty for that format
                currentScore += getParsingFlags(tempConfig).charsLeftOver;

                //or tokens
                currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

                getParsingFlags(tempConfig).score = currentScore;

                if (!bestFormatIsValid) {
                    if (
                        scoreToBeat == null ||
                        currentScore < scoreToBeat ||
                        validFormatFound
                    ) {
                        scoreToBeat = currentScore;
                        bestMoment = tempConfig;
                        if (validFormatFound) {
                            bestFormatIsValid = true;
                        }
                    }
                } else {
                    if (currentScore < scoreToBeat) {
                        scoreToBeat = currentScore;
                        bestMoment = tempConfig;
                    }
                }
            }

            extend(config, bestMoment || tempConfig);
        }

        function configFromObject(config) {
            if (config._d) {
                return;
            }

            var i = normalizeObjectUnits(config._i),
                dayOrDate = i.day === undefined ? i.date : i.day;
            config._a = map(
                [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
                function (obj) {
                    return obj && parseInt(obj, 10);
                }
            );

            configFromArray(config);
        }

        function createFromConfig(config) {
            var res = new Moment(checkOverflow(prepareConfig(config)));
            if (res._nextDay) {
                // Adding is smart enough around DST
                res.add(1, 'd');
                res._nextDay = undefined;
            }

            return res;
        }

        function prepareConfig(config) {
            var input = config._i,
                format = config._f;

            config._locale = config._locale || getLocale(config._l);

            if (input === null || (format === undefined && input === '')) {
                return createInvalid({ nullInput: true });
            }

            if (typeof input === 'string') {
                config._i = input = config._locale.preparse(input);
            }

            if (isMoment(input)) {
                return new Moment(checkOverflow(input));
            } else if (isDate(input)) {
                config._d = input;
            } else if (isArray(format)) {
                configFromStringAndArray(config);
            } else if (format) {
                configFromStringAndFormat(config);
            } else {
                configFromInput(config);
            }

            if (!isValid(config)) {
                config._d = null;
            }

            return config;
        }

        function configFromInput(config) {
            var input = config._i;
            if (isUndefined(input)) {
                config._d = new Date(hooks.now());
            } else if (isDate(input)) {
                config._d = new Date(input.valueOf());
            } else if (typeof input === 'string') {
                configFromString(config);
            } else if (isArray(input)) {
                config._a = map(input.slice(0), function (obj) {
                    return parseInt(obj, 10);
                });
                configFromArray(config);
            } else if (isObject(input)) {
                configFromObject(config);
            } else if (isNumber(input)) {
                // from milliseconds
                config._d = new Date(input);
            } else {
                hooks.createFromInputFallback(config);
            }
        }

        function createLocalOrUTC(input, format, locale, strict, isUTC) {
            var c = {};

            if (format === true || format === false) {
                strict = format;
                format = undefined;
            }

            if (locale === true || locale === false) {
                strict = locale;
                locale = undefined;
            }

            if (
                (isObject(input) && isObjectEmpty(input)) ||
                (isArray(input) && input.length === 0)
            ) {
                input = undefined;
            }
            // object construction must be done this way.
            // https://github.com/moment/moment/issues/1423
            c._isAMomentObject = true;
            c._useUTC = c._isUTC = isUTC;
            c._l = locale;
            c._i = input;
            c._f = format;
            c._strict = strict;

            return createFromConfig(c);
        }

        function createLocal(input, format, locale, strict) {
            return createLocalOrUTC(input, format, locale, strict, false);
        }

        var prototypeMin = deprecate(
                'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
                function () {
                    var other = createLocal.apply(null, arguments);
                    if (this.isValid() && other.isValid()) {
                        return other < this ? this : other;
                    } else {
                        return createInvalid();
                    }
                }
            ),
            prototypeMax = deprecate(
                'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
                function () {
                    var other = createLocal.apply(null, arguments);
                    if (this.isValid() && other.isValid()) {
                        return other > this ? this : other;
                    } else {
                        return createInvalid();
                    }
                }
            );

        // Pick a moment m from moments so that m[fn](other) is true for all
        // other. This relies on the function fn to be transitive.
        //
        // moments should either be an array of moment objects or an array, whose
        // first element is an array of moment objects.
        function pickBy(fn, moments) {
            var res, i;
            if (moments.length === 1 && isArray(moments[0])) {
                moments = moments[0];
            }
            if (!moments.length) {
                return createLocal();
            }
            res = moments[0];
            for (i = 1; i < moments.length; ++i) {
                if (!moments[i].isValid() || moments[i][fn](res)) {
                    res = moments[i];
                }
            }
            return res;
        }

        // TODO: Use [].sort instead?
        function min() {
            var args = [].slice.call(arguments, 0);

            return pickBy('isBefore', args);
        }

        function max() {
            var args = [].slice.call(arguments, 0);

            return pickBy('isAfter', args);
        }

        var now = function () {
            return Date.now ? Date.now() : +new Date();
        };

        var ordering = [
            'year',
            'quarter',
            'month',
            'week',
            'day',
            'hour',
            'minute',
            'second',
            'millisecond',
        ];

        function isDurationValid(m) {
            var key,
                unitHasDecimal = false,
                i;
            for (key in m) {
                if (
                    hasOwnProp(m, key) &&
                    !(
                        indexOf.call(ordering, key) !== -1 &&
                        (m[key] == null || !isNaN(m[key]))
                    )
                ) {
                    return false;
                }
            }

            for (i = 0; i < ordering.length; ++i) {
                if (m[ordering[i]]) {
                    if (unitHasDecimal) {
                        return false; // only allow non-integers for smallest unit
                    }
                    if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                        unitHasDecimal = true;
                    }
                }
            }

            return true;
        }

        function isValid$1() {
            return this._isValid;
        }

        function createInvalid$1() {
            return createDuration(NaN);
        }

        function Duration(duration) {
            var normalizedInput = normalizeObjectUnits(duration),
                years = normalizedInput.year || 0,
                quarters = normalizedInput.quarter || 0,
                months = normalizedInput.month || 0,
                weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
                days = normalizedInput.day || 0,
                hours = normalizedInput.hour || 0,
                minutes = normalizedInput.minute || 0,
                seconds = normalizedInput.second || 0,
                milliseconds = normalizedInput.millisecond || 0;

            this._isValid = isDurationValid(normalizedInput);

            // representation for dateAddRemove
            this._milliseconds =
                +milliseconds +
                seconds * 1e3 + // 1000
                minutes * 6e4 + // 1000 * 60
                hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
            // Because of dateAddRemove treats 24 hours as different from a
            // day when working around DST, we need to store them separately
            this._days = +days + weeks * 7;
            // It is impossible to translate months into days without knowing
            // which months you are are talking about, so we have to store
            // it separately.
            this._months = +months + quarters * 3 + years * 12;

            this._data = {};

            this._locale = getLocale();

            this._bubble();
        }

        function isDuration(obj) {
            return obj instanceof Duration;
        }

        function absRound(number) {
            if (number < 0) {
                return Math.round(-1 * number) * -1;
            } else {
                return Math.round(number);
            }
        }

        // compare two arrays, return the number of differences
        function compareArrays(array1, array2, dontConvert) {
            var len = Math.min(array1.length, array2.length),
                lengthDiff = Math.abs(array1.length - array2.length),
                diffs = 0,
                i;
            for (i = 0; i < len; i++) {
                if (
                    (dontConvert && array1[i] !== array2[i]) ||
                    (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))
                ) {
                    diffs++;
                }
            }
            return diffs + lengthDiff;
        }

        // FORMATTING

        function offset(token, separator) {
            addFormatToken(token, 0, 0, function () {
                var offset = this.utcOffset(),
                    sign = '+';
                if (offset < 0) {
                    offset = -offset;
                    sign = '-';
                }
                return (
                    sign +
                    zeroFill(~~(offset / 60), 2) +
                    separator +
                    zeroFill(~~offset % 60, 2)
                );
            });
        }

        offset('Z', ':');
        offset('ZZ', '');

        // PARSING

        addRegexToken('Z', matchShortOffset);
        addRegexToken('ZZ', matchShortOffset);
        addParseToken(['Z', 'ZZ'], function (input, array, config) {
            config._useUTC = true;
            config._tzm = offsetFromString(matchShortOffset, input);
        });

        // HELPERS

        // timezone chunker
        // '+10:00' > ['10',  '00']
        // '-1530'  > ['-15', '30']
        var chunkOffset = /([\+\-]|\d\d)/gi;

        function offsetFromString(matcher, string) {
            var matches = (string || '').match(matcher),
                chunk,
                parts,
                minutes;

            if (matches === null) {
                return null;
            }

            chunk = matches[matches.length - 1] || [];
            parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
            minutes = +(parts[1] * 60) + toInt(parts[2]);

            return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
        }

        // Return a moment from input, that is local/utc/zone equivalent to model.
        function cloneWithOffset(input, model) {
            var res, diff;
            if (model._isUTC) {
                res = model.clone();
                diff =
                    (isMoment(input) || isDate(input)
                        ? input.valueOf()
                        : createLocal(input).valueOf()) - res.valueOf();
                // Use low-level api, because this fn is low-level api.
                res._d.setTime(res._d.valueOf() + diff);
                hooks.updateOffset(res, false);
                return res;
            } else {
                return createLocal(input).local();
            }
        }

        function getDateOffset(m) {
            // On Firefox.24 Date#getTimezoneOffset returns a floating point.
            // https://github.com/moment/moment/pull/1871
            return -Math.round(m._d.getTimezoneOffset());
        }

        // HOOKS

        // This function will be called whenever a moment is mutated.
        // It is intended to keep the offset in sync with the timezone.
        hooks.updateOffset = function () {};

        // MOMENTS

        // keepLocalTime = true means only change the timezone, without
        // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
        // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
        // +0200, so we adjust the time as needed, to be valid.
        //
        // Keeping the time actually adds/subtracts (one hour)
        // from the actual represented time. That is why we call updateOffset
        // a second time. In case it wants us to change the offset again
        // _changeInProgress == true case, then we have to adjust, because
        // there is no such time in the given timezone.
        function getSetOffset(input, keepLocalTime, keepMinutes) {
            var offset = this._offset || 0,
                localAdjust;
            if (!this.isValid()) {
                return input != null ? this : NaN;
            }
            if (input != null) {
                if (typeof input === 'string') {
                    input = offsetFromString(matchShortOffset, input);
                    if (input === null) {
                        return this;
                    }
                } else if (Math.abs(input) < 16 && !keepMinutes) {
                    input = input * 60;
                }
                if (!this._isUTC && keepLocalTime) {
                    localAdjust = getDateOffset(this);
                }
                this._offset = input;
                this._isUTC = true;
                if (localAdjust != null) {
                    this.add(localAdjust, 'm');
                }
                if (offset !== input) {
                    if (!keepLocalTime || this._changeInProgress) {
                        addSubtract(
                            this,
                            createDuration(input - offset, 'm'),
                            1,
                            false
                        );
                    } else if (!this._changeInProgress) {
                        this._changeInProgress = true;
                        hooks.updateOffset(this, true);
                        this._changeInProgress = null;
                    }
                }
                return this;
            } else {
                return this._isUTC ? offset : getDateOffset(this);
            }
        }

        function getSetZone(input, keepLocalTime) {
            if (input != null) {
                if (typeof input !== 'string') {
                    input = -input;
                }

                this.utcOffset(input, keepLocalTime);

                return this;
            } else {
                return -this.utcOffset();
            }
        }

        function setOffsetToUTC(keepLocalTime) {
            return this.utcOffset(0, keepLocalTime);
        }

        function setOffsetToLocal(keepLocalTime) {
            if (this._isUTC) {
                this.utcOffset(0, keepLocalTime);
                this._isUTC = false;

                if (keepLocalTime) {
                    this.subtract(getDateOffset(this), 'm');
                }
            }
            return this;
        }

        function setOffsetToParsedOffset() {
            if (this._tzm != null) {
                this.utcOffset(this._tzm, false, true);
            } else if (typeof this._i === 'string') {
                var tZone = offsetFromString(matchOffset, this._i);
                if (tZone != null) {
                    this.utcOffset(tZone);
                } else {
                    this.utcOffset(0, true);
                }
            }
            return this;
        }

        function hasAlignedHourOffset(input) {
            if (!this.isValid()) {
                return false;
            }
            input = input ? createLocal(input).utcOffset() : 0;

            return (this.utcOffset() - input) % 60 === 0;
        }

        function isDaylightSavingTime() {
            return (
                this.utcOffset() > this.clone().month(0).utcOffset() ||
                this.utcOffset() > this.clone().month(5).utcOffset()
            );
        }

        function isDaylightSavingTimeShifted() {
            if (!isUndefined(this._isDSTShifted)) {
                return this._isDSTShifted;
            }

            var c = {},
                other;

            copyConfig(c, this);
            c = prepareConfig(c);

            if (c._a) {
                other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
                this._isDSTShifted =
                    this.isValid() && compareArrays(c._a, other.toArray()) > 0;
            } else {
                this._isDSTShifted = false;
            }

            return this._isDSTShifted;
        }

        function isLocal() {
            return this.isValid() ? !this._isUTC : false;
        }

        function isUtcOffset() {
            return this.isValid() ? this._isUTC : false;
        }

        function isUtc() {
            return this.isValid() ? this._isUTC && this._offset === 0 : false;
        }

        // ASP.NET json date format regex
        var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
            // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
            // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
            // and further modified to allow for strings containing both week and day
            isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

        function createDuration(input, key) {
            var duration = input,
                // matching against regexp is expensive, do it on demand
                match = null,
                sign,
                ret,
                diffRes;

            if (isDuration(input)) {
                duration = {
                    ms: input._milliseconds,
                    d: input._days,
                    M: input._months,
                };
            } else if (isNumber(input) || !isNaN(+input)) {
                duration = {};
                if (key) {
                    duration[key] = +input;
                } else {
                    duration.milliseconds = +input;
                }
            } else if ((match = aspNetRegex.exec(input))) {
                sign = match[1] === '-' ? -1 : 1;
                duration = {
                    y: 0,
                    d: toInt(match[DATE]) * sign,
                    h: toInt(match[HOUR]) * sign,
                    m: toInt(match[MINUTE]) * sign,
                    s: toInt(match[SECOND]) * sign,
                    ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match
                };
            } else if ((match = isoRegex.exec(input))) {
                sign = match[1] === '-' ? -1 : 1;
                duration = {
                    y: parseIso(match[2], sign),
                    M: parseIso(match[3], sign),
                    w: parseIso(match[4], sign),
                    d: parseIso(match[5], sign),
                    h: parseIso(match[6], sign),
                    m: parseIso(match[7], sign),
                    s: parseIso(match[8], sign),
                };
            } else if (duration == null) {
                // checks for null or undefined
                duration = {};
            } else if (
                typeof duration === 'object' &&
                ('from' in duration || 'to' in duration)
            ) {
                diffRes = momentsDifference(
                    createLocal(duration.from),
                    createLocal(duration.to)
                );

                duration = {};
                duration.ms = diffRes.milliseconds;
                duration.M = diffRes.months;
            }

            ret = new Duration(duration);

            if (isDuration(input) && hasOwnProp(input, '_locale')) {
                ret._locale = input._locale;
            }

            if (isDuration(input) && hasOwnProp(input, '_isValid')) {
                ret._isValid = input._isValid;
            }

            return ret;
        }

        createDuration.fn = Duration.prototype;
        createDuration.invalid = createInvalid$1;

        function parseIso(inp, sign) {
            // We'd normally use ~~inp for this, but unfortunately it also
            // converts floats to ints.
            // inp may be undefined, so careful calling replace on it.
            var res = inp && parseFloat(inp.replace(',', '.'));
            // apply sign while we're at it
            return (isNaN(res) ? 0 : res) * sign;
        }

        function positiveMomentsDifference(base, other) {
            var res = {};

            res.months =
                other.month() - base.month() + (other.year() - base.year()) * 12;
            if (base.clone().add(res.months, 'M').isAfter(other)) {
                --res.months;
            }

            res.milliseconds = +other - +base.clone().add(res.months, 'M');

            return res;
        }

        function momentsDifference(base, other) {
            var res;
            if (!(base.isValid() && other.isValid())) {
                return { milliseconds: 0, months: 0 };
            }

            other = cloneWithOffset(other, base);
            if (base.isBefore(other)) {
                res = positiveMomentsDifference(base, other);
            } else {
                res = positiveMomentsDifference(other, base);
                res.milliseconds = -res.milliseconds;
                res.months = -res.months;
            }

            return res;
        }

        // TODO: remove 'name' arg after deprecation is removed
        function createAdder(direction, name) {
            return function (val, period) {
                var dur, tmp;
                //invert the arguments, but complain about it
                if (period !== null && !isNaN(+period)) {
                    deprecateSimple(
                        name,
                        'moment().' +
                        name +
                        '(period, number) is deprecated. Please use moment().' +
                        name +
                        '(number, period). ' +
                        'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.'
                    );
                    tmp = val;
                    val = period;
                    period = tmp;
                }

                dur = createDuration(val, period);
                addSubtract(this, dur, direction);
                return this;
            };
        }

        function addSubtract(mom, duration, isAdding, updateOffset) {
            var milliseconds = duration._milliseconds,
                days = absRound(duration._days),
                months = absRound(duration._months);

            if (!mom.isValid()) {
                // No op
                return;
            }

            updateOffset = updateOffset == null ? true : updateOffset;

            if (months) {
                setMonth(mom, get(mom, 'Month') + months * isAdding);
            }
            if (days) {
                set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
            }
            if (milliseconds) {
                mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
            }
            if (updateOffset) {
                hooks.updateOffset(mom, days || months);
            }
        }

        var add = createAdder(1, 'add'),
            subtract = createAdder(-1, 'subtract');

        function isString(input) {
            return typeof input === 'string' || input instanceof String;
        }

        // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
        function isMomentInput(input) {
            return (
                isMoment(input) ||
                isDate(input) ||
                isString(input) ||
                isNumber(input) ||
                isNumberOrStringArray(input) ||
                isMomentInputObject(input) ||
                input === null ||
                input === undefined
            );
        }

        function isMomentInputObject(input) {
            var objectTest = isObject(input) && !isObjectEmpty(input),
                propertyTest = false,
                properties = [
                    'years',
                    'year',
                    'y',
                    'months',
                    'month',
                    'M',
                    'days',
                    'day',
                    'd',
                    'dates',
                    'date',
                    'D',
                    'hours',
                    'hour',
                    'h',
                    'minutes',
                    'minute',
                    'm',
                    'seconds',
                    'second',
                    's',
                    'milliseconds',
                    'millisecond',
                    'ms',
                ],
                i,
                property;

            for (i = 0; i < properties.length; i += 1) {
                property = properties[i];
                propertyTest = propertyTest || hasOwnProp(input, property);
            }

            return objectTest && propertyTest;
        }

        function isNumberOrStringArray(input) {
            var arrayTest = isArray(input),
                dataTypeTest = false;
            if (arrayTest) {
                dataTypeTest =
                    input.filter(function (item) {
                        return !isNumber(item) && isString(input);
                    }).length === 0;
            }
            return arrayTest && dataTypeTest;
        }

        function isCalendarSpec(input) {
            var objectTest = isObject(input) && !isObjectEmpty(input),
                propertyTest = false,
                properties = [
                    'sameDay',
                    'nextDay',
                    'lastDay',
                    'nextWeek',
                    'lastWeek',
                    'sameElse',
                ],
                i,
                property;

            for (i = 0; i < properties.length; i += 1) {
                property = properties[i];
                propertyTest = propertyTest || hasOwnProp(input, property);
            }

            return objectTest && propertyTest;
        }

        function getCalendarFormat(myMoment, now) {
            var diff = myMoment.diff(now, 'days', true);
            return diff < -6
                ? 'sameElse'
                : diff < -1
                    ? 'lastWeek'
                    : diff < 0
                        ? 'lastDay'
                        : diff < 1
                            ? 'sameDay'
                            : diff < 2
                                ? 'nextDay'
                                : diff < 7
                                    ? 'nextWeek'
                                    : 'sameElse';
        }

        function calendar$1(time, formats) {
            // Support for single parameter, formats only overload to the calendar function
            if (arguments.length === 1) {
                if (!arguments[0]) {
                    time = undefined;
                    formats = undefined;
                } else if (isMomentInput(arguments[0])) {
                    time = arguments[0];
                    formats = undefined;
                } else if (isCalendarSpec(arguments[0])) {
                    formats = arguments[0];
                    time = undefined;
                }
            }
            // We want to compare the start of today, vs this.
            // Getting start-of-today depends on whether we're local/utc/offset or not.
            var now = time || createLocal(),
                sod = cloneWithOffset(now, this).startOf('day'),
                format = hooks.calendarFormat(this, sod) || 'sameElse',
                output =
                    formats &&
                    (isFunction(formats[format])
                        ? formats[format].call(this, now)
                        : formats[format]);

            return this.format(
                output || this.localeData().calendar(format, this, createLocal(now))
            );
        }

        function clone() {
            return new Moment(this);
        }

        function isAfter(input, units) {
            var localInput = isMoment(input) ? input : createLocal(input);
            if (!(this.isValid() && localInput.isValid())) {
                return false;
            }
            units = normalizeUnits(units) || 'millisecond';
            if (units === 'millisecond') {
                return this.valueOf() > localInput.valueOf();
            } else {
                return localInput.valueOf() < this.clone().startOf(units).valueOf();
            }
        }

        function isBefore(input, units) {
            var localInput = isMoment(input) ? input : createLocal(input);
            if (!(this.isValid() && localInput.isValid())) {
                return false;
            }
            units = normalizeUnits(units) || 'millisecond';
            if (units === 'millisecond') {
                return this.valueOf() < localInput.valueOf();
            } else {
                return this.clone().endOf(units).valueOf() < localInput.valueOf();
            }
        }

        function isBetween(from, to, units, inclusivity) {
            var localFrom = isMoment(from) ? from : createLocal(from),
                localTo = isMoment(to) ? to : createLocal(to);
            if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
                return false;
            }
            inclusivity = inclusivity || '()';
            return (
                (inclusivity[0] === '('
                    ? this.isAfter(localFrom, units)
                    : !this.isBefore(localFrom, units)) &&
                (inclusivity[1] === ')'
                    ? this.isBefore(localTo, units)
                    : !this.isAfter(localTo, units))
            );
        }

        function isSame(input, units) {
            var localInput = isMoment(input) ? input : createLocal(input),
                inputMs;
            if (!(this.isValid() && localInput.isValid())) {
                return false;
            }
            units = normalizeUnits(units) || 'millisecond';
            if (units === 'millisecond') {
                return this.valueOf() === localInput.valueOf();
            } else {
                inputMs = localInput.valueOf();
                return (
                    this.clone().startOf(units).valueOf() <= inputMs &&
                    inputMs <= this.clone().endOf(units).valueOf()
                );
            }
        }

        function isSameOrAfter(input, units) {
            return this.isSame(input, units) || this.isAfter(input, units);
        }

        function isSameOrBefore(input, units) {
            return this.isSame(input, units) || this.isBefore(input, units);
        }

        function diff(input, units, asFloat) {
            var that, zoneDelta, output;

            if (!this.isValid()) {
                return NaN;
            }

            that = cloneWithOffset(input, this);

            if (!that.isValid()) {
                return NaN;
            }

            zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

            units = normalizeUnits(units);

            switch (units) {
                case 'year':
                    output = monthDiff(this, that) / 12;
                    break;
                case 'month':
                    output = monthDiff(this, that);
                    break;
                case 'quarter':
                    output = monthDiff(this, that) / 3;
                    break;
                case 'second':
                    output = (this - that) / 1e3;
                    break; // 1000
                case 'minute':
                    output = (this - that) / 6e4;
                    break; // 1000 * 60
                case 'hour':
                    output = (this - that) / 36e5;
                    break; // 1000 * 60 * 60
                case 'day':
                    output = (this - that - zoneDelta) / 864e5;
                    break; // 1000 * 60 * 60 * 24, negate dst
                case 'week':
                    output = (this - that - zoneDelta) / 6048e5;
                    break; // 1000 * 60 * 60 * 24 * 7, negate dst
                default:
                    output = this - that;
            }

            return asFloat ? output : absFloor(output);
        }

        function monthDiff(a, b) {
            if (a.date() < b.date()) {
                // end-of-month calculations work correct when the start month has more
                // days than the end month.
                return -monthDiff(b, a);
            }
            // difference in months
            var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
                // b is in (anchor - 1 month, anchor + 1 month)
                anchor = a.clone().add(wholeMonthDiff, 'months'),
                anchor2,
                adjust;

            if (b - anchor < 0) {
                anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
                // linear across the month
                adjust = (b - anchor) / (anchor - anchor2);
            } else {
                anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
                // linear across the month
                adjust = (b - anchor) / (anchor2 - anchor);
            }

            //check for negative zero, return zero if negative zero
            return -(wholeMonthDiff + adjust) || 0;
        }

        hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
        hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

        function toString() {
            return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
        }

        function toISOString(keepOffset) {
            if (!this.isValid()) {
                return null;
            }
            var utc = keepOffset !== true,
                m = utc ? this.clone().utc() : this;
            if (m.year() < 0 || m.year() > 9999) {
                return formatMoment(
                    m,
                    utc
                        ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]'
                        : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ'
                );
            }
            if (isFunction(Date.prototype.toISOString)) {
                // native implementation is ~50x faster, use it when we can
                if (utc) {
                    return this.toDate().toISOString();
                } else {
                    return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)
                        .toISOString()
                        .replace('Z', formatMoment(m, 'Z'));
                }
            }
            return formatMoment(
                m,
                utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ'
            );
        }

        /**
         * Return a human readable representation of a moment that can
         * also be evaluated to get a new moment which is the same
         *
         * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
         */
        function inspect() {
            if (!this.isValid()) {
                return 'moment.invalid(/* ' + this._i + ' */)';
            }
            var func = 'moment',
                zone = '',
                prefix,
                year,
                datetime,
                suffix;
            if (!this.isLocal()) {
                func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
                zone = 'Z';
            }
            prefix = '[' + func + '("]';
            year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
            datetime = '-MM-DD[T]HH:mm:ss.SSS';
            suffix = zone + '[")]';

            return this.format(prefix + year + datetime + suffix);
        }

        function format(inputString) {
            if (!inputString) {
                inputString = this.isUtc()
                    ? hooks.defaultFormatUtc
                    : hooks.defaultFormat;
            }
            var output = formatMoment(this, inputString);
            return this.localeData().postformat(output);
        }

        function from(time, withoutSuffix) {
            if (
                this.isValid() &&
                ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
            ) {
                return createDuration({ to: this, from: time })
                    .locale(this.locale())
                    .humanize(!withoutSuffix);
            } else {
                return this.localeData().invalidDate();
            }
        }

        function fromNow(withoutSuffix) {
            return this.from(createLocal(), withoutSuffix);
        }

        function to(time, withoutSuffix) {
            if (
                this.isValid() &&
                ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
            ) {
                return createDuration({ from: this, to: time })
                    .locale(this.locale())
                    .humanize(!withoutSuffix);
            } else {
                return this.localeData().invalidDate();
            }
        }

        function toNow(withoutSuffix) {
            return this.to(createLocal(), withoutSuffix);
        }

        // If passed a locale key, it will set the locale for this
        // instance.  Otherwise, it will return the locale configuration
        // variables for this instance.
        function locale(key) {
            var newLocaleData;

            if (key === undefined) {
                return this._locale._abbr;
            } else {
                newLocaleData = getLocale(key);
                if (newLocaleData != null) {
                    this._locale = newLocaleData;
                }
                return this;
            }
        }

        var lang = deprecate(
            'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
            function (key) {
                if (key === undefined) {
                    return this.localeData();
                } else {
                    return this.locale(key);
                }
            }
        );

        function localeData() {
            return this._locale;
        }

        var MS_PER_SECOND = 1000,
            MS_PER_MINUTE = 60 * MS_PER_SECOND,
            MS_PER_HOUR = 60 * MS_PER_MINUTE,
            MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

        // actual modulo - handles negative numbers (for dates before 1970):
        function mod$1(dividend, divisor) {
            return ((dividend % divisor) + divisor) % divisor;
        }

        function localStartOfDate(y, m, d) {
            // the date constructor remaps years 0-99 to 1900-1999
            if (y < 100 && y >= 0) {
                // preserve leap years using a full 400 year cycle, then reset
                return new Date(y + 400, m, d) - MS_PER_400_YEARS;
            } else {
                return new Date(y, m, d).valueOf();
            }
        }

        function utcStartOfDate(y, m, d) {
            // Date.UTC remaps years 0-99 to 1900-1999
            if (y < 100 && y >= 0) {
                // preserve leap years using a full 400 year cycle, then reset
                return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
            } else {
                return Date.UTC(y, m, d);
            }
        }

        function startOf(units) {
            var time, startOfDate;
            units = normalizeUnits(units);
            if (units === undefined || units === 'millisecond' || !this.isValid()) {
                return this;
            }

            startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

            switch (units) {
                case 'year':
                    time = startOfDate(this.year(), 0, 1);
                    break;
                case 'quarter':
                    time = startOfDate(
                        this.year(),
                        this.month() - (this.month() % 3),
                        1
                    );
                    break;
                case 'month':
                    time = startOfDate(this.year(), this.month(), 1);
                    break;
                case 'week':
                    time = startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - this.weekday()
                    );
                    break;
                case 'isoWeek':
                    time = startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - (this.isoWeekday() - 1)
                    );
                    break;
                case 'day':
                case 'date':
                    time = startOfDate(this.year(), this.month(), this.date());
                    break;
                case 'hour':
                    time = this._d.valueOf();
                    time -= mod$1(
                        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                        MS_PER_HOUR
                    );
                    break;
                case 'minute':
                    time = this._d.valueOf();
                    time -= mod$1(time, MS_PER_MINUTE);
                    break;
                case 'second':
                    time = this._d.valueOf();
                    time -= mod$1(time, MS_PER_SECOND);
                    break;
            }

            this._d.setTime(time);
            hooks.updateOffset(this, true);
            return this;
        }

        function endOf(units) {
            var time, startOfDate;
            units = normalizeUnits(units);
            if (units === undefined || units === 'millisecond' || !this.isValid()) {
                return this;
            }

            startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

            switch (units) {
                case 'year':
                    time = startOfDate(this.year() + 1, 0, 1) - 1;
                    break;
                case 'quarter':
                    time =
                        startOfDate(
                            this.year(),
                            this.month() - (this.month() % 3) + 3,
                            1
                        ) - 1;
                    break;
                case 'month':
                    time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                    break;
                case 'week':
                    time =
                        startOfDate(
                            this.year(),
                            this.month(),
                            this.date() - this.weekday() + 7
                        ) - 1;
                    break;
                case 'isoWeek':
                    time =
                        startOfDate(
                            this.year(),
                            this.month(),
                            this.date() - (this.isoWeekday() - 1) + 7
                        ) - 1;
                    break;
                case 'day':
                case 'date':
                    time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                    break;
                case 'hour':
                    time = this._d.valueOf();
                    time +=
                        MS_PER_HOUR -
                        mod$1(
                            time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                            MS_PER_HOUR
                        ) -
                        1;
                    break;
                case 'minute':
                    time = this._d.valueOf();
                    time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                    break;
                case 'second':
                    time = this._d.valueOf();
                    time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                    break;
            }

            this._d.setTime(time);
            hooks.updateOffset(this, true);
            return this;
        }

        function valueOf() {
            return this._d.valueOf() - (this._offset || 0) * 60000;
        }

        function unix() {
            return Math.floor(this.valueOf() / 1000);
        }

        function toDate() {
            return new Date(this.valueOf());
        }

        function toArray() {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hour(),
                m.minute(),
                m.second(),
                m.millisecond(),
            ];
        }

        function toObject() {
            var m = this;
            return {
                years: m.year(),
                months: m.month(),
                date: m.date(),
                hours: m.hours(),
                minutes: m.minutes(),
                seconds: m.seconds(),
                milliseconds: m.milliseconds(),
            };
        }

        function toJSON() {
            // new Date(NaN).toJSON() === null
            return this.isValid() ? this.toISOString() : null;
        }

        function isValid$2() {
            return isValid(this);
        }

        function parsingFlags() {
            return extend({}, getParsingFlags(this));
        }

        function invalidAt() {
            return getParsingFlags(this).overflow;
        }

        function creationData() {
            return {
                input: this._i,
                format: this._f,
                locale: this._locale,
                isUTC: this._isUTC,
                strict: this._strict,
            };
        }

        addFormatToken('N', 0, 0, 'eraAbbr');
        addFormatToken('NN', 0, 0, 'eraAbbr');
        addFormatToken('NNN', 0, 0, 'eraAbbr');
        addFormatToken('NNNN', 0, 0, 'eraName');
        addFormatToken('NNNNN', 0, 0, 'eraNarrow');

        addFormatToken('y', ['y', 1], 'yo', 'eraYear');
        addFormatToken('y', ['yy', 2], 0, 'eraYear');
        addFormatToken('y', ['yyy', 3], 0, 'eraYear');
        addFormatToken('y', ['yyyy', 4], 0, 'eraYear');

        addRegexToken('N', matchEraAbbr);
        addRegexToken('NN', matchEraAbbr);
        addRegexToken('NNN', matchEraAbbr);
        addRegexToken('NNNN', matchEraName);
        addRegexToken('NNNNN', matchEraNarrow);

        addParseToken(['N', 'NN', 'NNN', 'NNNN', 'NNNNN'], function (
            input,
            array,
            config,
            token
        ) {
            var era = config._locale.erasParse(input, token, config._strict);
            if (era) {
                getParsingFlags(config).era = era;
            } else {
                getParsingFlags(config).invalidEra = input;
            }
        });

        addRegexToken('y', matchUnsigned);
        addRegexToken('yy', matchUnsigned);
        addRegexToken('yyy', matchUnsigned);
        addRegexToken('yyyy', matchUnsigned);
        addRegexToken('yo', matchEraYearOrdinal);

        addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
        addParseToken(['yo'], function (input, array, config, token) {
            var match;
            if (config._locale._eraYearOrdinalRegex) {
                match = input.match(config._locale._eraYearOrdinalRegex);
            }

            if (config._locale.eraYearOrdinalParse) {
                array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
            } else {
                array[YEAR] = parseInt(input, 10);
            }
        });

        function localeEras(m, format) {
            var i,
                l,
                date,
                eras = this._eras || getLocale('en')._eras;
            for (i = 0, l = eras.length; i < l; ++i) {
                switch (typeof eras[i].since) {
                    case 'string':
                        // truncate time
                        date = hooks(eras[i].since).startOf('day');
                        eras[i].since = date.valueOf();
                        break;
                }

                switch (typeof eras[i].until) {
                    case 'undefined':
                        eras[i].until = +Infinity;
                        break;
                    case 'string':
                        // truncate time
                        date = hooks(eras[i].until).startOf('day').valueOf();
                        eras[i].until = date.valueOf();
                        break;
                }
            }
            return eras;
        }

        function localeErasParse(eraName, format, strict) {
            var i,
                l,
                eras = this.eras(),
                name,
                abbr,
                narrow;
            eraName = eraName.toUpperCase();

            for (i = 0, l = eras.length; i < l; ++i) {
                name = eras[i].name.toUpperCase();
                abbr = eras[i].abbr.toUpperCase();
                narrow = eras[i].narrow.toUpperCase();

                if (strict) {
                    switch (format) {
                        case 'N':
                        case 'NN':
                        case 'NNN':
                            if (abbr === eraName) {
                                return eras[i];
                            }
                            break;

                        case 'NNNN':
                            if (name === eraName) {
                                return eras[i];
                            }
                            break;

                        case 'NNNNN':
                            if (narrow === eraName) {
                                return eras[i];
                            }
                            break;
                    }
                } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
                    return eras[i];
                }
            }
        }

        function localeErasConvertYear(era, year) {
            var dir = era.since <= era.until ? +1 : -1;
            if (year === undefined) {
                return hooks(era.since).year();
            } else {
                return hooks(era.since).year() + (year - era.offset) * dir;
            }
        }

        function getEraName() {
            var i,
                l,
                val,
                eras = this.localeData().eras();
            for (i = 0, l = eras.length; i < l; ++i) {
                // truncate time
                val = this.clone().startOf('day').valueOf();

                if (eras[i].since <= val && val <= eras[i].until) {
                    return eras[i].name;
                }
                if (eras[i].until <= val && val <= eras[i].since) {
                    return eras[i].name;
                }
            }

            return '';
        }

        function getEraNarrow() {
            var i,
                l,
                val,
                eras = this.localeData().eras();
            for (i = 0, l = eras.length; i < l; ++i) {
                // truncate time
                val = this.clone().startOf('day').valueOf();

                if (eras[i].since <= val && val <= eras[i].until) {
                    return eras[i].narrow;
                }
                if (eras[i].until <= val && val <= eras[i].since) {
                    return eras[i].narrow;
                }
            }

            return '';
        }

        function getEraAbbr() {
            var i,
                l,
                val,
                eras = this.localeData().eras();
            for (i = 0, l = eras.length; i < l; ++i) {
                // truncate time
                val = this.clone().startOf('day').valueOf();

                if (eras[i].since <= val && val <= eras[i].until) {
                    return eras[i].abbr;
                }
                if (eras[i].until <= val && val <= eras[i].since) {
                    return eras[i].abbr;
                }
            }

            return '';
        }

        function getEraYear() {
            var i,
                l,
                dir,
                val,
                eras = this.localeData().eras();
            for (i = 0, l = eras.length; i < l; ++i) {
                dir = eras[i].since <= eras[i].until ? +1 : -1;

                // truncate time
                val = this.clone().startOf('day').valueOf();

                if (
                    (eras[i].since <= val && val <= eras[i].until) ||
                    (eras[i].until <= val && val <= eras[i].since)
                ) {
                    return (
                        (this.year() - hooks(eras[i].since).year()) * dir +
                        eras[i].offset
                    );
                }
            }

            return this.year();
        }

        function erasNameRegex(isStrict) {
            if (!hasOwnProp(this, '_erasNameRegex')) {
                computeErasParse.call(this);
            }
            return isStrict ? this._erasNameRegex : this._erasRegex;
        }

        function erasAbbrRegex(isStrict) {
            if (!hasOwnProp(this, '_erasAbbrRegex')) {
                computeErasParse.call(this);
            }
            return isStrict ? this._erasAbbrRegex : this._erasRegex;
        }

        function erasNarrowRegex(isStrict) {
            if (!hasOwnProp(this, '_erasNarrowRegex')) {
                computeErasParse.call(this);
            }
            return isStrict ? this._erasNarrowRegex : this._erasRegex;
        }

        function matchEraAbbr(isStrict, locale) {
            return locale.erasAbbrRegex(isStrict);
        }

        function matchEraName(isStrict, locale) {
            return locale.erasNameRegex(isStrict);
        }

        function matchEraNarrow(isStrict, locale) {
            return locale.erasNarrowRegex(isStrict);
        }

        function matchEraYearOrdinal(isStrict, locale) {
            return locale._eraYearOrdinalRegex || matchUnsigned;
        }

        function computeErasParse() {
            var abbrPieces = [],
                namePieces = [],
                narrowPieces = [],
                mixedPieces = [],
                i,
                l,
                eras = this.eras();

            for (i = 0, l = eras.length; i < l; ++i) {
                namePieces.push(regexEscape(eras[i].name));
                abbrPieces.push(regexEscape(eras[i].abbr));
                narrowPieces.push(regexEscape(eras[i].narrow));

                mixedPieces.push(regexEscape(eras[i].name));
                mixedPieces.push(regexEscape(eras[i].abbr));
                mixedPieces.push(regexEscape(eras[i].narrow));
            }

            this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
            this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
            this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
            this._erasNarrowRegex = new RegExp(
                '^(' + narrowPieces.join('|') + ')',
                'i'
            );
        }

        // FORMATTING

        addFormatToken(0, ['gg', 2], 0, function () {
            return this.weekYear() % 100;
        });

        addFormatToken(0, ['GG', 2], 0, function () {
            return this.isoWeekYear() % 100;
        });

        function addWeekYearFormatToken(token, getter) {
            addFormatToken(0, [token, token.length], 0, getter);
        }

        addWeekYearFormatToken('gggg', 'weekYear');
        addWeekYearFormatToken('ggggg', 'weekYear');
        addWeekYearFormatToken('GGGG', 'isoWeekYear');
        addWeekYearFormatToken('GGGGG', 'isoWeekYear');

        // ALIASES

        addUnitAlias('weekYear', 'gg');
        addUnitAlias('isoWeekYear', 'GG');

        // PRIORITY

        addUnitPriority('weekYear', 1);
        addUnitPriority('isoWeekYear', 1);

        // PARSING

        addRegexToken('G', matchSigned);
        addRegexToken('g', matchSigned);
        addRegexToken('GG', match1to2, match2);
        addRegexToken('gg', match1to2, match2);
        addRegexToken('GGGG', match1to4, match4);
        addRegexToken('gggg', match1to4, match4);
        addRegexToken('GGGGG', match1to6, match6);
        addRegexToken('ggggg', match1to6, match6);

        addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (
            input,
            week,
            config,
            token
        ) {
            week[token.substr(0, 2)] = toInt(input);
        });

        addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
            week[token] = hooks.parseTwoDigitYear(input);
        });

        // MOMENTS

        function getSetWeekYear(input) {
            return getSetWeekYearHelper.call(
                this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy
            );
        }

        function getSetISOWeekYear(input) {
            return getSetWeekYearHelper.call(
                this,
                input,
                this.isoWeek(),
                this.isoWeekday(),
                1,
                4
            );
        }

        function getISOWeeksInYear() {
            return weeksInYear(this.year(), 1, 4);
        }

        function getISOWeeksInISOWeekYear() {
            return weeksInYear(this.isoWeekYear(), 1, 4);
        }

        function getWeeksInYear() {
            var weekInfo = this.localeData()._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        }

        function getWeeksInWeekYear() {
            var weekInfo = this.localeData()._week;
            return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
        }

        function getSetWeekYearHelper(input, week, weekday, dow, doy) {
            var weeksTarget;
            if (input == null) {
                return weekOfYear(this, dow, doy).year;
            } else {
                weeksTarget = weeksInYear(input, dow, doy);
                if (week > weeksTarget) {
                    week = weeksTarget;
                }
                return setWeekAll.call(this, input, week, weekday, dow, doy);
            }
        }

        function setWeekAll(weekYear, week, weekday, dow, doy) {
            var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
                date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

            this.year(date.getUTCFullYear());
            this.month(date.getUTCMonth());
            this.date(date.getUTCDate());
            return this;
        }

        // FORMATTING

        addFormatToken('Q', 0, 'Qo', 'quarter');

        // ALIASES

        addUnitAlias('quarter', 'Q');

        // PRIORITY

        addUnitPriority('quarter', 7);

        // PARSING

        addRegexToken('Q', match1);
        addParseToken('Q', function (input, array) {
            array[MONTH] = (toInt(input) - 1) * 3;
        });

        // MOMENTS

        function getSetQuarter(input) {
            return input == null
                ? Math.ceil((this.month() + 1) / 3)
                : this.month((input - 1) * 3 + (this.month() % 3));
        }

        // FORMATTING

        addFormatToken('D', ['DD', 2], 'Do', 'date');

        // ALIASES

        addUnitAlias('date', 'D');

        // PRIORITY
        addUnitPriority('date', 9);

        // PARSING

        addRegexToken('D', match1to2);
        addRegexToken('DD', match1to2, match2);
        addRegexToken('Do', function (isStrict, locale) {
            // TODO: Remove "ordinalParse" fallback in next major release.
            return isStrict
                ? locale._dayOfMonthOrdinalParse || locale._ordinalParse
                : locale._dayOfMonthOrdinalParseLenient;
        });

        addParseToken(['D', 'DD'], DATE);
        addParseToken('Do', function (input, array) {
            array[DATE] = toInt(input.match(match1to2)[0]);
        });

        // MOMENTS

        var getSetDayOfMonth = makeGetSet('Date', true);

        // FORMATTING

        addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

        // ALIASES

        addUnitAlias('dayOfYear', 'DDD');

        // PRIORITY
        addUnitPriority('dayOfYear', 4);

        // PARSING

        addRegexToken('DDD', match1to3);
        addRegexToken('DDDD', match3);
        addParseToken(['DDD', 'DDDD'], function (input, array, config) {
            config._dayOfYear = toInt(input);
        });

        // HELPERS

        // MOMENTS

        function getSetDayOfYear(input) {
            var dayOfYear =
                Math.round(
                    (this.clone().startOf('day') - this.clone().startOf('year')) / 864e5
                ) + 1;
            return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
        }

        // FORMATTING

        addFormatToken('m', ['mm', 2], 0, 'minute');

        // ALIASES

        addUnitAlias('minute', 'm');

        // PRIORITY

        addUnitPriority('minute', 14);

        // PARSING

        addRegexToken('m', match1to2);
        addRegexToken('mm', match1to2, match2);
        addParseToken(['m', 'mm'], MINUTE);

        // MOMENTS

        var getSetMinute = makeGetSet('Minutes', false);

        // FORMATTING

        addFormatToken('s', ['ss', 2], 0, 'second');

        // ALIASES

        addUnitAlias('second', 's');

        // PRIORITY

        addUnitPriority('second', 15);

        // PARSING

        addRegexToken('s', match1to2);
        addRegexToken('ss', match1to2, match2);
        addParseToken(['s', 'ss'], SECOND);

        // MOMENTS

        var getSetSecond = makeGetSet('Seconds', false);

        // FORMATTING

        addFormatToken('S', 0, 0, function () {
            return ~~(this.millisecond() / 100);
        });

        addFormatToken(0, ['SS', 2], 0, function () {
            return ~~(this.millisecond() / 10);
        });

        addFormatToken(0, ['SSS', 3], 0, 'millisecond');
        addFormatToken(0, ['SSSS', 4], 0, function () {
            return this.millisecond() * 10;
        });
        addFormatToken(0, ['SSSSS', 5], 0, function () {
            return this.millisecond() * 100;
        });
        addFormatToken(0, ['SSSSSS', 6], 0, function () {
            return this.millisecond() * 1000;
        });
        addFormatToken(0, ['SSSSSSS', 7], 0, function () {
            return this.millisecond() * 10000;
        });
        addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
            return this.millisecond() * 100000;
        });
        addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
            return this.millisecond() * 1000000;
        });

        // ALIASES

        addUnitAlias('millisecond', 'ms');

        // PRIORITY

        addUnitPriority('millisecond', 16);

        // PARSING

        addRegexToken('S', match1to3, match1);
        addRegexToken('SS', match1to3, match2);
        addRegexToken('SSS', match1to3, match3);

        var token, getSetMillisecond;
        for (token = 'SSSS'; token.length <= 9; token += 'S') {
            addRegexToken(token, matchUnsigned);
        }

        function parseMs(input, array) {
            array[MILLISECOND] = toInt(('0.' + input) * 1000);
        }

        for (token = 'S'; token.length <= 9; token += 'S') {
            addParseToken(token, parseMs);
        }

        getSetMillisecond = makeGetSet('Milliseconds', false);

        // FORMATTING

        addFormatToken('z', 0, 0, 'zoneAbbr');
        addFormatToken('zz', 0, 0, 'zoneName');

        // MOMENTS

        function getZoneAbbr() {
            return this._isUTC ? 'UTC' : '';
        }

        function getZoneName() {
            return this._isUTC ? 'Coordinated Universal Time' : '';
        }

        var proto = Moment.prototype;

        proto.add = add;
        proto.calendar = calendar$1;
        proto.clone = clone;
        proto.diff = diff;
        proto.endOf = endOf;
        proto.format = format;
        proto.from = from;
        proto.fromNow = fromNow;
        proto.to = to;
        proto.toNow = toNow;
        proto.get = stringGet;
        proto.invalidAt = invalidAt;
        proto.isAfter = isAfter;
        proto.isBefore = isBefore;
        proto.isBetween = isBetween;
        proto.isSame = isSame;
        proto.isSameOrAfter = isSameOrAfter;
        proto.isSameOrBefore = isSameOrBefore;
        proto.isValid = isValid$2;
        proto.lang = lang;
        proto.locale = locale;
        proto.localeData = localeData;
        proto.max = prototypeMax;
        proto.min = prototypeMin;
        proto.parsingFlags = parsingFlags;
        proto.set = stringSet;
        proto.startOf = startOf;
        proto.subtract = subtract;
        proto.toArray = toArray;
        proto.toObject = toObject;
        proto.toDate = toDate;
        proto.toISOString = toISOString;
        proto.inspect = inspect;
        if (typeof Symbol !== 'undefined' && Symbol.for != null) {
            proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
                return 'Moment<' + this.format() + '>';
            };
        }
        proto.toJSON = toJSON;
        proto.toString = toString;
        proto.unix = unix;
        proto.valueOf = valueOf;
        proto.creationData = creationData;
        proto.eraName = getEraName;
        proto.eraNarrow = getEraNarrow;
        proto.eraAbbr = getEraAbbr;
        proto.eraYear = getEraYear;
        proto.year = getSetYear;
        proto.isLeapYear = getIsLeapYear;
        proto.weekYear = getSetWeekYear;
        proto.isoWeekYear = getSetISOWeekYear;
        proto.quarter = proto.quarters = getSetQuarter;
        proto.month = getSetMonth;
        proto.daysInMonth = getDaysInMonth;
        proto.week = proto.weeks = getSetWeek;
        proto.isoWeek = proto.isoWeeks = getSetISOWeek;
        proto.weeksInYear = getWeeksInYear;
        proto.weeksInWeekYear = getWeeksInWeekYear;
        proto.isoWeeksInYear = getISOWeeksInYear;
        proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
        proto.date = getSetDayOfMonth;
        proto.day = proto.days = getSetDayOfWeek;
        proto.weekday = getSetLocaleDayOfWeek;
        proto.isoWeekday = getSetISODayOfWeek;
        proto.dayOfYear = getSetDayOfYear;
        proto.hour = proto.hours = getSetHour;
        proto.minute = proto.minutes = getSetMinute;
        proto.second = proto.seconds = getSetSecond;
        proto.millisecond = proto.milliseconds = getSetMillisecond;
        proto.utcOffset = getSetOffset;
        proto.utc = setOffsetToUTC;
        proto.local = setOffsetToLocal;
        proto.parseZone = setOffsetToParsedOffset;
        proto.hasAlignedHourOffset = hasAlignedHourOffset;
        proto.isDST = isDaylightSavingTime;
        proto.isLocal = isLocal;
        proto.isUtcOffset = isUtcOffset;
        proto.isUtc = isUtc;
        proto.isUTC = isUtc;
        proto.zoneAbbr = getZoneAbbr;
        proto.zoneName = getZoneName;
        proto.dates = deprecate(
            'dates accessor is deprecated. Use date instead.',
            getSetDayOfMonth
        );
        proto.months = deprecate(
            'months accessor is deprecated. Use month instead',
            getSetMonth
        );
        proto.years = deprecate(
            'years accessor is deprecated. Use year instead',
            getSetYear
        );
        proto.zone = deprecate(
            'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',
            getSetZone
        );
        proto.isDSTShifted = deprecate(
            'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',
            isDaylightSavingTimeShifted
        );

        function createUnix(input) {
            return createLocal(input * 1000);
        }

        function createInZone() {
            return createLocal.apply(null, arguments).parseZone();
        }

        function preParsePostFormat(string) {
            return string;
        }

        var proto$1 = Locale.prototype;

        proto$1.calendar = calendar;
        proto$1.longDateFormat = longDateFormat;
        proto$1.invalidDate = invalidDate;
        proto$1.ordinal = ordinal;
        proto$1.preparse = preParsePostFormat;
        proto$1.postformat = preParsePostFormat;
        proto$1.relativeTime = relativeTime;
        proto$1.pastFuture = pastFuture;
        proto$1.set = set;
        proto$1.eras = localeEras;
        proto$1.erasParse = localeErasParse;
        proto$1.erasConvertYear = localeErasConvertYear;
        proto$1.erasAbbrRegex = erasAbbrRegex;
        proto$1.erasNameRegex = erasNameRegex;
        proto$1.erasNarrowRegex = erasNarrowRegex;

        proto$1.months = localeMonths;
        proto$1.monthsShort = localeMonthsShort;
        proto$1.monthsParse = localeMonthsParse;
        proto$1.monthsRegex = monthsRegex;
        proto$1.monthsShortRegex = monthsShortRegex;
        proto$1.week = localeWeek;
        proto$1.firstDayOfYear = localeFirstDayOfYear;
        proto$1.firstDayOfWeek = localeFirstDayOfWeek;

        proto$1.weekdays = localeWeekdays;
        proto$1.weekdaysMin = localeWeekdaysMin;
        proto$1.weekdaysShort = localeWeekdaysShort;
        proto$1.weekdaysParse = localeWeekdaysParse;

        proto$1.weekdaysRegex = weekdaysRegex;
        proto$1.weekdaysShortRegex = weekdaysShortRegex;
        proto$1.weekdaysMinRegex = weekdaysMinRegex;

        proto$1.isPM = localeIsPM;
        proto$1.meridiem = localeMeridiem;

        function get$1(format, index, field, setter) {
            var locale = getLocale(),
                utc = createUTC().set(setter, index);
            return locale[field](utc, format);
        }

        function listMonthsImpl(format, index, field) {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';

            if (index != null) {
                return get$1(format, index, field, 'month');
            }

            var i,
                out = [];
            for (i = 0; i < 12; i++) {
                out[i] = get$1(format, i, field, 'month');
            }
            return out;
        }

        // ()
        // (5)
        // (fmt, 5)
        // (fmt)
        // (true)
        // (true, 5)
        // (true, fmt, 5)
        // (true, fmt)
        function listWeekdaysImpl(localeSorted, format, index, field) {
            if (typeof localeSorted === 'boolean') {
                if (isNumber(format)) {
                    index = format;
                    format = undefined;
                }

                format = format || '';
            } else {
                format = localeSorted;
                index = format;
                localeSorted = false;

                if (isNumber(format)) {
                    index = format;
                    format = undefined;
                }

                format = format || '';
            }

            var locale = getLocale(),
                shift = localeSorted ? locale._week.dow : 0,
                i,
                out = [];

            if (index != null) {
                return get$1(format, (index + shift) % 7, field, 'day');
            }

            for (i = 0; i < 7; i++) {
                out[i] = get$1(format, (i + shift) % 7, field, 'day');
            }
            return out;
        }

        function listMonths(format, index) {
            return listMonthsImpl(format, index, 'months');
        }

        function listMonthsShort(format, index) {
            return listMonthsImpl(format, index, 'monthsShort');
        }

        function listWeekdays(localeSorted, format, index) {
            return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
        }

        function listWeekdaysShort(localeSorted, format, index) {
            return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
        }

        function listWeekdaysMin(localeSorted, format, index) {
            return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
        }

        getSetGlobalLocale('en', {
            eras: [
                {
                    since: '0001-01-01',
                    until: +Infinity,
                    offset: 1,
                    name: 'Anno Domini',
                    narrow: 'AD',
                    abbr: 'AD',
                },
                {
                    since: '0000-12-31',
                    until: -Infinity,
                    offset: 1,
                    name: 'Before Christ',
                    narrow: 'BC',
                    abbr: 'BC',
                },
            ],
            dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
            ordinal: function (number) {
                var b = number % 10,
                    output =
                        toInt((number % 100) / 10) === 1
                            ? 'th'
                            : b === 1
                                ? 'st'
                                : b === 2
                                    ? 'nd'
                                    : b === 3
                                        ? 'rd'
                                        : 'th';
                return number + output;
            },
        });

        // Side effect imports

        hooks.lang = deprecate(
            'moment.lang is deprecated. Use moment.locale instead.',
            getSetGlobalLocale
        );
        hooks.langData = deprecate(
            'moment.langData is deprecated. Use moment.localeData instead.',
            getLocale
        );

        var mathAbs = Math.abs;

        function abs() {
            var data = this._data;

            this._milliseconds = mathAbs(this._milliseconds);
            this._days = mathAbs(this._days);
            this._months = mathAbs(this._months);

            data.milliseconds = mathAbs(data.milliseconds);
            data.seconds = mathAbs(data.seconds);
            data.minutes = mathAbs(data.minutes);
            data.hours = mathAbs(data.hours);
            data.months = mathAbs(data.months);
            data.years = mathAbs(data.years);

            return this;
        }

        function addSubtract$1(duration, input, value, direction) {
            var other = createDuration(input, value);

            duration._milliseconds += direction * other._milliseconds;
            duration._days += direction * other._days;
            duration._months += direction * other._months;

            return duration._bubble();
        }

        // supports only 2.0-style add(1, 's') or add(duration)
        function add$1(input, value) {
            return addSubtract$1(this, input, value, 1);
        }

        // supports only 2.0-style subtract(1, 's') or subtract(duration)
        function subtract$1(input, value) {
            return addSubtract$1(this, input, value, -1);
        }

        function absCeil(number) {
            if (number < 0) {
                return Math.floor(number);
            } else {
                return Math.ceil(number);
            }
        }

        function bubble() {
            var milliseconds = this._milliseconds,
                days = this._days,
                months = this._months,
                data = this._data,
                seconds,
                minutes,
                hours,
                years,
                monthsFromDays;

            // if we have a mix of positive and negative values, bubble down first
            // check: https://github.com/moment/moment/issues/2166
            if (
                !(
                    (milliseconds >= 0 && days >= 0 && months >= 0) ||
                    (milliseconds <= 0 && days <= 0 && months <= 0)
                )
            ) {
                milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
                days = 0;
                months = 0;
            }

            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;

            seconds = absFloor(milliseconds / 1000);
            data.seconds = seconds % 60;

            minutes = absFloor(seconds / 60);
            data.minutes = minutes % 60;

            hours = absFloor(minutes / 60);
            data.hours = hours % 24;

            days += absFloor(hours / 24);

            // convert days to months
            monthsFromDays = absFloor(daysToMonths(days));
            months += monthsFromDays;
            days -= absCeil(monthsToDays(monthsFromDays));

            // 12 months -> 1 year
            years = absFloor(months / 12);
            months %= 12;

            data.days = days;
            data.months = months;
            data.years = years;

            return this;
        }

        function daysToMonths(days) {
            // 400 years have 146097 days (taking into account leap year rules)
            // 400 years have 12 months === 4800
            return (days * 4800) / 146097;
        }

        function monthsToDays(months) {
            // the reverse of daysToMonths
            return (months * 146097) / 4800;
        }

        function as(units) {
            if (!this.isValid()) {
                return NaN;
            }
            var days,
                months,
                milliseconds = this._milliseconds;

            units = normalizeUnits(units);

            if (units === 'month' || units === 'quarter' || units === 'year') {
                days = this._days + milliseconds / 864e5;
                months = this._months + daysToMonths(days);
                switch (units) {
                    case 'month':
                        return months;
                    case 'quarter':
                        return months / 3;
                    case 'year':
                        return months / 12;
                }
            } else {
                // handle milliseconds separately because of floating point math errors (issue #1867)
                days = this._days + Math.round(monthsToDays(this._months));
                switch (units) {
                    case 'week':
                        return days / 7 + milliseconds / 6048e5;
                    case 'day':
                        return days + milliseconds / 864e5;
                    case 'hour':
                        return days * 24 + milliseconds / 36e5;
                    case 'minute':
                        return days * 1440 + milliseconds / 6e4;
                    case 'second':
                        return days * 86400 + milliseconds / 1000;
                    // Math.floor prevents floating point math errors here
                    case 'millisecond':
                        return Math.floor(days * 864e5) + milliseconds;
                    default:
                        throw new Error('Unknown unit ' + units);
                }
            }
        }

        // TODO: Use this.as('ms')?
        function valueOf$1() {
            if (!this.isValid()) {
                return NaN;
            }
            return (
                this._milliseconds +
                this._days * 864e5 +
                (this._months % 12) * 2592e6 +
                toInt(this._months / 12) * 31536e6
            );
        }

        function makeAs(alias) {
            return function () {
                return this.as(alias);
            };
        }

        var asMilliseconds = makeAs('ms'),
            asSeconds = makeAs('s'),
            asMinutes = makeAs('m'),
            asHours = makeAs('h'),
            asDays = makeAs('d'),
            asWeeks = makeAs('w'),
            asMonths = makeAs('M'),
            asQuarters = makeAs('Q'),
            asYears = makeAs('y');

        function clone$1() {
            return createDuration(this);
        }

        function get$2(units) {
            units = normalizeUnits(units);
            return this.isValid() ? this[units + 's']() : NaN;
        }

        function makeGetter(name) {
            return function () {
                return this.isValid() ? this._data[name] : NaN;
            };
        }

        var milliseconds = makeGetter('milliseconds'),
            seconds = makeGetter('seconds'),
            minutes = makeGetter('minutes'),
            hours = makeGetter('hours'),
            days = makeGetter('days'),
            months = makeGetter('months'),
            years = makeGetter('years');

        function weeks() {
            return absFloor(this.days() / 7);
        }

        var round = Math.round,
            thresholds = {
                ss: 44, // a few seconds to seconds
                s: 45, // seconds to minute
                m: 45, // minutes to hour
                h: 22, // hours to day
                d: 26, // days to month/week
                w: null, // weeks to month
                M: 11, // months to year
            };

        // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
        function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
            return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
        }

        function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
            var duration = createDuration(posNegDuration).abs(),
                seconds = round(duration.as('s')),
                minutes = round(duration.as('m')),
                hours = round(duration.as('h')),
                days = round(duration.as('d')),
                months = round(duration.as('M')),
                weeks = round(duration.as('w')),
                years = round(duration.as('y')),
                a =
                    (seconds <= thresholds.ss && ['s', seconds]) ||
                    (seconds < thresholds.s && ['ss', seconds]) ||
                    (minutes <= 1 && ['m']) ||
                    (minutes < thresholds.m && ['mm', minutes]) ||
                    (hours <= 1 && ['h']) ||
                    (hours < thresholds.h && ['hh', hours]) ||
                    (days <= 1 && ['d']) ||
                    (days < thresholds.d && ['dd', days]);

            if (thresholds.w != null) {
                a =
                    a ||
                    (weeks <= 1 && ['w']) ||
                    (weeks < thresholds.w && ['ww', weeks]);
            }
            a = a ||
                (months <= 1 && ['M']) ||
                (months < thresholds.M && ['MM', months]) ||
                (years <= 1 && ['y']) || ['yy', years];

            a[2] = withoutSuffix;
            a[3] = +posNegDuration > 0;
            a[4] = locale;
            return substituteTimeAgo.apply(null, a);
        }

        // This function allows you to set the rounding function for relative time strings
        function getSetRelativeTimeRounding(roundingFunction) {
            if (roundingFunction === undefined) {
                return round;
            }
            if (typeof roundingFunction === 'function') {
                round = roundingFunction;
                return true;
            }
            return false;
        }

        // This function allows you to set a threshold for relative time strings
        function getSetRelativeTimeThreshold(threshold, limit) {
            if (thresholds[threshold] === undefined) {
                return false;
            }
            if (limit === undefined) {
                return thresholds[threshold];
            }
            thresholds[threshold] = limit;
            if (threshold === 's') {
                thresholds.ss = limit - 1;
            }
            return true;
        }

        function humanize(argWithSuffix, argThresholds) {
            if (!this.isValid()) {
                return this.localeData().invalidDate();
            }

            var withSuffix = false,
                th = thresholds,
                locale,
                output;

            if (typeof argWithSuffix === 'object') {
                argThresholds = argWithSuffix;
                argWithSuffix = false;
            }
            if (typeof argWithSuffix === 'boolean') {
                withSuffix = argWithSuffix;
            }
            if (typeof argThresholds === 'object') {
                th = Object.assign({}, thresholds, argThresholds);
                if (argThresholds.s != null && argThresholds.ss == null) {
                    th.ss = argThresholds.s - 1;
                }
            }

            locale = this.localeData();
            output = relativeTime$1(this, !withSuffix, th, locale);

            if (withSuffix) {
                output = locale.pastFuture(+this, output);
            }

            return locale.postformat(output);
        }

        var abs$1 = Math.abs;

        function sign(x) {
            return (x > 0) - (x < 0) || +x;
        }

        function toISOString$1() {
            // for ISO strings we do not use the normal bubbling rules:
            //  * milliseconds bubble up until they become hours
            //  * days do not bubble at all
            //  * months bubble up until they become years
            // This is because there is no context-free conversion between hours and days
            // (think of clock changes)
            // and also not between days and months (28-31 days per month)
            if (!this.isValid()) {
                return this.localeData().invalidDate();
            }

            var seconds = abs$1(this._milliseconds) / 1000,
                days = abs$1(this._days),
                months = abs$1(this._months),
                minutes,
                hours,
                years,
                s,
                total = this.asSeconds(),
                totalSign,
                ymSign,
                daysSign,
                hmsSign;

            if (!total) {
                // this is the same as C#'s (Noda) and python (isodate)...
                // but not other JS (goog.date)
                return 'P0D';
            }

            // 3600 seconds -> 60 minutes -> 1 hour
            minutes = absFloor(seconds / 60);
            hours = absFloor(minutes / 60);
            seconds %= 60;
            minutes %= 60;

            // 12 months -> 1 year
            years = absFloor(months / 12);
            months %= 12;

            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';

            totalSign = total < 0 ? '-' : '';
            ymSign = sign(this._months) !== sign(total) ? '-' : '';
            daysSign = sign(this._days) !== sign(total) ? '-' : '';
            hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

            return (
                totalSign +
                'P' +
                (years ? ymSign + years + 'Y' : '') +
                (months ? ymSign + months + 'M' : '') +
                (days ? daysSign + days + 'D' : '') +
                (hours || minutes || seconds ? 'T' : '') +
                (hours ? hmsSign + hours + 'H' : '') +
                (minutes ? hmsSign + minutes + 'M' : '') +
                (seconds ? hmsSign + s + 'S' : '')
            );
        }

        var proto$2 = Duration.prototype;

        proto$2.isValid = isValid$1;
        proto$2.abs = abs;
        proto$2.add = add$1;
        proto$2.subtract = subtract$1;
        proto$2.as = as;
        proto$2.asMilliseconds = asMilliseconds;
        proto$2.asSeconds = asSeconds;
        proto$2.asMinutes = asMinutes;
        proto$2.asHours = asHours;
        proto$2.asDays = asDays;
        proto$2.asWeeks = asWeeks;
        proto$2.asMonths = asMonths;
        proto$2.asQuarters = asQuarters;
        proto$2.asYears = asYears;
        proto$2.valueOf = valueOf$1;
        proto$2._bubble = bubble;
        proto$2.clone = clone$1;
        proto$2.get = get$2;
        proto$2.milliseconds = milliseconds;
        proto$2.seconds = seconds;
        proto$2.minutes = minutes;
        proto$2.hours = hours;
        proto$2.days = days;
        proto$2.weeks = weeks;
        proto$2.months = months;
        proto$2.years = years;
        proto$2.humanize = humanize;
        proto$2.toISOString = toISOString$1;
        proto$2.toString = toISOString$1;
        proto$2.toJSON = toISOString$1;
        proto$2.locale = locale;
        proto$2.localeData = localeData;

        proto$2.toIsoString = deprecate(
            'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',
            toISOString$1
        );
        proto$2.lang = lang;

        // FORMATTING

        addFormatToken('X', 0, 0, 'unix');
        addFormatToken('x', 0, 0, 'valueOf');

        // PARSING

        addRegexToken('x', matchSigned);
        addRegexToken('X', matchTimestamp);
        addParseToken('X', function (input, array, config) {
            config._d = new Date(parseFloat(input) * 1000);
        });
        addParseToken('x', function (input, array, config) {
            config._d = new Date(toInt(input));
        });

        //! moment.js

        hooks.version = '2.29.1';

        setHookCallback(createLocal);

        hooks.fn = proto;
        hooks.min = min;
        hooks.max = max;
        hooks.now = now;
        hooks.utc = createUTC;
        hooks.unix = createUnix;
        hooks.months = listMonths;
        hooks.isDate = isDate;
        hooks.locale = getSetGlobalLocale;
        hooks.invalid = createInvalid;
        hooks.duration = createDuration;
        hooks.isMoment = isMoment;
        hooks.weekdays = listWeekdays;
        hooks.parseZone = createInZone;
        hooks.localeData = getLocale;
        hooks.isDuration = isDuration;
        hooks.monthsShort = listMonthsShort;
        hooks.weekdaysMin = listWeekdaysMin;
        hooks.defineLocale = defineLocale;
        hooks.updateLocale = updateLocale;
        hooks.locales = listLocales;
        hooks.weekdaysShort = listWeekdaysShort;
        hooks.normalizeUnits = normalizeUnits;
        hooks.relativeTimeRounding = getSetRelativeTimeRounding;
        hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
        hooks.calendarFormat = getCalendarFormat;
        hooks.prototype = proto;

        // currently HTML5 input type only supports 24-hour formats
        hooks.HTML5_FMT = {
            DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm', // <input type="datetime-local" />
            DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss', // <input type="datetime-local" step="1" />
            DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS', // <input type="datetime-local" step="0.001" />
            DATE: 'YYYY-MM-DD', // <input type="date" />
            TIME: 'HH:mm', // <input type="time" />
            TIME_SECONDS: 'HH:mm:ss', // <input type="time" step="1" />
            TIME_MS: 'HH:mm:ss.SSS', // <input type="time" step="0.001" />
            WEEK: 'GGGG-[W]WW', // <input type="week" />
            MONTH: 'YYYY-MM', // <input type="month" />
        };

        return hooks;

    })));
});

var lib = (joi) => ({

    name: 'date',

    base: joi.date(),

    language: {
        format: 'must be a string with one of the following formats {{format}}'
    },

    coerce(value, state, options) {

        if (!value ||
            value instanceof Date ||
            typeof value === 'number') {

            return value;
        }

        if (this._flags.momentFormat &&
            options.convert) {

            const date = this._flags.utc
                ? moment$1.utc(value, this._flags.momentFormat, true)
                : moment$1(value, this._flags.momentFormat, true);

            if (date.isValid()) {
                return date.toDate();
            }

            return this.createError('date.format', { value, format: this._flags.momentFormat }, state, options);
        }

        return value;
    },

    rules: [
        {
            name: 'format',
            description(params) {

                return `Date should respect format ${params.format}`;
            },
            params: {
                format: joi.array().items(joi.string()).single().required()
            },
            setup(params) {

                this._flags.momentFormat = params.format;
            },
            validate(params, value, state, options) {

                // No-op just to enable description
                return value;
            }
        },
        {
            name: 'utc',
            description(params) {

                return 'Date should be interpreted in UTC';
            },
            setup(params) {

                this._flags.utc = true;
            },
            validate(params, value, state, options) {

                // No-op just to enable description
                return value;
            }
        }
    ]
});

const Joi = BaseJoi.extend(lib);

function message(str) {
    return { message: str };
}

function clearError(state, prop) {
    state.errors[prop] = "";
}

function errorCount(state) {
    return Object.keys(state.errors).reduce(
        (acc, k) => (!state.errors[k] ? acc : acc + 1),
        0
    );
}

const detailsScheme = Joi.object().keys({
    address: Joi.string()
        .required()
        .error((_) => message(t(" "))),
    time: Joi.date()
        .format("H:mm")
        .required()
        .error((_) => message(t(" "))),
    date: Joi.date()
        .format("DD.MM.YYYY")
        .max("now")
        .required()
        .error((_) => message(t(" "))),
    district: Joi.object()
        .required()
        .keys({
            id: Joi.string().required(),
        })
        .error((_) => message(t(" "))),
    area: Joi.object()
        .required()
        .keys({
            id: Joi.string().required(),
        })
        .error((_) => message(t(" "))),
    coords: Joi.array()
        .required()
        .items(Joi.number().required().min(0), Joi.number().required().min(0))
        .error((_) => message(t("  "))),
});

const offenseScheme = Joi.object().keys({
    vehicleId: Joi.string()
        .required()
        .error((_) => message(t("  "))),
    valid: Joi.boolean()
        .invalid(false)
        .required()
        .error((_) => message(t("   "))),
    testimony: Joi.when("type", {
        is: Joi.object().keys({
            show_details: Joi.boolean().valid(true),
        }),
        then: Joi.string()
            .required()
            .error((_) => message(t(" "))),
    }),
    typeId: Joi.number()
        .required()
        .error((_) => message(t("  "))),
    citizenArticleId: Joi.number()
        .optional()
        .error((_) => message(t(" "))),
});

const rewardScheme = Joi.object().keys({
    type: Joi.string()
        .required()
        .valid(...Object.keys(window.rewardTypes)),
    phone: Joi.when("type", {
        is: Joi.string().valid("phone"),
        then: Joi.string().required(),
    }).error((_) => message(t("  "))),

    bank: Joi.when("type", {
        is: Joi.string().valid("bank"),
        then: Joi.string().required(),
    }).error((_) => message(t(" "))),

    phoneValid: Joi.boolean()
        .when("type", {
            is: Joi.string().valid("phone"),
            then: Joi.invalid(false).required(),
        })
        .error((_) => message(t("   "))),

    fund: Joi.when("type", {
        is: Joi.string().valid("fund"),
        then: Joi.string().required(),
    }).error((_) => message(t(" "))),
});

const offenseListScheme = Joi.array().items(offenseScheme);

function validator(scheme) {
    return {
        async validateList({ state, commit }) {
            let errors = {};
            try {
                await Joi.validate(state.list, scheme, {
                    abortEarly: false,
                    allowUnknown: true,
                });
            } catch (err) {
                if (err) {
                    for (let i = 0; i < err.details.length; i++) {
                        let [index, key] = err.details[i].path;
                        if (!errors[index]) errors[index] = {};
                        errors[index][key] = err.details[i].message;
                    }
                }
            }
            commit("updateErrors", errors);
            return Object.keys(errors).length === 0;
        },

        async validate({ state, commit }) {
            let errors = {};
            try {
                await Joi.validate(state, scheme, {
                    abortEarly: false,
                    allowUnknown: true,
                });
            } catch (err) {
                if (err) {
                    errors = err.details.reduce((acc, e) => {
                        return { ...acc, [e.path[0]]: e.message };
                    }, {});
                }
            }
            commit("updateErrors", errors);
            return Object.keys(errors).length === 0;
        },
    };
}

const actions$3 = {
    ...validator(detailsScheme)
};

const state$2 = {
    now: moment(),
    time: '',
    date: '',
    area: {},
    address: null,
    district: {},
    coords: [41.2995, 69.2401],
    errors: {
        time: '',
        date: '',
        area: '',
        address: '',
        district: '',
        coords: '',
    }
};


const getters$3 = {
    errorCount,
    yAddress(state) {
        let str = '';
        if (state.area && state.area.name)
            str += state.area.name;
        if (state.district && state.district.name)
            str += ', ' + state.district.name;
        if (state.address)
            str += ', ' + state.address;
        return str;
    },
};


const mutations$2 = {
    updateDetails(state, details) {
    },

    refreshNow(){
        state$2.now = moment();
    },

    updateErrors(state, errors) {
        state.errors = errors;
    },

    updateDate(state, date) {
        state.date = date;
        clearError(state, 'date');
    },

    updateTime(state, time) {
        state.time = time;
        clearError(state, 'time');
    },

    updateAddress(state, address) {
        state.address = address;
        clearError(state, 'address');
    },

    updateArea(state, area) {
        state.district = null;
        state.area = area;
        clearError(state, 'area');
    },

    updateDistrict(state, district) {
        state.district = district;
        if (district)
            clearError(state, 'district');

    },

    updateCoords(state, coords) {
        state.coords = coords;
        clearError(state, 'coords');
    },

};


var details = {
    namespaced: true,
    state: state$2,
    actions: actions$3,
    getters: getters$3,
    mutations: mutations$2
};

function uid() {
    return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (c) =>
        (
            c ^
            (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))
        ).toString(16)
    );
}

const state$1 = {
    list: [
        {
            vehicleId: undefined,
            citizenArticleId: undefined,
            valid: false,
            removable: false,
            key: uid(),
            errors: {
                vehicleId: "",
                citizenArticleId: "",
                typeId: "",
            },
        },
    ],
};

const getters$2 = {
    errorCount(state) {
        let count = 0;
        state.list.forEach(function (offense) {
            let errors = { ...offense.errors };
            if (!errors.vehicleId) errors.vehicleId = offense.errors.valid;
            errors.valid = "";
            count += errorCount({ errors });
        });
        return count;
    },
};

const actions$2 = {
    ...validator(offenseListScheme),
};

const mutations$1 = {
    addOffense(state) {
        state.list = [
            ...state.list,
            {
                vehicleId: undefined,
                removable: true,
                key: uid(),
                errors: {
                    vehicleId: "",
                    typeId: "",
                },
            },
        ];
    },

    removeOffense(state, key) {
        state.list = state.list.filter((o) => o.key !== key);
    },

    updateVehicleId(state, { index, vehicleId }) {
        state.list[index].vehicleId = vehicleId;
        clearError(state.list[index], "vehicleId");
    },

    updateValidFlag(state, { index, valid }) {
        state.list[index].valid = valid;
        clearError(state.list[index], "valid");
    },

    updateTestimony(state, { index, testimony }) {
        state.list[index].testimony = testimony;
        clearError(state.list[index], "testimony");
    },

    updateArticleId(state, { index, articleId }) {
        state.list[index].citizenArticleId = articleId;
        clearError(state.list[index], "citizenArticleId");
    },

    updateType(state, { index, type }) {
        const offense = state.list[index];
        offense.type = type;
        offense.typeId = type.id;
        clearError(offense, "typeId");
        clearError(offense, "type");
    },

    updateErrors(state, errors) {
        state.list = state.list.map((o, i) => ({
            ...o,
            errors: errors[i] || { vehicleId: "", typeId: "" },
        }));
    },
};

var offenses = {
    namespaced: true,
    state: state$1,
    getters: getters$2,
    actions: actions$2,
    mutations: mutations$1,
};

const actions$1 = {
    ...validator(rewardScheme),
    async sendCardNumber(_, card) {
        let result;
        let data = new FormData();
        data.set("card", card);
        try {
            result = (
                await axios.post("/verify-card", data, {
                    headers: {
                        "Content-Type": "application/x-www-form-urlencoded",
                        "x-csrf-token": window.csrf,
                    },
                })
            ).data;
        } catch (e) {
            result = e.response;
        }
        return result;
    },
};

const state = {
    card: {
        error: " ",
        number: "",
        owner: "",
        bank: "",
    },
    fund: "",
    phone: "",
    bank: "",
    type: "phone",
    phoneValid: false,
    errors: {
        type: "",
        phone: "",
        valid: "",
        card: "",
    },
};

const mutations = {
    updateBank(state, bank) {
        state.bank = bank;
        clearError(state, "bank");
    },

    updatePhone(state, phone) {
        state.phone = phone;
        clearError(state, "phone");
    },

    updateType(state, type) {
        state.type = type;
        state.valid = false;
        clearError(state, "type");
    },

    updateFund(state, fund) {
        state.fund = fund;
        clearError(state, "fund");
    },

    updatePhoneValidFlag(state, save) {
        state.phoneValid = save;
    },

    updateErrors(state, errors) {
        state.errors = errors;
    },
};

const getters$1 = {
    errorCount(state) {
        let errors = { ...state.errors };
        if (!errors.phone) errors.phone = errors.valid;
        errors.valid = "";
        return errorCount({ errors });
    },
};
var reward = {
    namespaced: true,
    state,
    getters: getters$1,
    actions: actions$1,
    mutations,
};

function reset(state) {
    state.error = '';
    state.id = null;
    state.url = null;
    state.width = null;
    state.height = null;
    state.duration = null;
    state.filename = null;
    state.filetype = null;
    state.filesize = null;
    state.status = 'initial';
    state.uploadProgress = 0;
    state.cancelSource.cancel();
    state.cancelSource = axios.CancelToken.source();
}

function create() {
    const state = {
        id: null,
        url: null,
        type: null,
        width: null,
        height: null,
        filename: null,
        filesize: null,
        duration: null,
        downloadUrl: null,
        uploadProgress: 0,
        lastUploadUpdate: null,
        status: 'initial',
        cancelSource: axios.CancelToken.source(),
        error: ''
    };

    const getters = {
        errorCount(state) {
            if (state.error)
                return 1;
            else return 0
        },
    };


    const actions = {

        async uploadVideo({state, commit, dispatch}, file) {
            commit('updateError', '');
            commit('updateStatus', 'uploading');
            commit('updateFile', file);
            let formData = new FormData();
            let isCanceled = false;
            formData.append('video', file);
            let result;
            try {
                result = await axios.post('/api/citizen/report/video',
                    formData,
                    {
                        headers: {'Content-Type': 'multipart/form-data'},
                        onUploadProgress: progressEvent => {
                            return commit('updateProgress', progressEvent.loaded)
                        },
                        cancelToken: state.cancelSource.token
                    }
                );
                commit('updateStatus', 'uploaded');
            } catch (e) {
                result = e.response;
                isCanceled = axios.isCancel(e);
            }

            if (isCanceled) return;

            if (result && result.status) { // if not network error
                if (result.status === 200) {
                    commit('updateStatus', 'uploaded');
                    commit('finishUpload', result.data);
                    dispatch('showNotification', {text: t(' ')}, {root: true});
                } else {
                    commit('reset');
                    commit('updateError', Object.values(result.data.errors.video).filter(e => e).join(', '));
                }
            } else {
                commit('reset');
                commit('updateError', ":  ");
                dispatch('showNotification', {text: t(" ,  "), type: "danger"}, {root: true});
            }
        }
    };

    const mutations = {
        updateVideo(state, video) {
            state.duration = video.duration;
            state.height = video.videoHeight;
            state.width = video.videoWidth;
            state.error = '';
        },

        updateError(state, error) {
            state.error = error;
        },

        updateFile(state, {size, name, type}) {
            state.filename = name;
            state.filesize = size;
            state.filetype = type;
        },

        updateStatus(state, status) {
            state.status = status;
        },

        finishUpload(state, {id, url, 'download-url': download_url}) {
            state.id = id;
            state.url = url;
            state.downloadUrl = download_url;
        },

        updateProgress(state, progress) {
            state.uploadProgress = progress;
        },

        updateType(state, type) {
            state.type = type;
        },

        reset,
    };


    return {
        namespaced: true,
        state,
        getters,
        actions,
        mutations
    }
}

const isObject = (obj) => {
    return obj === Object(obj);
};

const prettyError = (error) => {
    return error && error.filter((e) => e).join(", ");
};

function coerceOffenseErrors(errors) {
    let offenseErrors = {};
    for (let key in errors.offenses) {
        if (errors.offenses.hasOwnProperty(key)) {
            const o = errors.offenses[key];
            offenseErrors[key] = {
                vehicleId: prettyError(o.vehicle_id),
                typeId: prettyError(o.type_id),
                testimony: prettyError(o.testimony),
                citizenArticleId: prettyError(o.citizenArticleId),
            };
        }
    }
    return offenseErrors;
}

function coerceRewardErrors(params) {
    if (isObject(params)) {
        return {
            type: "",
            phone: prettyError(params && params.phone),
            card: prettyError(params && params.card),
            fund: prettyError(params && params.fund),
            bank: prettyError(params && params.bank),
        };
    } else {
        return {
            type: prettyError(params),
            phone: "",
            card: "",
            fund: "",
            bank: "",
        };
    }
}

function coerceDetailsErrors({
                                 incident_time,
                                 incident_date,
                                 area_id,
                                 address,
                                 lat,
                                 lng,
                                 district_id,
                             }) {
    return {
        time: prettyError(incident_time),
        date: prettyError(incident_date),
        area: prettyError(area_id),
        address: prettyError(address),
        district: prettyError(district_id),
        coords: prettyError([...(lat || []), ...(lng || [])]),
    };
}

const getters = {
    errorCount(state, getters) {
        return Object.keys(state).reduce(
            (acc, name) => acc + (getters[name + "/errorCount"] || 0),
            0
        );
    },
};

const actions = {
    updateErrors({ commit }, errors) {
        commit("offenses/updateErrors", coerceOffenseErrors(errors));
        commit("reward/updateErrors", coerceRewardErrors(errors.reward_params));

        const detailsErrors = coerceDetailsErrors(errors);

        if (detailsErrors.date) {
            commit("details/refreshNow");
            commit("details/updateDate");
        }
        commit("details/updateErrors", detailsErrors);

        if (errors.video_id) {
            commit("video/reset");
            commit("video/updateError", prettyError(errors.video_id));
        }
        if (errors.extra_video_id) {
            commit("extraVideo/reset");
            commit(
                "extraVideo/updateError",
                prettyError([
                    ...(errors.extra_video_id || []),
                    ...(errors.extra_video_type || []),
                ])
            );
        }
    },

    showNotification(_, { text, type }) {
        $.notify(
            {
                message: text,
            },
            {
                animate: {
                    enter: "animated fadeInUp",
                    exit: "animated fadeOut",
                },
                type: type || "success",
                spacing: 10,
                offset: {
                    y: 20,
                },
                allow_dismiss: false,
                newest_on_top: false,
                placement: {
                    from: "bottom",
                    align: "center",
                },
                delay: 500,
                duration: 3000,
                onShow: function () {
                    this.css({ width: "20rem" });
                },
            }
        );
    },

    async validate({ dispatch, state }) {
        Object.keys(state).forEach((k) => {
            if (state[k].list) dispatch(k + "/validateList");
            else dispatch(k + "/validate");
        });
    },

    async sendReport({ dispatch, state, commit, getters }) {
        const { offenses, video, reward, details, extraVideo } = state;
        let result;
        await dispatch("validate");

        if (video.status === "uploading" || extraVideo.status === "uploading") {
            dispatch("showNotification", {
                text: t("   "),
                type: "warning",
            });
            return;
        }

        if (getters["errorCount"] > 0) {
            dispatch("showNotification", {
                text: t(" "),
                type: "danger",
            });
            return;
        }

        const withExtraVideo =
            state.withExtraVideo && extraVideo.status !== "initial";

        let data = {
            offenses: offenses.list
                .map((o) => ({
                    vehicle_id: o.vehicleId,
                    citizen_article_id: o.citizenArticleId,
                    type_id: o.typeId,
                    testimony: o.testimony,
                }))
                .reduce((acc, v, i) => ({ ...acc, [i]: v }), {}),
            video_id: video.id,
            lat: details.coords[0],
            lng: details.coords[1],
            address: details.address,
            incident_date: details.date && details.date.format("DD.MM.YYYY"),
            incident_time: details.time,
            area_id: details.area && details.area.id,
            district_id: details.district && details.district.id,
            with_extra_video: withExtraVideo,
        };

        if (withExtraVideo) {
            data.extra_video_id = extraVideo.id;
            data.extra_video_type = extraVideo.type;
        }
        if (reward.type === "phone") data.reward_params = { phone: reward.phone };
        else if (reward.type === "fund") data.reward_params = { fund: reward.fund };
        else if (reward.type === "card") {
            data.reward_params = { card: true };
        } else if (reward.type === "bank")
            data.reward_params = { bank: reward.bank };
        else if (reward.type === "no-reward")
            data.reward_params = { "no-reward": true };

        try {
            result = await axios.post("/api/citizen/reports", data);
        } catch (e) {
            result = e.response;
        }
        if (result && result.status) {
            // if not network error
            if (result.status === 200) {
                window.open(result.data.redirect, "_self");
            } else if (result.status === 400) {
                commit("reset");
                dispatch("updateErrors", result.data.errors);
                dispatch("showNotification", {
                    text: t(" "),
                    type: "danger",
                });
            }
        } else {
            dispatch("showNotification", {
                text: t(" ,  "),
                type: "danger",
            });
        }
    },
};

Vue$1.use(index);
var store = new index.Store({
    state: {
        withExtraVideo: false,
    },

    mutations: {
        updateWithExtraVideo(state, flag) {
            state.withExtraVideo = flag;
        },
    },
    getters,
    actions,
    modules: {
        reward,
        details,
        extraVideo: create(),
        video: create(),
        offenses,
    },
});

var mixins = {
    filters: {
        t: function (value) {
            return t(value);
        },
        tget: function (value, prop) {
            return value[`${prop}_${window.locale}`];
        },
        moment: window.moment,

        localDateFormat(date) {
            return t("%s ", date.format(`dddd, D MMMM YYYY`));
        },

        humanFileSize(bytes) {
            if (bytes) {
                let thresh = 1024;
                if (Math.abs(bytes) < thresh) {
                    return bytes + " Bytes";
                }
                const units = [
                    "KBytes",
                    "MBytes",
                    "GBytes",
                    "TBytes",
                    "PBytes",
                    "EBytes",
                    "ZBytes",
                    "YBytes",
                ];
                let u = -1;
                do {
                    bytes /= thresh;
                    ++u;
                } while (Math.abs(bytes) >= thresh && u < units.length - 1);
                return bytes.toFixed(1) + " " + units[u];
            } else {
                return 0 + " Bytes";
            }
        },

        humanRemainingTime(seconds) {
            const mins = Math.round(seconds / 60);
            const hours = Math.round(seconds / 3600);
            if (isFinite(seconds)) {
                if (seconds < 60) {
                    return `${seconds} ${t(".")}`;
                } else if (mins < 60) {
                    return `${Math.round(seconds / 60)} ${"."}`;
                } else {
                    return `${hours} ${"."}`;
                }
            } else return t("");
        },

        prettyError,

        lowerFirstLetter(str) {
            return str.charAt(0).toLowerCase() + str.slice(1);
        },
    },
    methods: {
        debug: console.log,
        t: t,
    },
};

var autosize = createCommonjsModule(function (module, exports) {
    /*!
	autosize 4.0.2
	license: MIT
	http://www.jacklmoore.com/autosize
*/
    (function (global, factory) {
        {
            factory(module, exports);
        }
    })(commonjsGlobal, function (module, exports) {

        var map = typeof Map === "function" ? new Map() : function () {
            var keys = [];
            var values = [];

            return {
                has: function has(key) {
                    return keys.indexOf(key) > -1;
                },
                get: function get(key) {
                    return values[keys.indexOf(key)];
                },
                set: function set(key, value) {
                    if (keys.indexOf(key) === -1) {
                        keys.push(key);
                        values.push(value);
                    }
                },
                delete: function _delete(key) {
                    var index = keys.indexOf(key);
                    if (index > -1) {
                        keys.splice(index, 1);
                        values.splice(index, 1);
                    }
                }
            };
        }();

        var createEvent = function createEvent(name) {
            return new Event(name, { bubbles: true });
        };
        try {
            new Event('test');
        } catch (e) {
            // IE does not support `new Event()`
            createEvent = function createEvent(name) {
                var evt = document.createEvent('Event');
                evt.initEvent(name, true, false);
                return evt;
            };
        }

        function assign(ta) {
            if (!ta || !ta.nodeName || ta.nodeName !== 'TEXTAREA' || map.has(ta)) return;

            var heightOffset = null;
            var clientWidth = null;
            var cachedHeight = null;

            function init() {
                var style = window.getComputedStyle(ta, null);

                if (style.resize === 'vertical') {
                    ta.style.resize = 'none';
                } else if (style.resize === 'both') {
                    ta.style.resize = 'horizontal';
                }

                if (style.boxSizing === 'content-box') {
                    heightOffset = -(parseFloat(style.paddingTop) + parseFloat(style.paddingBottom));
                } else {
                    heightOffset = parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
                }
                // Fix when a textarea is not on document body and heightOffset is Not a Number
                if (isNaN(heightOffset)) {
                    heightOffset = 0;
                }

                update();
            }

            function changeOverflow(value) {
                {
                    // Chrome/Safari-specific fix:
                    // When the textarea y-overflow is hidden, Chrome/Safari do not reflow the text to account for the space
                    // made available by removing the scrollbar. The following forces the necessary text reflow.
                    var width = ta.style.width;
                    ta.style.width = '0px';
                    // Force reflow:
                    /* jshint ignore:start */
                    ta.offsetWidth;
                    /* jshint ignore:end */
                    ta.style.width = width;
                }

                ta.style.overflowY = value;
            }

            function getParentOverflows(el) {
                var arr = [];

                while (el && el.parentNode && el.parentNode instanceof Element) {
                    if (el.parentNode.scrollTop) {
                        arr.push({
                            node: el.parentNode,
                            scrollTop: el.parentNode.scrollTop
                        });
                    }
                    el = el.parentNode;
                }

                return arr;
            }

            function resize() {
                if (ta.scrollHeight === 0) {
                    // If the scrollHeight is 0, then the element probably has display:none or is detached from the DOM.
                    return;
                }

                var overflows = getParentOverflows(ta);
                var docTop = document.documentElement && document.documentElement.scrollTop; // Needed for Mobile IE (ticket #240)

                ta.style.height = '';
                ta.style.height = ta.scrollHeight + heightOffset + 'px';

                // used to check if an update is actually necessary on window.resize
                clientWidth = ta.clientWidth;

                // prevents scroll-position jumping
                overflows.forEach(function (el) {
                    el.node.scrollTop = el.scrollTop;
                });

                if (docTop) {
                    document.documentElement.scrollTop = docTop;
                }
            }

            function update() {
                resize();

                var styleHeight = Math.round(parseFloat(ta.style.height));
                var computed = window.getComputedStyle(ta, null);

                // Using offsetHeight as a replacement for computed.height in IE, because IE does not account use of border-box
                var actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(computed.height)) : ta.offsetHeight;

                // The actual height not matching the style height (set via the resize method) indicates that
                // the max-height has been exceeded, in which case the overflow should be allowed.
                if (actualHeight < styleHeight) {
                    if (computed.overflowY === 'hidden') {
                        changeOverflow('scroll');
                        resize();
                        actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
                    }
                } else {
                    // Normally keep overflow set to hidden, to avoid flash of scrollbar as the textarea expands.
                    if (computed.overflowY !== 'hidden') {
                        changeOverflow('hidden');
                        resize();
                        actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
                    }
                }

                if (cachedHeight !== actualHeight) {
                    cachedHeight = actualHeight;
                    var evt = createEvent('autosize:resized');
                    try {
                        ta.dispatchEvent(evt);
                    } catch (err) {
                        // Firefox will throw an error on dispatchEvent for a detached element
                        // https://bugzilla.mozilla.org/show_bug.cgi?id=889376
                    }
                }
            }

            var pageResize = function pageResize() {
                if (ta.clientWidth !== clientWidth) {
                    update();
                }
            };

            var destroy = function (style) {
                window.removeEventListener('resize', pageResize, false);
                ta.removeEventListener('input', update, false);
                ta.removeEventListener('keyup', update, false);
                ta.removeEventListener('autosize:destroy', destroy, false);
                ta.removeEventListener('autosize:update', update, false);

                Object.keys(style).forEach(function (key) {
                    ta.style[key] = style[key];
                });

                map.delete(ta);
            }.bind(ta, {
                height: ta.style.height,
                resize: ta.style.resize,
                overflowY: ta.style.overflowY,
                overflowX: ta.style.overflowX,
                wordWrap: ta.style.wordWrap
            });

            ta.addEventListener('autosize:destroy', destroy, false);

            // IE9 does not fire onpropertychange or oninput for deletions,
            // so binding to onkeyup to catch most of those events.
            // There is no way that I know of to detect something like 'cut' in IE9.
            if ('onpropertychange' in ta && 'oninput' in ta) {
                ta.addEventListener('keyup', update, false);
            }

            window.addEventListener('resize', pageResize, false);
            ta.addEventListener('input', update, false);
            ta.addEventListener('autosize:update', update, false);
            ta.style.overflowX = 'hidden';
            ta.style.wordWrap = 'break-word';

            map.set(ta, {
                destroy: destroy,
                update: update
            });

            init();
        }

        function destroy(ta) {
            var methods = map.get(ta);
            if (methods) {
                methods.destroy();
            }
        }

        function update(ta) {
            var methods = map.get(ta);
            if (methods) {
                methods.update();
            }
        }

        var autosize = null;

        // Do nothing in Node.js environment and IE8 (or lower)
        if (typeof window === 'undefined' || typeof window.getComputedStyle !== 'function') {
            autosize = function autosize(el) {
                return el;
            };
            autosize.destroy = function (el) {
                return el;
            };
            autosize.update = function (el) {
                return el;
            };
        } else {
            autosize = function autosize(el, options) {
                if (el) {
                    Array.prototype.forEach.call(el.length ? el : [el], function (x) {
                        return assign(x);
                    });
                }
                return el;
            };
            autosize.destroy = function (el) {
                if (el) {
                    Array.prototype.forEach.call(el.length ? el : [el], destroy);
                }
                return el;
            };
            autosize.update = function (el) {
                if (el) {
                    Array.prototype.forEach.call(el.length ? el : [el], update);
                }
                return el;
            };
        }

        exports.default = autosize;
        module.exports = exports['default'];
    });
});

let GHOST_ELEMENT_ID = '__autosizeInputGhost';

let characterEntities = {
    ' ': 'nbsp',
    '<': 'lt',
    '>': 'gt'
};

function mapSpecialCharacterToCharacterEntity(specialCharacter) {
    return '&' + characterEntities[specialCharacter] + ';'
}

function escapeSpecialCharacters(string) {
    return string.replace(/\s|<|>/g, mapSpecialCharacterToCharacterEntity)
}

// Create `ghostElement`, with inline styles to hide it and ensure that the text is all
// on a single line.
function createGhostElement() {
    let ghostElement = document.createElement('div');
    ghostElement.id = GHOST_ELEMENT_ID;
    ghostElement.style.cssText =
        'display:inline-block;height:0;overflow:hidden;position:absolute;top:0;visibility:hidden;white-space:nowrap;';
    document.body.appendChild(ghostElement);
    return ghostElement
}

const autoSizeInput = function (element, options) {
    // Assigns an appropriate width to the given `element` based on its contents.
    function setWidth() {
        let elementStyle = window.getComputedStyle(element);
        // prettier-ignore
        let elementCssText = 'box-sizing:' + elementStyle.boxSizing +
            ';border-left:' + elementStyle.borderLeftWidth + ' solid red' +
            ';border-right:' + elementStyle.borderRightWidth + ' solid red' +
            ';font-family:' + elementStyle.fontFamily +
            ';font-feature-settings:' + elementStyle.fontFeatureSettings +
            ';font-kerning:' + elementStyle.fontKerning +
            ';font-size:' + elementStyle.fontSize +
            ';font-stretch:' + elementStyle.fontStretch +
            ';font-style:' + elementStyle.fontStyle +
            ';font-letiant:' + elementStyle.fontVariant +
            ';font-letiant-caps:' + elementStyle.fontVariantCaps +
            ';font-letiant-ligatures:' + elementStyle.fontVariantLigatures +
            ';font-letiant-numeric:' + elementStyle.fontVariantNumeric +
            ';font-weight:' + elementStyle.fontWeight +
            ';letter-spacing:' + elementStyle.letterSpacing +
            ';margin-left:' + elementStyle.marginLeft +
            ';margin-right:' + elementStyle.marginRight +
            ';padding-left:' + elementStyle.paddingLeft +
            ';padding-right:' + elementStyle.paddingRight +
            ';text-indent:' + elementStyle.textIndent +
            ';text-transform:' + elementStyle.textTransform;

        let string = element.value || element.getAttribute('placeholder') || '';
        let ghostElement = document.getElementById(GHOST_ELEMENT_ID) || createGhostElement();
        ghostElement.style.cssText += elementCssText;
        ghostElement.innerHTML = escapeSpecialCharacters(string);
        let width = window.getComputedStyle(ghostElement).width;
        element.style.width = width;
        return width
    }

    element.addEventListener('input', setWidth);

    let width = setWidth();

    if (options && options.minWidth && !element.style.minWidth && width !== '0px') {
        element.style.minWidth = width;
    }

    // Return a function for unbinding the event listener and removing the `ghostElement`.
    return function () {
        element.removeEventListener('input', setWidth);
        let ghostElement = document.getElementById(GHOST_ELEMENT_ID);
        if (ghostElement) {
            ghostElement.parentNode.removeChild(ghostElement);
        }
    }
};




var install = function(Vue) {
    Vue.directive('autosize', {
        inserted: function(el, binding) {
            var tagName = el.tagName;
            if (tagName == 'TEXTAREA') {
                autosize(el);
            } else if (tagName == 'INPUT' && el.type == 'text') {
                autoSizeInput(el);
            }
        },

        componentUpdated: function(el, binding, vnode) {
            var tagName = el.tagName;
            if (tagName == 'TEXTAREA') {
                autosize.update(el);
            } else if (tagName == 'INPUT' && el.type == 'text') {
                autoSizeInput(el);
            }
        },

        unbind: function(el) {
            autosize.destroy(el);
        }
    });
};

var src = {
    install: install
};

window.csrf =$('[name=__anti-forgery-token]').val();

Vue$1.config.productionTip = false;
Vue$1.mixin(mixins);
Vue$1.use(src);

new Vue$1({
    store,
    render: h => h(App)
}).$mount("#report-app");
//# sourceMappingURL=report.js.map
